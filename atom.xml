<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[狂奔的菜鸟]]></title>
  <subtitle><![CDATA[当你的实力支撑不起你的野心的时候，静下心来好好学习吧！]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.cxyteam.com/"/>
  <updated>2016-12-21T03:22:16.000Z</updated>
  <id>http://www.cxyteam.com/</id>
  
  <author>
    <name><![CDATA[狂奔的菜鸟]]></name>
    <email><![CDATA[phpchengxuyuan@sina.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[环境变量的设置]]></title>
    <link href="http://www.cxyteam.com/2016/12/21/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BE%E7%BD%AE/"/>
    <id>http://www.cxyteam.com/2016/12/21/环境变量的设置/</id>
    <published>2016-12-21T03:06:19.000Z</published>
    <updated>2016-12-21T03:22:16.000Z</updated>
    <content type="html"><![CDATA[<h1 id="永久对所有用户生效"><a href="#永久对所有用户生效" class="headerlink" title="永久对所有用户生效"></a>永久对所有用户生效</h1><h6 id="修改-etc-profile"><a href="#修改-etc-profile" class="headerlink" title="修改/etc/profile"></a>修改/etc/profile</h6><h6 id="添加如下行-下面的PATH-PATH…是添加的-，对-etc-profile的不同，添加的位置可能不同"><a href="#添加如下行-下面的PATH-PATH…是添加的-，对-etc-profile的不同，添加的位置可能不同" class="headerlink" title="添加如下行(下面的PATH=$PATH…是添加的)，对/etc/profile的不同，添加的位置可能不同"></a>添加如下行(下面的PATH=$PATH…是添加的)，对/etc/profile的不同，添加的位置可能不同</h6><pre><code>pathmunge () {
    case &quot;:${PATH}:&quot; in
        *:&quot;$1&quot;:*)
            ;;
        *)
            if [ &quot;$2&quot; = &quot;after&quot; ] ; then
                PATH=$PATH:$1
            else
                PATH=$1:$PATH
            fi
    esac
        PATH=$PATH:/usr/local/mysql/bin:/usr/local/mysql/sbin:/usr/local/php/sbin:/usr/local/php/bin:/usr/local/nginx/sbin
}
</code></pre><h6 id="source-etc-profile"><a href="#source-etc-profile" class="headerlink" title="source /etc/profile"></a>source /etc/profile</h6><h1 id="永久对当前用户生效（注意要重新登录才生效）"><a href="#永久对当前用户生效（注意要重新登录才生效）" class="headerlink" title="永久对当前用户生效（注意要重新登录才生效）"></a>永久对当前用户生效（注意要重新登录才生效）</h1><h6 id="修改-bash-profile"><a href="#修改-bash-profile" class="headerlink" title="修改~/.bash_profile"></a>修改~/.bash_profile</h6><pre><code>PATH=$PATH:$HOME/bin:/usr/local/mysql/bin
</code></pre><h6 id="source-bash-profile"><a href="#source-bash-profile" class="headerlink" title="source ~/.bash_profile"></a>source ~/.bash_profile</h6><h1 id="临时对当前终端生效（终端断开，换将变量就需要重新设置）"><a href="#临时对当前终端生效（终端断开，换将变量就需要重新设置）" class="headerlink" title="临时对当前终端生效（终端断开，换将变量就需要重新设置）"></a>临时对当前终端生效（终端断开，换将变量就需要重新设置）</h1><h6 id="终端执行命令"><a href="#终端执行命令" class="headerlink" title="终端执行命令"></a>终端执行命令</h6><pre><code>export PATH=$PATH:/usr/local/mysql/sbin
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="永久对所有用户生效"><a href="#永久对所有用户生效" class="headerlink" title="永久对所有用户生效"></a>永久对所有用户生效</h1><h6 id="修改-etc-profile"><a href="#修改-etc-prof]]>
    </summary>
    
      <category term="Linux" scheme="http://www.cxyteam.com/tags/Linux/"/>
    
      <category term="Linux" scheme="http://www.cxyteam.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[rsyslog搭建日志系统]]></title>
    <link href="http://www.cxyteam.com/2016/12/19/rsyslog%E6%90%AD%E5%BB%BA%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <id>http://www.cxyteam.com/2016/12/19/rsyslog搭建日志系统/</id>
    <published>2016-12-19T11:09:44.000Z</published>
    <updated>2016-12-21T08:45:53.000Z</updated>
    <content type="html"><![CDATA[<h2 id="安装rsyslog-请跳转：安装rsyslog"><a href="#安装rsyslog-请跳转：安装rsyslog" class="headerlink" title="安装rsyslog, 请跳转：安装rsyslog"></a>安装rsyslog, 请跳转：<a href="https://github.com/SunnySmilez/Source/tree/master/rsyslog" title="rsyslog搭建日志系统" target="_blank" rel="external">安装rsyslog</a></h2><h6 id="整体部署如图所示："><a href="#整体部署如图所示：" class="headerlink" title="整体部署如图所示："></a>整体部署如图所示：</h6><p><img src="/img/rsyslog/rsyslog_alarm.png" alt="Alt text" title="运行结果"></p>
<h2 id="配置client日志收集到本地"><a href="#配置client日志收集到本地" class="headerlink" title="配置client日志收集到本地"></a>配置client日志收集到本地</h2><h6 id="在-etc-rsyslog-conf中添加一行"><a href="#在-etc-rsyslog-conf中添加一行" class="headerlink" title="在/etc/rsyslog.conf中添加一行"></a>在/etc/rsyslog.conf中添加一行</h6><pre><code>*.* /tmp/rsyslog.log
</code></pre><h6 id="注释一行"><a href="#注释一行" class="headerlink" title="注释一行"></a>注释一行</h6><pre><code>#$IncludeConfig /etc/rsyslog.d/*.conf
</code></pre><h6 id="配置日志收集到本地样例"><a href="#配置日志收集到本地样例" class="headerlink" title="配置日志收集到本地样例"></a><a href="https://github.com/SunnySmilez/Source/blob/master/rsyslog/conf/rsyslog_local.conf" title="配置日志收集到本地" target="_blank" rel="external">配置日志收集到本地样例</a></h6><h6 id="检验配置文件正确性"><a href="#检验配置文件正确性" class="headerlink" title="检验配置文件正确性"></a>检验配置文件正确性</h6><pre><code>rsyslogd -f /etc/rsyslog.conf -N1
</code></pre><h6 id="查看错误信息"><a href="#查看错误信息" class="headerlink" title="查看错误信息"></a>查看错误信息</h6><pre><code>tail -n 100 /var/log/messages
</code></pre><h6 id="重启rsyslog"><a href="#重启rsyslog" class="headerlink" title="重启rsyslog"></a>重启rsyslog</h6><pre><code>/etc/init.d/rsyslog restart
</code></pre><h6 id="测试写入rsyslog日志脚本-位置在-data1-htdocs-rsyslog-input-php"><a href="#测试写入rsyslog日志脚本-位置在-data1-htdocs-rsyslog-input-php" class="headerlink" title="测试写入rsyslog日志脚本(位置在/data1/htdocs/rsyslog_input.php)"></a>测试写入rsyslog日志脚本(位置在/data1/htdocs/rsyslog_input.php)</h6><pre><code>&lt;?php
    $message=&apos;this is test&apos;;
    openlog(&apos;this is test, do you know&apos;, LOG_ODELAY, LOG_LOCAL7);
    syslog(LOG_DEBUG, $message);
    closelog();
</code></pre><h6 id="或者在终端运行（local7指定运行级别）"><a href="#或者在终端运行（local7指定运行级别）" class="headerlink" title="或者在终端运行（local7指定运行级别）"></a>或者在终端运行（local7指定运行级别）</h6><pre><code>#-p 指定自定义的日志设备，和配置文件的local5.*对应
logger -it error  -p local5.info &quot;hello world&quot;
</code></pre><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><h6 id="运行脚本-usr-local-php-bin-php为你php的命令路径"><a href="#运行脚本-usr-local-php-bin-php为你php的命令路径" class="headerlink" title="运行脚本(/usr/local/php/bin/php为你php的命令路径)"></a>运行脚本(/usr/local/php/bin/php为你php的命令路径)</h6><pre><code>/usr/local/php/bin/php /data1/htdocs/rsyslog_input.php
</code></pre><h6 id="安装php环境，请跳转：安装php运行环境"><a href="#安装php环境，请跳转：安装php运行环境" class="headerlink" title="安装php环境，请跳转：安装php运行环境"></a>安装php环境，请跳转：<a href="https://github.com/SunnySmilez/Source/tree/master/lnmp" title="安装php运行环境" target="_blank" rel="external">安装php运行环境</a></h6><h6 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h6><pre><code>在/tmp/rsyslog.log中查看，会有我们记录的内容
</code></pre><h2 id="client传输日志到server"><a href="#client传输日志到server" class="headerlink" title="client传输日志到server"></a>client传输日志到server</h2><h6 id="在-etc-rsyslog-conf文件中删除一行"><a href="#在-etc-rsyslog-conf文件中删除一行" class="headerlink" title="在/etc/rsyslog.conf文件中删除一行"></a>在/etc/rsyslog.conf文件中删除一行</h6><pre><code>*.* /tmp/rsyslog.log
</code></pre><h6 id="在-etc-rsyslog-conf文件中添加一行"><a href="#在-etc-rsyslog-conf文件中添加一行" class="headerlink" title="在/etc/rsyslog.conf文件中添加一行"></a>在/etc/rsyslog.conf文件中添加一行</h6><pre><code>$IncludeConfig /etc/rsyslog.d/*.conf
</code></pre><h6 id="在-etc-rsyslog-d-添加文件client-conf"><a href="#在-etc-rsyslog-d-添加文件client-conf" class="headerlink" title="在/etc/rsyslog.d/添加文件client.conf"></a>在/etc/rsyslog.d/添加文件client.conf</h6><h6 id="需要注意的是target是你的server的地址，配置client传输日志到server文件样例"><a href="#需要注意的是target是你的server的地址，配置client传输日志到server文件样例" class="headerlink" title="需要注意的是target是你的server的地址，配置client传输日志到server文件样例"></a>需要注意的是target是你的server的地址，<a href="https://github.com/SunnySmilez/Source/blob/master/rsyslog/conf/client.conf" title="配置client传输日志到server文件样例" target="_blank" rel="external">配置client传输日志到server文件样例</a></h6><pre><code>if ($syslogfacility-text == &apos;local6&apos;) or ($syslogfacility-text == &apos;local7&apos;) or ($syslogtag == &apos;php:&apos;) or ($msg startswith &apos;PHP&apos;) then {
        action(type=&quot;omfwd&quot;
                        target=&quot;192.168.1.12&quot; port=&quot;514&quot; protocol=&quot;tcp&quot;
                        queue.type=&quot;linkedList&quot;
                        queue.spoolDirectory=&quot;/var/spool/rsyslog&quot;
                        queue.fileName=&quot;fwd_rsyslog.com&quot;
                        queue.maxDiskSpace=&quot;5g&quot;
                        queue.saveOnShutdown=&quot;on&quot;
                        action.resumeRetryCount=&quot;-1&quot;
              )
                ~
}
</code></pre><h6 id="按照上述’配置client日志收集到本地’的步骤，配置好server服务器，如果接收到日志说明没有问题，如果有问题，请用tcpdump查看错误原因"><a href="#按照上述’配置client日志收集到本地’的步骤，配置好server服务器，如果接收到日志说明没有问题，如果有问题，请用tcpdump查看错误原因" class="headerlink" title="按照上述’配置client日志收集到本地’的步骤，配置好server服务器，如果接收到日志说明没有问题，如果有问题，请用tcpdump查看错误原因"></a>按照上述’配置client日志收集到本地’的步骤，配置好server服务器，如果接收到日志说明没有问题，如果有问题，请用tcpdump查看错误原因</h6><h2 id="配置server日志交给脚本处理"><a href="#配置server日志交给脚本处理" class="headerlink" title="配置server日志交给脚本处理"></a>配置server日志交给脚本处理</h2><h6 id="编辑日志处理脚本-data1-htdocs-rsyslog-php"><a href="#编辑日志处理脚本-data1-htdocs-rsyslog-php" class="headerlink" title="编辑日志处理脚本,/data1/htdocs/rsyslog.php"></a>编辑日志处理脚本,/data1/htdocs/rsyslog.php</h6><pre><code>&lt;?php
while(!feof(STDIN)){
        $line = trim(fgets(STDIN));
        if (empty($line)) {
                continue;
        }

        file_put_contents(&apos;/tmp/rsyslog2.log&apos;, $line, FILE_APPEND);
}
</code></pre><h6 id="在-etc-rsyslog-conf文件中删除一行-1"><a href="#在-etc-rsyslog-conf文件中删除一行-1" class="headerlink" title="在/etc/rsyslog.conf文件中删除一行"></a>在/etc/rsyslog.conf文件中删除一行</h6><pre><code>*.* /tmp/rsyslog.log
</code></pre><h6 id="在-etc-rsyslog-conf文件中添加一行-1"><a href="#在-etc-rsyslog-conf文件中添加一行-1" class="headerlink" title="在/etc/rsyslog.conf文件中添加一行"></a>在/etc/rsyslog.conf文件中添加一行</h6><pre><code>$IncludeConfig /etc/rsyslog.d/*.conf
</code></pre><h6 id="在-etc-rsyslog-d-添加文件server-conf，server收集日志交给脚本处理配置文件样例"><a href="#在-etc-rsyslog-d-添加文件server-conf，server收集日志交给脚本处理配置文件样例" class="headerlink" title="在/etc/rsyslog.d/添加文件server.conf，server收集日志交给脚本处理配置文件样例"></a>在/etc/rsyslog.d/添加文件server.conf，<a href="https://github.com/SunnySmilez/Source/blob/master/rsyslog/conf/server.conf" title="server收集日志交给脚本处理配置文件样例" target="_blank" rel="external">server收集日志交给脚本处理配置文件样例</a></h6><pre><code>module(load=&quot;omprog&quot;)

template(name=&quot;log&quot; type=&quot;string&quot; string=&quot;%fromhost-ip% %syslogtag% %msg%\n&quot;)

*.* action(type=&quot;omprog&quot; binary=&quot;/usr/local/php/bin/php /data1/htdocs/rsyslog.php&quot; template=&quot;log&quot;)
*.* ~
</code></pre><h6 id="重启rsyslog-1"><a href="#重启rsyslog-1" class="headerlink" title="重启rsyslog"></a>重启rsyslog</h6><pre><code>/etc/init.d/rsyslog restart
</code></pre><h6 id="在client端写入日志"><a href="#在client端写入日志" class="headerlink" title="在client端写入日志"></a>在client端写入日志</h6><pre><code>/usr/local/php/bin/php /data1/htdocs/rsyslog_input.php
</code></pre><h6 id="在server端查看-tmp-rsyslog2-log的内容，如果有内容写入则整体架构搭建完成，可根据自己的需求去编写日志分析脚本"><a href="#在server端查看-tmp-rsyslog2-log的内容，如果有内容写入则整体架构搭建完成，可根据自己的需求去编写日志分析脚本" class="headerlink" title="在server端查看/tmp/rsyslog2.log的内容，如果有内容写入则整体架构搭建完成，可根据自己的需求去编写日志分析脚本"></a>在server端查看/tmp/rsyslog2.log的内容，如果有内容写入则整体架构搭建完成，可根据自己的需求去编写日志分析脚本</h6><h2 id="将nginx日志接入rsyslog-nginx主动推送"><a href="#将nginx日志接入rsyslog-nginx主动推送" class="headerlink" title="将nginx日志接入rsyslog(nginx主动推送)"></a>将nginx日志接入rsyslog(nginx主动推送)</h2><h6 id="男性交友网站有一个nginx的补丁包-nginx-syslog-patch"><a href="#男性交友网站有一个nginx的补丁包-nginx-syslog-patch" class="headerlink" title="男性交友网站有一个nginx的补丁包,nginx_syslog_patch"></a>男性交友网站有一个nginx的补丁包,<a href="https://github.com/yaoweibin/nginx_syslog_patch" title="nginx_syslog_patch" target="_blank" rel="external">nginx_syslog_patch</a></h6><h6 id="下载包（注意是整个包，不是一个patch的文件）"><a href="#下载包（注意是整个包，不是一个patch的文件）" class="headerlink" title="下载包（注意是整个包，不是一个patch的文件）"></a>下载包（注意是整个包，不是一个patch的文件）</h6><pre><code>git clone https://github.com/splitice/nginx_syslog_patch
</code></pre><h5 id="进入到nginx的安装目录，然后进行patch"><a href="#进入到nginx的安装目录，然后进行patch" class="headerlink" title="进入到nginx的安装目录，然后进行patch"></a>进入到nginx的安装目录，然后进行patch</h5><pre><code>cd /usr/local/nginx-1.4.7 &amp;&amp; patch -p1 &lt; /usr/local/nginx_syslog_patch/syslog_1.4.0.patch
./configure --add-module=/usr/local/nginx_syslog_patch/ --prefix=/usr/local/nginx &amp;&amp; make &amp;&amp; make install
</code></pre><h5 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h5><pre><code>worker_processes  1;
#syslog logcal6 nginx这个很重要哦，只写一次就可以，当然也要看你放在哪里了
syslog local6 nginx;
events {
        worker_connections  1024;
}
http {
    include       mime.types;
    default_type  application/octet-stream;

    log_format  main  &apos;$remote_addr - $remote_user [$time_local] $request &apos;
        &apos;&quot;$status&quot; $body_bytes_sent &quot;$http_referer&quot; &apos;
        &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;
    server {
        listen       80;
        server_name  localhost;
        #send the log to syslog and file.
        access_log  syslog:notice|logs/kinggoo.access.log main;
         error_log syslog:notice|logs/kinggoo.error.log;

        location / {
            root   html;
            index  index.html index.htm;
        }
    }
    server {
        listen       80;
        server_name  www.example.com;

        access_log  syslog:warn|logs/host2.access.log main;
        error_log syslog:warn|logs/host2.error.log;

        location / {
            root   html;
            index  index.html index.htm;
        }
    }
    server {
        listen       80;
        server_name  www.test.com;

        #send the log just to syslog.
        access_log  syslog:error main;
        error_log syslog:error;

        location / {
            root   html;
            index  index.html index.htm;
        }
    }
}
</code></pre><h6 id="重启nginx"><a href="#重启nginx" class="headerlink" title="重启nginx"></a>重启nginx</h6><pre><code>/usr/local/nginx/sbin/nginx -s reload
</code></pre><h6 id="最好是对client和server的rsyslog都进行重启（理论上是可以忽略的）"><a href="#最好是对client和server的rsyslog都进行重启（理论上是可以忽略的）" class="headerlink" title="最好是对client和server的rsyslog都进行重启（理论上是可以忽略的）"></a>最好是对client和server的rsyslog都进行重启（理论上是可以忽略的）</h6><h6 id="访问client的web，查看rsyslog（这里也就是-tmp-rsyslog2-log）中是否记录了nginx的日志"><a href="#访问client的web，查看rsyslog（这里也就是-tmp-rsyslog2-log）中是否记录了nginx的日志" class="headerlink" title="访问client的web，查看rsyslog（这里也就是/tmp/rsyslog2.log）中是否记录了nginx的日志"></a>访问client的web，查看rsyslog（这里也就是/tmp/rsyslog2.log）中是否记录了nginx的日志</h6><h2 id="将php日志写入rsyslog"><a href="#将php日志写入rsyslog" class="headerlink" title="将php日志写入rsyslog"></a>将php日志写入rsyslog</h2><h6 id="修改配置文件-此处的位置是-usr-local-php-etc-php-ini或者通过php-i-grep-php-ini查询"><a href="#修改配置文件-此处的位置是-usr-local-php-etc-php-ini或者通过php-i-grep-php-ini查询" class="headerlink" title="修改配置文件(此处的位置是/usr/local/php/etc/php.ini或者通过php -i | grep php.ini查询)"></a>修改配置文件(此处的位置是/usr/local/php/etc/php.ini或者通过php -i | grep php.ini查询)</h6><pre><code>打开error_log = syslog这一行的注释，没有就添加吧
</code></pre><h6 id="重启php-fpm"><a href="#重启php-fpm" class="headerlink" title="重启php-fpm"></a>重启php-fpm</h6><pre><code>killall php-fpm &amp;&amp; /usr/local/php/sbin/php-fpm
</code></pre><h6 id="测试（故意写了语法错误）"><a href="#测试（故意写了语法错误）" class="headerlink" title="测试（故意写了语法错误）"></a>测试（故意写了语法错误）</h6><pre><code>php -r &quot;echo 11&quot;
</code></pre><h5 id="查看server的-tmp-rsyslog2-log中是否存在日志"><a href="#查看server的-tmp-rsyslog2-log中是否存在日志" class="headerlink" title="查看server的/tmp/rsyslog2.log中是否存在日志"></a>查看server的/tmp/rsyslog2.log中是否存在日志</h5><h2 id="拉取nginx日志"><a href="#拉取nginx日志" class="headerlink" title="拉取nginx日志"></a>拉取nginx日志</h2><h6 id="添加-etc-rsyslog-d-nginx-biglog-conf文件"><a href="#添加-etc-rsyslog-d-nginx-biglog-conf文件" class="headerlink" title="添加/etc/rsyslog.d/nginx-biglog.conf文件"></a>添加/etc/rsyslog.d/nginx-biglog.conf文件</h6><pre><code>$ModLoad imfile
$InputFilePollInterval 10
$WorkDirectory /var/spool/rsyslog
$PrivDropToGroup adm

## Nginx访问日志文件路径，根据实际情况修改:
$InputFileName /usr/local/nginx/logs/access.log
$InputFileTag nginx-access:
$InputFileStateFile stat-nginx-access
$InputFileSeverity info
$InputFilePersistStateInterval 25000
$InputRunFileMonitor

## Nginx错误日志文件路径，根据实际情况修改:
$InputFileName /usr/local/nginx/logs/error.log
$InputFileTag nginx-error:
$InputFileStateFile stat-nginx-error
$InputFileSeverity error
$InputFilePersistStateInterval 25000
$InputRunFileMonitor

## 指定日志格式模板：
$template BiglogFormatNginx,&quot;%msg%\n&quot;

## 注意syslog日志服务器接收地址，根据实际情况修改：
if $programname == &apos;nginx-access&apos; then @10.x.x.x:514;BiglogFormatNginx
if $programname == &apos;nginx-access&apos; then ~
if $programname == &apos;nginx-error&apos; then @10.x.x.x:514;BiglogFormatNginx
if $programname == &apos;nginx-error&apos; then ~
</code></pre><h6 id="重启rsyslog-2"><a href="#重启rsyslog-2" class="headerlink" title="重启rsyslog"></a>重启rsyslog</h6><h6 id="查看server的-tmp-rsyslog2-log中是否存在日志-1"><a href="#查看server的-tmp-rsyslog2-log中是否存在日志-1" class="headerlink" title="查看server的/tmp/rsyslog2.log中是否存在日志"></a>查看server的/tmp/rsyslog2.log中是否存在日志</h6>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="安装rsyslog-请跳转：安装rsyslog"><a href="#安装rsyslog-请跳转：安装rsyslog" class="headerlink" title="安装rsyslog, 请跳转：安装rsyslog"></a>安装rsyslog, 请跳转：<]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[安装lnmp环境]]></title>
    <link href="http://www.cxyteam.com/2016/12/14/%E5%AE%89%E8%A3%85lnmp%E7%8E%AF%E5%A2%83/"/>
    <id>http://www.cxyteam.com/2016/12/14/安装lnmp环境/</id>
    <published>2016-12-14T07:21:17.000Z</published>
    <updated>2016-12-20T12:38:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="注意需要wget的包都已经在source文件夹中存在，可直接下载安装（不过都是tar包，注意使用-tar-zxvf解压）"><a href="#注意需要wget的包都已经在source文件夹中存在，可直接下载安装（不过都是tar包，注意使用-tar-zxvf解压）" class="headerlink" title="注意需要wget的包都已经在source文件夹中存在，可直接下载安装（不过都是tar包，注意使用 tar -zxvf解压）"></a>注意需要wget的包都已经在source文件夹中存在，可直接下载安装（不过都是tar包，注意使用 tar -zxvf解压）</h2><h2 id="安装nginx依赖"><a href="#安装nginx依赖" class="headerlink" title="安装nginx依赖"></a>安装nginx依赖</h2><pre><code>yum install gcc zlib-devel pcre-devel openssl-devel 
</code></pre><h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><pre><code>wget http://nginx.org/download/nginx-1.4.7.tar.gz
tar -zxvf nginx-1.4.7.tar.gz
cd nginx-1.4.7
./configure --prefix=/usr/local/nginx --with-openssl=/usr/include/openssl --with-pcre --with-http_stub_status_module &amp;&amp; make &amp;&amp; make install
useradd www
groupadd www
useradd -g www www
</code></pre><h5 id="启动nginx"><a href="#启动nginx" class="headerlink" title="启动nginx"></a>启动nginx</h5><pre><code>/usr/local/nginx/sbin/nginx
</code></pre><h5 id="查看端口是否启动"><a href="#查看端口是否启动" class="headerlink" title="查看端口是否启动"></a>查看端口是否启动</h5><pre><code>ss -tlun | grep 80  或者 netstat -antlp ¦ grep 80
</code></pre><h2 id="安装mysql依赖"><a href="#安装mysql依赖" class="headerlink" title="安装mysql依赖"></a>安装mysql依赖</h2><pre><code>yum install ncurses-devel perl-Data-Dumper.x86_64 libaio*
</code></pre><h2 id="安装mysql-因为下载的包是已经编译好的，所以直接初始化就好了"><a href="#安装mysql-因为下载的包是已经编译好的，所以直接初始化就好了" class="headerlink" title="安装mysql(因为下载的包是已经编译好的，所以直接初始化就好了)"></a>安装mysql(因为下载的包是已经编译好的，所以直接初始化就好了)</h2><pre><code>wget http://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.35-linux-glibc2.5-x86_64.tar.gz
useradd -M -s /sbin/nologin mysql # -M 不添加家目录，-s不能指定shell登录

tar -zxvf mysql-5.6.35-linux-glibc2.5-x86_64.tar.gz
cp -R mysql-5.6.35-linux-glibc2.5-x86_64.tar.gz /usr/local/mysql
</code></pre><h5 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h5><pre><code>cd /usr/local/mysql
chown -R mysql:mysql ./
scripts/mysql_install_db --user=mysql
chown -R root:root ./

cp support-files/mysql.server /etc/init.d/mysqld        #复制启动脚本
chmod +x /etc/init.d/mysqld                             #添加执行权限
</code></pre><h5 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h5><pre><code>mysqladmin -u root password &quot;123123&quot;                   #账号为root密码为123123
</code></pre><h5 id="添加mysql软连接，php编译安装的时候依赖"><a href="#添加mysql软连接，php编译安装的时候依赖" class="headerlink" title="添加mysql软连接，php编译安装的时候依赖"></a>添加mysql软连接，php编译安装的时候依赖</h5><pre><code>ln -s /usr/local/mysql/lib/mysql/lib* /usr/lib/         
ln -s /usr/local/mysql/lib/mysql/lib* /usr/lib64/
</code></pre><h5 id="启动mysql检查端口启动"><a href="#启动mysql检查端口启动" class="headerlink" title="启动mysql检查端口启动"></a>启动mysql检查端口启动</h5><pre><code>service mysqld start
netstat -antlp ¦ grep 3306 或者 ss -tlun | grep 3306
</code></pre><h2 id="安装php依赖"><a href="#安装php依赖" class="headerlink" title="安装php依赖"></a>安装php依赖</h2><h5 id="安装libmcrypt"><a href="#安装libmcrypt" class="headerlink" title="安装libmcrypt"></a>安装libmcrypt</h5><pre><code>wget -O libmcrypt-2.5.8.tar.bz2 http://sourceforge.net/projects/mcrypt/files/Libmcrypt/2.5.8/libmcrypt-2.5.8.tar.bz2/download
tar -jxvf libmcrypt-2.5.8.tar.bz2
cd libmcrypt-2.5.8
./configure &amp;&amp; make &amp;&amp; make install
</code></pre><h5 id="安装mhash"><a href="#安装mhash" class="headerlink" title="安装mhash"></a>安装mhash</h5><pre><code>wget -O mhash-0.9.9.9.tar.bz2 http://sourceforge.net/projects/mhash/files/mhash/0.9.9.9/mhash-0.9.9.9.tar.bz2/download
tar -jxvf mhash-0.9.9.9.tar.bz2
cd mhash-0.9.9.9
./configure &amp;&amp; make &amp;&amp; make install
</code></pre><h5 id="解决mcrypt依赖"><a href="#解决mcrypt依赖" class="headerlink" title="解决mcrypt依赖"></a>解决mcrypt依赖</h5><pre><code>ln -s /usr/local/lib/libmcrypt* /usr/lib
ln -s /usr/local/lib/libmcrypt* /usr/lib64
ln -s /usr/local/lib/libmhash.* /usr/lib/
ln -s /usr/local/lib/libmhash.* /usr/lib64/
ln -s /usr/local/bin/libmcrypt-config /usr/bin/libmcrypt-config
ln -s /usr/lib64/liblber* /usr/lib/
ln -s /usr/lib64/liblber* /usr/lib64/
</code></pre><h4 id="安装mcrypt"><a href="#安装mcrypt" class="headerlink" title="安装mcrypt"></a>安装mcrypt</h4><pre><code>wget -O mcrypt-2.6.8.tar.gz http://sourceforge.net/projects/mcrypt/files/MCrypt/2.6.8/mcrypt-2.6.8.tar.gz/download
tar -zxvf mcrypt-2.6.8.tar.gz
cd mcrypt-2.6.8
./configure &amp;&amp; make &amp;&amp; make install
</code></pre><h5 id="解决php其他依赖"><a href="#解决php其他依赖" class="headerlink" title="解决php其他依赖"></a>解决php其他依赖</h5><pre><code>yum install -y gcc gcc-c++  make zlib zlib-devel pcre pcre-devel  libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel openssl openssl-devel openldap openldap-devel nss_ldap openldap-clients openldap-servers libxslt-devel autoconf
ln -s /usr/lib64/libldap* /usr/lib/
ln -s /usr/lib64/libldap* /usr/lib64/
</code></pre><h5 id="编辑-etc-ld-so-conf-加入-usr-local-lib-再执行-ldconfig即可"><a href="#编辑-etc-ld-so-conf-加入-usr-local-lib-再执行-ldconfig即可" class="headerlink" title="编辑 /etc/ld.so.conf 加入/usr/local/lib 再执行 ldconfig即可"></a>编辑 /etc/ld.so.conf 加入/usr/local/lib 再执行 ldconfig即可</h5><h2 id="安装php"><a href="#安装php" class="headerlink" title="安装php"></a>安装php</h2><pre><code>wget -O php-7.0.14.tar.gz http://cn2.php.net/get/php-7.0.14.tar.gz/from/this/mirror
tar -jxvf php-7.0.14.tar.gz
cd php-7.0.14
./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-mysqli=/usr/local/mysql/ --with-mysqli=/usr/local/mysql/bin/mysql_config --with-pdo-mysql  --with-iconv-dir=/usr/local/ --with-freetype-dir --with-jpeg-dir --with-png-dir --with-zlib --with-zlib-dir --with-libxml-dir=/usr --enable-xml --disable-rpath --enable-bcmath --enable-shmop --enable-sysvsem --enable-sysvshm --enable-inline-optimization --with-curl  --enable-mbregex  --enable-fpm --enable-mbstring --with-mcrypt --with-gd --enable-gd-native-ttf --with-openssl --with-mhash --enable-pcntl --enable-sockets --with-ldap=/usr/ --with-ldap-sasl --with-xmlrpc --enable-zip --enable-soap --enable-opcache --enable-ftp --enable-calendar --with-xsl --with-gettext --enable-session --enable-ctype --with-kerberos --with-libdir=/lib/ --with-pcre-regex --enable-exif --with-bz2 &amp;&amp; make &amp;&amp; make install
cp php.ini-production /usr/local/php/etc/php.ini
cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf
ln -s /usr/local/php/bin/php /usr/bin/
cp /usr/local/php/etc/php-fpm.d/www.conf.default /usr/local/php/etc/php-fpm.d/demo.conf
/usr/local/php/sbin/php-fpm
</code></pre><h2 id="编辑nginx配置文件"><a href="#编辑nginx配置文件" class="headerlink" title="编辑nginx配置文件"></a>编辑nginx配置文件</h2><h5 id="编辑-usr-local-nginx-conf-nginx-conf，添加解析php文件"><a href="#编辑-usr-local-nginx-conf-nginx-conf，添加解析php文件" class="headerlink" title="编辑/usr/local/nginx/conf/nginx.conf，添加解析php文件"></a>编辑/usr/local/nginx/conf/nginx.conf，添加解析php文件</h5><pre><code>location / {
    root   /data/htdocs;                           # 设置代码根目录     
    index  index.php index.html index.htm;         # 添加index.php的首页文件
}
</code></pre><h5 id="添加如下代码，解析php文件，注意SCRIPT-FILENAME"><a href="#添加如下代码，解析php文件，注意SCRIPT-FILENAME" class="headerlink" title="添加如下代码，解析php文件，注意SCRIPT_FILENAME"></a>添加如下代码，解析php文件，注意SCRIPT_FILENAME</h5><pre><code>location ~ \.php$ {
    fastcgi_pass        127.0.0.1:9000;
    fastcgi_index       index.php;
    fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name; #注意SCRIPT_FILENAME
    include fastcgi_params;
    include fastcgi.conf;
}
</code></pre><h5 id="重启nginx-usr-local-nginx-sbin-nginx"><a href="#重启nginx-usr-local-nginx-sbin-nginx" class="headerlink" title="重启nginx /usr/local/nginx/sbin/nginx"></a>重启nginx /usr/local/nginx/sbin/nginx</h5><h5 id="在-data-htdocs中添加php文件测试"><a href="#在-data-htdocs中添加php文件测试" class="headerlink" title="在/data/htdocs中添加php文件测试"></a>在/data/htdocs中添加php文件测试</h5><h2 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h2><pre><code>yum install redis
redis-server &amp;
</code></pre><h2 id="添加reids拓展"><a href="#添加reids拓展" class="headerlink" title="添加reids拓展"></a>添加reids拓展</h2><h5 id="下载php7对应的redis拓展"><a href="#下载php7对应的redis拓展" class="headerlink" title="下载php7对应的redis拓展"></a>下载php7对应的redis拓展</h5><pre><code>wget https://github.com/phpredis/phpredis/archive/php7.zip
unzip php7.zip
cd phpredis-php7/
/usr/local/php/bin/phpize
./configure --with-php-config=/usr/local/php/bin/php-config &amp;&amp; make &amp;&amp; make install
</code></pre><h5 id="编辑配置文件，添加redis-so拓展"><a href="#编辑配置文件，添加redis-so拓展" class="headerlink" title="编辑配置文件，添加redis.so拓展"></a>编辑配置文件，添加redis.so拓展</h5><pre><code>vim /usr/local/php/etc/php.ini
添加如下行：
extension=redis.so
</code></pre><h5 id="重启nginx-php-fpm"><a href="#重启nginx-php-fpm" class="headerlink" title="重启nginx,php-fpm"></a>重启nginx,php-fpm</h5><h5 id="查看安装结果"><a href="#查看安装结果" class="headerlink" title="查看安装结果"></a>查看安装结果</h5><pre><code>php -i | grep redis
</code></pre><h2 id="安装yaf拓展-用不到yaf框架可以进行以下步骤"><a href="#安装yaf拓展-用不到yaf框架可以进行以下步骤" class="headerlink" title="安装yaf拓展(用不到yaf框架可以进行以下步骤)"></a>安装yaf拓展(用不到yaf框架可以进行以下步骤)</h2><pre><code>wget pecl.php.net//get/yaf-3.0.4.tgz
tar -zxvf yaf-3.0.4.tgz
cd yaf-3.0.4
/usr/local/php/bin/phpize
./configure --with-php-config=/usr/local/php/bin/php-config &amp;&amp; make &amp;&amp; make install
vim /usr/local/php/etc/php.ini
</code></pre><h6 id="修改php-ini配置-添加如下配置"><a href="#修改php-ini配置-添加如下配置" class="headerlink" title="修改php.ini配置(添加如下配置)"></a>修改php.ini配置(添加如下配置)</h6><pre><code>[yaf]
extension=yaf.so
yaf.library=/data1/phplib
yaf.name_suffix=0
yaf.use_namespace=1
yaf.name_separator=&quot;_&quot;
yaf.action_prefer=0
yaf.environ=dev
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h2 id="注意需要wget的包都已经在source文件夹中存在，可直接下载安装（不过都是tar包，注意使用-tar-zxvf解压）"><a href="#注意需要wget的包都已经在source文件夹中存在，可直接下载安装（不过都是tar包，注意使用-tar-zxvf解压）]]>
    </summary>
    
      <category term="Linux" scheme="http://www.cxyteam.com/tags/Linux/"/>
    
      <category term="Linux" scheme="http://www.cxyteam.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[rsyslog配置]]></title>
    <link href="http://www.cxyteam.com/2016/12/06/rsyslog%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.cxyteam.com/2016/12/06/rsyslog配置/</id>
    <published>2016-12-06T13:23:37.000Z</published>
    <updated>2016-12-06T13:38:31.000Z</updated>
    <content type="html"><![CDATA[<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><pre><code>http://www.cnblogs.com/tobeseeker/archive/2013/03/10/2953250.html
http://huoding.com/2014/05/09/347
http://blog.clanzx.net/2013/12/31/rsyslog.html
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><pre><code>http://www.cnblogs.com/tobeseeker/archive/2013/03/10/2]]>
    </summary>
    
      <category term="Linux" scheme="http://www.cxyteam.com/tags/Linux/"/>
    
      <category term="Linux" scheme="http://www.cxyteam.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[linux配置网络]]></title>
    <link href="http://www.cxyteam.com/2016/12/01/linux%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C/"/>
    <id>http://www.cxyteam.com/2016/12/01/linux配置网络/</id>
    <published>2016-12-01T04:01:52.000Z</published>
    <updated>2016-12-03T09:43:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="关闭NetworkManager服务"><a href="#关闭NetworkManager服务" class="headerlink" title="关闭NetworkManager服务"></a>关闭NetworkManager服务</h1><pre><code>service NetworkManager stop
chkconfig NetworkManager off
</code></pre><h1 id="设置网络为桥接模式"><a href="#设置网络为桥接模式" class="headerlink" title="设置网络为桥接模式"></a>设置网络为桥接模式</h1><h1 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h1><h4 id="vi-etc-resolv-conf"><a href="#vi-etc-resolv-conf" class="headerlink" title="vi /etc/resolv.conf"></a>vi /etc/resolv.conf</h4><pre><code>nameserver 202.106.0.20
nameserver 8.8.8.8
</code></pre><h1 id="配置网关"><a href="#配置网关" class="headerlink" title="配置网关"></a>配置网关</h1><h4 id="vi-etc-sysconfig-network"><a href="#vi-etc-sysconfig-network" class="headerlink" title="vi /etc/sysconfig/network"></a>vi /etc/sysconfig/network</h4><pre><code>NETWORKING=yes
HOSTNAME=dev
</code></pre><h1 id="配置IP地址"><a href="#配置IP地址" class="headerlink" title="配置IP地址"></a>配置IP地址</h1><h4 id="vi-etc-sysconfig-network-scripts-ifcfg-eth0"><a href="#vi-etc-sysconfig-network-scripts-ifcfg-eth0" class="headerlink" title="vi /etc/sysconfig/network-scripts/ifcfg-eth0"></a>vi /etc/sysconfig/network-scripts/ifcfg-eth0</h4><pre><code>DEVICE=eth0
BOOTPROTO=static
HWADDR=08:00:27:94:F4:CB
IPADDR=192.168.1.11
NETMASK=255.255.255.0
ONBOOT=yes
GATEWAY=192.168.1.1
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="关闭NetworkManager服务"><a href="#关闭NetworkManager服务" class="headerlink" title="关闭NetworkManager服务"></a>关闭NetworkManager服务</h1><pre><cod]]>
    </summary>
    
      <category term="Linux" scheme="http://www.cxyteam.com/tags/Linux/"/>
    
      <category term="Linux" scheme="http://www.cxyteam.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis源码-目录结构]]></title>
    <link href="http://www.cxyteam.com/2016/11/04/redis%E6%BA%90%E7%A0%81-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>http://www.cxyteam.com/2016/11/04/redis源码-目录结构/</id>
    <published>2016-11-04T01:15:12.000Z</published>
    <updated>2016-11-04T06:59:24.000Z</updated>
    <content type="html"><![CDATA[<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><pre><code>|
|--deps
|
|-- src
   -- adlist.c          双链表结构,用于定义list
   -- ae.c              用于事件的处理
   -- ae_epoll.c        处理epoll事件
   -- ae_evport.c       通过event ports实现处理结构
   -- ae_kqueue.c       实现消息队列的处理
   -- ae_select.c       处理select事件
   -- anet.c            网络处理
   -- aof.c             实现aof模式
   -- asciilogo.h       定义欢迎界面的logo
   -- bio.c             在后台通过线程模式实现io处理
   -- bitops.c          与setbit,getbit相关的位操作
   -- blocked.c         支持类似blpop,wait的阻塞操作
   -- cluster.c         与集群创建,通信相关操作
   -- config.c          配置文件的解析
   -- crc16.c           基于CCITT标准的过滤算法
   -- crc64.c
   -- db.c              c-level数据库api实现
   -- debug.c           调试库和日志输出
   -- dict.c            字典实现
   -- endiancov.c       主机字节序编解码, redis致力于使用little endian来编码
   -- fmacros.h         用于Mac下的兼容性处理
   -- help.h            辅助于命令的提示信息
   -- hyperloglog.c
   -- intset.c          int集合类型实现
   -- lzf_c.c           lzf压缩算法
   -- lzf_d.c
   -- memtest.c         内存测试
   -- muti.c            批量命令操作的原子实现
   -- networking.c      网络通信实现
   -- notify.c
   -- object.c          对象存储类型
   -- pqsort.c          一种快速排序的实现
   -- pubsub.c          用于订阅模式的实现，有点类似于Client广播发送的方式
   -- rand.c            随机序列的生产
   -- rdb.c             rdb数据的load和dump
   -- redis.c           redis数据库的主程序入口
   -- redis-benchmark.c redis基准测试入口
   -- redis-check-aof.c aof文件检查入口
   -- redis-check-dump.c dump文件检查入口
   -- redis-cli.c       redis的shell的客户端
   -- release.c         版本发布信息
   -- replication.c     数据的主从备份
   -- rio.c             流式I/O的读写接口
   -- scripting.c       redis相关协议转换到lua环境下执行
   -- sds.c             强大的字符串处理机制
   -- sentinel.c        redis集群的监护程序
   -- setproctitle.c    程序名信息相关
   -- sha1.c            sha1加密算法
   -- slowlog.c         记录最近一段时间的查询等操作
   -- sort.c            排序算法及辅助函数
   -- syncio.c          同步io的实现
   -- t_hash.c          hash结构
   -- t_list.c          list结构
   -- t_set.c           set结构
   -- t_string.c        string结构
   -- t_zset.c          用两种数据结构存储同一个数据体
   -- util.c            辅助函数
   -- ziplist.c         ziplist结构
   -- zipmap.c          zipmap结构
   -- zmalloc.c         在malloc上进行封装,增加内存开销统计
|
|--tests
|
|--utils
</code></pre><h1 id="源码阅读顺序"><a href="#源码阅读顺序" class="headerlink" title="源码阅读顺序"></a><a href="https://github.com/huangz1990/blog/blob/master/diary/2014/how-to-read-redis-source-code.rst" title="源码阅读顺序" target="_blank" rel="external">源码阅读顺序</a></h1><h3 id="数据结构实现"><a href="#数据结构实现" class="headerlink" title="数据结构实现"></a>数据结构实现</h3><p>sds.h,sds.c                 动态字符串实现<br>adlist.h,adlist.c           双端链表实现<br>dict.h,dict.c               字典的实现</p>
<p>redis.h中的zskiplist结构和zskiplistNode结构,以及t_zset.c中所有以zsl开头的函数,比如zslCreate,zslInsert,zslDeleteNode                 跳跃表实现</p>
<p>hyperloglog.c中的hllhdr结构,以及所有以hll开头的函数。                      HyperLogLog实现</p>
<h3 id="阅读内存编码数据结构实现"><a href="#阅读内存编码数据结构实现" class="headerlink" title="阅读内存编码数据结构实现"></a>阅读内存编码数据结构实现</h3><p>intset.c            整数集合数据结构。<br>ziplist.c           压缩列表数据结构</p>
<h3 id="阅读数据类型实现"><a href="#阅读数据类型实现" class="headerlink" title="阅读数据类型实现"></a>阅读数据类型实现</h3><p>object.c            对象系统实现<br>t_string.c          字符串键的实现<br>t_list.c            列表键的实现<br>t_hash.c            散列键的实现<br>t_set.c             集合键的实现<br>t_zset.c中除zsl开头的函数之外的所有函数           有序集合键的实现<br>hyperloglog.c中所有以pf开头的函数                HyperLogLog 键的实现</p>
<h3 id="阅读数据库实现相关代码"><a href="#阅读数据库实现相关代码" class="headerlink" title="阅读数据库实现相关代码"></a>阅读数据库实现相关代码</h3><p>redis.h文件中的redisDb结构,以及 db.c文件              Redis的数据库实现<br>notify.c                Redis的数据库通知功能实现代码<br>rdb.h和rdb.c             Redis的RDB持久化实现代码<br>aof.c                   Redis 的 AOF 持久化实现代码</p>
<h3 id="选读"><a href="#选读" class="headerlink" title="选读"></a>选读</h3><p>redis.h文件的pubsubPattern结构,以及pubsub.c文件              发布与订阅功能的实现<br>redis.h文件的multiState结构以及multiCmd结构,multi.c文件       事务功能的实现<br>sort.c                      SORT命令的实现<br>bitops.c                    GETBIT,SETBIT等二进制位操作命令的实现</p>
<h3 id="阅读客户端和服务器的相关代码"><a href="#阅读客户端和服务器的相关代码" class="headerlink" title="阅读客户端和服务器的相关代码"></a>阅读客户端和服务器的相关代码</h3><p>ae.c,以及任意一个 ae_*.c文件（取决于你所使用的多路复用库）         Redis 的事件处理器实现<br>networking.c                Redis 的网络连接库，负责发送命令回复和接受命令请求， 同时也负责创建/销毁客户端， 以及通信协议分析等工作<br>redis.h和redis.c中和单机Redis服务器有关的部分            单机 Redis 服务器的实现</p>
<h3 id="选读-1"><a href="#选读-1" class="headerlink" title="选读"></a>选读</h3><p>scripting.c                 Lua 脚本功能的实现<br>slowlog.c                   慢查询功能的实现<br>monitor.c                   监视器功能的实现</p>
<h3 id="阅读多机功能的实现"><a href="#阅读多机功能的实现" class="headerlink" title="阅读多机功能的实现"></a>阅读多机功能的实现</h3><p>replication.c               复制功能的实现代码<br>sentinel.c                  Redis Sentinel 的实现代码<br>cluster.c                   Redis 集群的实现代码</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><pre><code>|
|--deps
|
|-- src
   -- adlist.c          双链表结构,用于定义]]>
    </summary>
    
      <category term="Redis" scheme="http://www.cxyteam.com/tags/Redis/"/>
    
      <category term="Redis" scheme="http://www.cxyteam.com/categories/Redis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gdb调试redis]]></title>
    <link href="http://www.cxyteam.com/2016/11/02/gdb%E8%B0%83%E8%AF%95redis/"/>
    <id>http://www.cxyteam.com/2016/11/02/gdb调试redis/</id>
    <published>2016-11-02T02:46:04.000Z</published>
    <updated>2016-11-02T03:02:53.000Z</updated>
    <content type="html"><![CDATA[<p>#<br>启动redis redis-server<br>连接redis redis-cli<br>获取进程id redis-cli info | grep process_id<br>gdb调试进程id sudo gdb -p pid<br>gdb查询代码 list<br>gdb 设置断点 break main</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>#<br>启动redis redis-server<br>连接redis redis-cli<br>获取进程id redis-cli info | grep process_id<br>gdb调试进程id sudo gdb -p pid<br>gdb查询代码 list<br]]>
    </summary>
    
      <category term="Redis" scheme="http://www.cxyteam.com/tags/Redis/"/>
    
      <category term="Redis" scheme="http://www.cxyteam.com/categories/Redis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gdb调试]]></title>
    <link href="http://www.cxyteam.com/2016/10/26/gdb%E8%B0%83%E8%AF%95/"/>
    <id>http://www.cxyteam.com/2016/10/26/gdb调试/</id>
    <published>2016-10-25T23:44:26.000Z</published>
    <updated>2016-11-01T06:27:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="调试文件内容gdb-c"><a href="#调试文件内容gdb-c" class="headerlink" title="调试文件内容gdb.c"></a>调试文件内容gdb.c</h1><pre><code>#include &lt;stdio.h&gt;

int add_range(int low, int high)
{
        int i, sum;
        for (i = low; i &lt;= high; i++)
                sum = sum + i;
        return sum;
}

int main(void)
{
        int result[100];
        result[0] = add_range(1, 10);
        result[1] = add_range(1, 100);
        printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);
        return 0;
}
</code></pre><h1 id="编译文件"><a href="#编译文件" class="headerlink" title="编译文件"></a>编译文件</h1><pre><code>gcc -g gdb.c -o gdbtest
</code></pre><h1 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h1><pre><code>./gdbtest
</code></pre><p><img src="/img/gdb_test/result.png" alt="Alt text" title="运行结果"><br>很明显运行的结果是不对的:1加到10的结果是55,但是1加到100的,结果应该是5050才对,而不是5105,下面用两种gdb方式进行调试</p>
<h1 id="启动gdb"><a href="#启动gdb" class="headerlink" title="启动gdb"></a>启动gdb</h1><pre><code>sudo gdb gdbtest
</code></pre><p><img src="/img/gdb_test/gdb.png" alt="Alt text" title="启动gdb"></p>
<h1 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h1><pre><code>l
</code></pre><p>l以后直接进行回车能够查看到后续的内容<br><img src="/img/gdb_test/list.png" alt="Alt text" title="启动gdb"></p>
<h1 id="断点调试法"><a href="#断点调试法" class="headerlink" title="断点调试法"></a>断点调试法</h1><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><pre><code>break 16                #设置16行为断点
break add_range         #设置add_range函数为断点
info break              #查看断点信息
break在你认为关键的,需要输出的位置进行设置
</code></pre><p><img src="/img/gdb_test/break.png" alt="Alt text" title="启动gdb"></p>
<h3 id="开启调试"><a href="#开启调试" class="headerlink" title="开启调试"></a>开启调试</h3><pre><code>start               #运行程序
n                   #单条语句执行，进入下一条
print i             #达因变量i的值
print sum
c                   #可以想象成continue的功能
当执行完c之后不知道代码执行到那个位置了,可以使用bt进行查看
</code></pre><p><img src="/img/gdb_test/start_break.png" alt="Alt text" title="断点输出"></p>
<h3 id="bt查看函数的堆栈"><a href="#bt查看函数的堆栈" class="headerlink" title="bt查看函数的堆栈"></a>bt查看函数的堆栈</h3><pre><code>如下图,表示在gdb.c的文件的第15行的main函数中调用了gdb.c文件中第六航的add_range函数,参数为low=1,high=100
    #0  add_range (low=1, high=100) at gdb.c:6
    #1  0x0000000100000f07 in main () at gdb.c:15
</code></pre><p><img src="/img/gdb_test/bt.png" alt="Alt text" title="查看函数堆栈"></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><pre><code>当我们在调试的时候,可以看出i和sum没有被初始化,而在循环中i进行了初始化,所以问题不大,sum执行完第一次调用后的值是55,所以最终运行完1到10相加,再运行1到100相加的最终结果是5105
</code></pre><h1 id="顺序调试"><a href="#顺序调试" class="headerlink" title="顺序调试"></a>顺序调试</h1><h3 id="查看mian函数-不能发现问题处在哪"><a href="#查看mian函数-不能发现问题处在哪" class="headerlink" title="查看mian函数,不能发现问题处在哪"></a>查看mian函数,不能发现问题处在哪</h3><pre><code>首先我们看到gdb停在第14行的位置,执行了add_range的函数调用,正等待我们执行命令
14        result[0] = add_range(1, 10);
接着我们执行了n,gdb执行下一条命令,
15        result[1] = add_range(1, 100);
最后知道输出结果
</code></pre><p><img src="/img/gdb_test/step_start.png" alt="Alt text" title="调试main函数"></p>
<h3 id="进入子函数add-range中-查看具体的执行步骤"><a href="#进入子函数add-range中-查看具体的执行步骤" class="headerlink" title="进入子函数add_range中,查看具体的执行步骤"></a>进入子函数add_range中,查看具体的执行步骤</h3><pre><code>调试子函数的第一次调用,gdb停留在add_range(1,10)这行代码的位置,直接使用s进入子函数
Temporary breakpoint 3, main () at gdb.c:14
14        result[0] = add_range(1, 10);
(gdb) s
add_range (low=1, high=10) at gdb.c:6
6        for (i = low; i &lt;= high; i++)

接着直接回车进入下一步,在使用info locals进行当前栈帧局部变量的值,也就是add_range函数中i和sum的值
在使用f 1进入1号栈帧也就是main函数中,查看main栈帧局部变量的值(info locals)
本次调用(add_range(1,10))没有错误,直接使用finish运行完当前函数,并让gdb回到main函数中,等待命令发出
</code></pre><p><img src="/img/gdb_test/subfunc_start.png" alt="Alt text" title="调试子函数"></p>
<pre><code>让gdb进入下一条命令(n),
(gdb) n
    15        result[1] = add_range(1, 100);

再进入子函数(add_range(1,100))中,并查看当前栈帧局部变量的值
(gdb) s
    add_range (low=1, high=100) at gdb.c:6
    6        for (i = low; i &lt;= high; i++)

发现当前的i和sum没有进行初始化,还是上次函数add_range(1,10)执行完后的结果
(gdb) info locals
i = 11
sum = 55

使用bt查看函数的调用栈(当前调用add_range的蚕食是low=1,high=100),
(gdb) bt
    #0  add_range (low=1, high=100) at gdb.c:6
    #1  0x0000000100000f07 in main () at gdb.c:15

并进入下一步,设置i和sum的初始值(set var i=0),
(gdb) set var i=0
    (gdb) set var sum=0
    (gdb) s
    7            sum = sum + i;

接着确认当前i和sum的值(p i),
(gdb) p i
    $2 = 1
    (gdb) p sum
    $3 = 0

在用finish连续运行完当前函数,结果返回的值为5050
(gdb) finish
    Run till exit from #0  add_range (low=1, high=100) at gdb.c:7
    0x0000000100000f07 in main () at gdb.c:15
    15        result[1] = add_range(1, 100);
    Value returned is $4 = 5050

也就是说,函数返回了正确的结果,错误原因是在第一次add_range的调用之后,没有对i和sum进行初始化
</code></pre><p><img src="/img/gdb_test/subfunc_end.png" alt="Alt text" title="调试子函数"></p>
<h1 id="命令总结"><a href="#命令总结" class="headerlink" title="命令总结"></a>命令总结</h1><pre><code>命令                           描述
backtrace（或bt）              查看各级函数调用及参数
finish                        连续运行到当前函数返回为止，然后停下来等待命令
frame（或f）                   帧编号    选择栈帧
info（或i）locals              查看当前栈帧局部变量的值
list（或l）                      列出源代码，接着上次的位置往下列，每次列10行
list 行号                      列出从第几行开始的源代码
list 函数名                      列出某个函数的源代码
next（或n）                      执行下一行语句
print（或p）                      打印表达式的值，通过表达式可以修改变量的值或者调用函数
quit（或q）                      退出gdb调试环境
set var                          修改变量的值
start                          开始执行程序，停在main函数第一行语句前面等待命令
step（或s）                      执行下一行语句，如果有函数调用则进入到函数中
next(或n)                     执行下一条语句
break 行号                     在源码的行数设置断点
break 函数名                   在函数的入口处,设置断点
info break                    查看断点信息
continue(或c)                 继续运行程序
print(或p) 变量名名            打印变量的值
frame(或f)                    选择栈帧
set var                       修改变量的值


==========
其他事例中没用到的命令
call 函数                     调用函数
print 函数                    调用函数
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="调试文件内容gdb-c"><a href="#调试文件内容gdb-c" class="headerlink" title="调试文件内容gdb.c"></a>调试文件内容gdb.c</h1><pre><code>#include &lt;stdio.h&gt;

]]>
    </summary>
    
      <category term="C" scheme="http://www.cxyteam.com/tags/C/"/>
    
      <category term="C" scheme="http://www.cxyteam.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mac安装gdb]]></title>
    <link href="http://www.cxyteam.com/2016/10/21/mac%E5%AE%89%E8%A3%85gdb/"/>
    <id>http://www.cxyteam.com/2016/10/21/mac安装gdb/</id>
    <published>2016-10-21T09:32:25.000Z</published>
    <updated>2016-10-25T00:33:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Mac安装GDB"><a href="#Mac安装GDB" class="headerlink" title="Mac安装GDB"></a>Mac安装GDB</h1><h3 id="安装GDB"><a href="#安装GDB" class="headerlink" title="安装GDB"></a>安装GDB</h3><pre><code>brew install gdb
</code></pre><h1 id="使用gdb进行调试"><a href="#使用gdb进行调试" class="headerlink" title="使用gdb进行调试"></a>使用gdb进行调试</h1><h3 id="gbd-c文件中的内容"><a href="#gbd-c文件中的内容" class="headerlink" title="gbd.c文件中的内容"></a>gbd.c文件中的内容</h3><pre><code>#include &lt;stdio.h&gt;

int add_range(int low, int high)
{
        int i, sum;
        for (i = low; i &lt;= high; i++)
                sum = sum + i;
        return sum;
}

int main(void)
{
        int result[100];
        result[0] = add_range(1, 10);
        result[1] = add_range(1, 100);
        printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);
        return 0;
}
</code></pre><h3 id="编译并使用gdb"><a href="#编译并使用gdb" class="headerlink" title="编译并使用gdb"></a>编译并使用gdb</h3><pre><code>gcc -g gdb.c -o gdbtest &amp;&amp; gdb gdbtest
</code></pre><h3 id="gdb开始调试"><a href="#gdb开始调试" class="headerlink" title="gdb开始调试"></a>gdb开始调试</h3><pre><code>start
</code></pre><h3 id="mac下出现如下错误"><a href="#mac下出现如下错误" class="headerlink" title="mac下出现如下错误"></a>mac下出现如下错误</h3><p><img src="/img/mac_gdb/gdb-error.png" alt="Alt text" title="gdb错误信息"></p>
<h3 id="mac下对gdb进行签名"><a href="#mac下对gdb进行签名" class="headerlink" title="mac下对gdb进行签名"></a>mac下对gdb进行签名</h3><p><img src="/img/mac_gdb/key.png" alt="Alt text" title="启动key"></p>
<p><img src="/img/mac_gdb/create-key.png" alt="Alt text" title="创建证书"></p>
<p><img src="/img/mac_gdb/gdb-cert-first.png" alt="Alt text" title="选择代码签名"></p>
<p><img src="/img/mac_gdb/gdb-cert-second.png" alt="Alt text" title="设置过期时间"></p>
<h3 id="接下来所有步骤都选择默认选项-直到选择证书存储的时候选择系统"><a href="#接下来所有步骤都选择默认选项-直到选择证书存储的时候选择系统" class="headerlink" title="接下来所有步骤都选择默认选项,直到选择证书存储的时候选择系统"></a>接下来所有步骤都选择默认选项,直到选择证书存储的时候选择系统</h3><p><img src="/img/mac_gdb/gdb-cert-third.png" alt="Alt text" title="选择存储位置"></p>
<h3 id="创建的证书"><a href="#创建的证书" class="headerlink" title="创建的证书"></a>创建的证书</h3><p><img src="/img/mac_gdb/gdb-cert-last.png" alt="Alt text" title="证书"></p>
<h3 id="设置信任"><a href="#设置信任" class="headerlink" title="设置信任"></a>设置信任</h3><p><img src="/img/mac_gdb/gdb-auth-1.png" alt="Alt text" title="找到证书简介"><br><img src="/img/mac_gdb/gdb-auth-2.png" alt="Alt text" title="设置代码签名始终信任"></p>
<h1 id="对gdb进行代码签名"><a href="#对gdb进行代码签名" class="headerlink" title="对gdb进行代码签名"></a>对gdb进行代码签名</h1><h3 id="关闭taskgated进程"><a href="#关闭taskgated进程" class="headerlink" title="关闭taskgated进程"></a>关闭taskgated进程</h3><p><img src="/img/mac_gdb/gdb-cert-sign-1.png" alt="Alt text" title="打开活动检测器"><br><img src="/img/mac_gdb/taskgated.png" alt="Alt text" title="检索taskgated进程并退出"></p>
<h3 id="对gdb进行签名"><a href="#对gdb进行签名" class="headerlink" title="对gdb进行签名"></a>对gdb进行签名</h3><pre><code>codesign -s gdb-cert /usr/local/bin/gdb
</code></pre><h3 id="检测是否安装成功"><a href="#检测是否安装成功" class="headerlink" title="检测是否安装成功"></a>检测是否安装成功</h3><pre><code>codesign -v gdb (`如果没有任何信息输出代表签名成功`)
</code></pre><h3 id="再次使用gdb进行调试"><a href="#再次使用gdb进行调试" class="headerlink" title="再次使用gdb进行调试"></a>再次使用gdb进行调试</h3><pre><code>gcc -g gdb.c -o gdbtest &amp;&amp; sudo gdb gdbtest (`注意sudo不能少,这个坑我趟了好几个小时,最终在google找到答案`)
start
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Mac安装GDB"><a href="#Mac安装GDB" class="headerlink" title="Mac安装GDB"></a>Mac安装GDB</h1><h3 id="安装GDB"><a href="#安装GDB" class="headerlink]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis源码阅读-准备工作]]></title>
    <link href="http://www.cxyteam.com/2016/10/21/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    <id>http://www.cxyteam.com/2016/10/21/redis源码阅读-准备工作/</id>
    <published>2016-10-21T09:29:44.000Z</published>
    <updated>2016-11-04T02:33:01.000Z</updated>
    <content type="html"><![CDATA[<h1 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h1><h1 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h1>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h1><h1 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h]]>
    </summary>
    
      <category term="Redis" scheme="http://www.cxyteam.com/tags/Redis/"/>
    
      <category term="Redis" scheme="http://www.cxyteam.com/categories/Redis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Primary script unknown排查]]></title>
    <link href="http://www.cxyteam.com/2016/10/21/Primary-script-unknown%E6%8E%92%E6%9F%A5/"/>
    <id>http://www.cxyteam.com/2016/10/21/Primary-script-unknown排查/</id>
    <published>2016-10-21T04:21:14.000Z</published>
    <updated>2016-10-21T09:27:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>#<br>    tcpdump  -i  lo -Anns0 port 9000</p>
<p>#<br>    ps aux|grep fpm|grep -v grep |awk ‘{printf “ -p “ $2}’<br>    strace</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>#<br>    tcpdump  -i  lo -Anns0 port 9000</p>
<p>#<br>    ps aux|grep ]]>
    </summary>
    
      <category term="PHP" scheme="http://www.cxyteam.com/tags/PHP/"/>
    
      <category term="PHP" scheme="http://www.cxyteam.com/categories/PHP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言进程间通信]]></title>
    <link href="http://www.cxyteam.com/2016/10/16/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://www.cxyteam.com/2016/10/16/C语言进程间通信/</id>
    <published>2016-10-16T08:02:11.000Z</published>
    <updated>2016-10-18T02:14:12.000Z</updated>
    <content type="html"><![CDATA[<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><pre><code>标准输入:stdin          对应描述符:0
标准输出:stdout         对应描述符:1
标准错误:stderr         对应描述符:2
</code></pre><h1 id="重定向数据流"><a href="#重定向数据流" class="headerlink" title="重定向数据流"></a>重定向数据流</h1><pre><code>重定向输出数据流 &quot;&gt;&quot;,&quot;&gt;&gt;&quot;
重定向输入数据流 &quot;&lt;&quot;,&quot;&lt;&lt;&quot;
</code></pre><h1 id="fileni返回描述符号"><a href="#fileni返回描述符号" class="headerlink" title="fileni返回描述符号"></a>fileni返回描述符号</h1><h1 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h1>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><pre><code>标准输入:stdin          对应描述符:0
标准输出:stdout         对应描述符:1
标准]]>
    </summary>
    
      <category term="C" scheme="http://www.cxyteam.com/tags/C/"/>
    
      <category term="C" scheme="http://www.cxyteam.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言进程与系统调用]]></title>
    <link href="http://www.cxyteam.com/2016/10/14/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://www.cxyteam.com/2016/10/14/C语言进程与系统调用/</id>
    <published>2016-10-14T02:34:53.000Z</published>
    <updated>2016-10-16T07:57:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="execl-execlp-execle"><a href="#execl-execlp-execle" class="headerlink" title="execl,execlp,execle"></a>execl,execlp,execle</h1><pre><code>第一个参数是exec系列函数告诉将要运行什么程序(区别就是execlp可以就是命令的名字,而execl和execle需要完整路径名)
第一个命令行的参数必须是程序名,因此第二个参数和第一个参数是一致的
中间都被当做脚本所需要的参数
最后一个参数是NULL,告诉函数没有其他参数了
如果是以e结尾的exec系列函数(例如execle),还可以传递环境变量数组

例子:
execl(&apos;/tmp/test&apos;, &apos;/tmp/test&apos;, &apos;param1&apos;, &apos;param2&apos;, &apos;param3&apos;, NULL);
execlp(&apos;test&apos;, &apos;test&apos;, &apos;param1&apos;, &apos;param2&apos;, &apos;param3&apos;, NULL);
execle(&apos;/tmp/test&apos;, &apos;/tmp/test&apos;, &apos;param1&apos;, &apos;param2&apos;, &apos;param3&apos;, NULL, env_vars);
</code></pre><h1 id="execv-execvp-execve"><a href="#execv-execvp-execve" class="headerlink" title="execv,execvp,execve"></a>execv,execvp,execve</h1><pre><code>参数类型,只是把后面的参数传递给了数组

例子:
execv(&apos;/tmp/test&apos;, my_args);
execvp(&apos;test&apos;, my_args);
</code></pre><h1 id="错误信息的一些规定"><a href="#错误信息的一些规定" class="headerlink" title="错误信息的一些规定"></a>错误信息的一些规定</h1><pre><code>不允许操作               1
没有该文件或目录          2
没有改进程               3
错误                    -1
正常返回                 0
</code></pre><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><pre><code>#include &lt;stdio.h&gt;
/*
    为了使用exec函数
*/
#include &lt;unistd.h&gt;
/*
    为了使用errno变量
*/
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

int main()
{
    if (execl(&quot;/sbin/ifconfig&quot;, &quot;/sbin/ifconfig&quot;, NULL) == -1)
    {
        if (execlp(&quot;ipconfig&quot;, &quot;ipconfig&quot;, NULL) == -1)
        {
            fprintf(stderr, &quot;Cannot run ipconfig: %s&quot;, strerror(errno));

            return 1;
        }
    }

    return 0;
}
</code></pre><h1 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h1><pre><code>fork会向子进程返回0,父进程返回非0值
</code></pre><h1 id="copy-on-write"><a href="#copy-on-write" class="headerlink" title="copy-on-write"></a>copy-on-write</h1><pre><code>为了让fork进程变快,操作系统做了很多技巧,比如操作系统不会真的复制父进程的数据,而是让父子进程共享数据,当子进程需要修改存储器,就会为他复制一份数据
</code></pre><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><pre><code>exec系列函数执行的时候会启动一个进程,后面的代码不会运行
伪代码:
    code1
    exec系列函数
    code2
    此例中的code2代码不会再运行

如果需要运行获取多个exec系列函数的结果需要使用fork进行
伪代码:
    code1
    pid_t pid_t = fork();
    exec系列函数
    pid_t pid_t = fork();
    exec系列函数
</code></pre><h1 id="事例-此事例中需要安装python环境-下载rss-gossip脚本https-github-com-dogriffiths-rssgossip-zipball-master"><a href="#事例-此事例中需要安装python环境-下载rss-gossip脚本https-github-com-dogriffiths-rssgossip-zipball-master" class="headerlink" title="事例(此事例中需要安装python环境,下载rss gossip脚本https://github.com/dogriffiths/rssgossip/zipball/master)"></a>事例(此事例中需要安装python环境,下载rss gossip脚本<a href="https://github.com/dogriffiths/rssgossip/zipball/master" target="_blank" rel="external">https://github.com/dogriffiths/rssgossip/zipball/master</a>)</h1><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;

 int main(int argc, char *argv[])
 {
    char *feeds[] = {&quot;http://wwww.cnn.com/rss/celebs.xml&quot;,
                    &quot;http://www.rollingstone/rock.xml&quot;,
                    &quot;http://eonline.com/gossip.xml&quot;
                    };
    int times = 3;
    char *phrase = argv[1];
    int i;
    for(i = 0; i&lt; times; i++) {
        char var[255];
        sprintf(var, &quot;RSS_FEED=%s&quot;, feeds[i]);
        char *vars[] = {var, NULL};
        /*
            pid_t是可以理解成一种int的类型
        */
        pid_t pid_t = fork();
        if (pid_t == -1) {
            fprintf(stderr, &quot;can&apos;t fork process:%s\n&quot;, strerror(errno));
            return 1;
        }

        if (!pid_t &amp;&amp; execle(&quot;/usr/bin/python&quot;, &quot;/usr/bin/python&quot;, &quot;./rssgossip.py&quot;, phrase, NULL, vars) == -1) {
            fprintf(stderr, &quot;can&apos;t run script:%s\n&quot;, strerror(errno));
            return 1;
        }
    }

    return 0;
 }
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="execl-execlp-execle"><a href="#execl-execlp-execle" class="headerlink" title="execl,execlp,execle"></a>execl,execlp,execle</h1><pre>]]>
    </summary>
    
      <category term="C" scheme="http://www.cxyteam.com/tags/C/"/>
    
      <category term="C" scheme="http://www.cxyteam.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言静态库和动态库]]></title>
    <link href="http://www.cxyteam.com/2016/09/11/C%E8%AF%AD%E8%A8%80%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    <id>http://www.cxyteam.com/2016/09/11/C语言静态库和动态库/</id>
    <published>2016-09-11T08:51:13.000Z</published>
    <updated>2016-09-13T10:10:26.000Z</updated>
    <content type="html"><![CDATA[<h1 id="实现文件共享"><a href="#实现文件共享" class="headerlink" title="实现文件共享"></a>实现文件共享</h1><pre><code>例子:
目录结构如下:
|--myHeader
  --checksum.h
  --encrypt.h
|--checksum.c
|--encrypt.c
|--test.c
|--myObject

在myHeader文件中建立头文件checksum.h
int checksum(char *message);
在myHeader文件中建立头文件encrypt.h
void encrypt(char *message);

checksum.c内容:
#include &lt;checksum.h&gt;

int checksum(char *message)
{
 int c = 0;
 while (*message) {
     c += c ^ (int)(*message);
     message++;
 }

 return c;
}

encrypt.c内容:
#include &quot;./myHeader/encrypt.h&quot;

void encrypt(char *message)
{
 char c;
 while(*message) {
     *message = *message ^ 31;
     message++;
 }
}

test.c的内容:
#include &lt;stdio.h&gt;
#include &quot;./myHeader/encrypt.h&quot;
#include &quot;./myHeader/checksum.h&quot;

int main()
{
     char s[] = &quot;Speak friend and enter&quot;;
     encrypt(s);
     printf(&quot;Encrypt to &apos;%s&apos;\n&quot;, s);
     printf(&quot;checksum is %i\n&quot;, checksum(s));
     encrypt(s);
     printf(&quot;Decrypt to &apos;%s&apos;\n&quot;, s);
     printf(&quot;checksum is %i\n&quot;, checksum(s));
     return 0;
}

/*
    把头文件和编译后的文件都保存在固定的文件中方便共享(myHeader和myObject)
    -I告诉编译器去哪里找头文件
*/
执行命令:(执行命令每次都要指定.o的文件路径,是不是太麻烦?)
    gcc -I ./myHeader -c checksum.c -o ./myObject/checksum.o
    gcc -I ./myHeader -c encrypt.c -o ./myObject/encrypt.o
    gcc -I ./myHeader test.c ./myObject/checksum.o ./myObject/encrypt.o -o test &amp;&amp; ./test
</code></pre><h1 id="创建静态库的方式"><a href="#创建静态库的方式" class="headerlink" title="创建静态库的方式"></a>创建静态库的方式</h1><pre><code>/*
    r:如果.a文件存在就更新它
    c:表示创建存档时不显示反馈信息
    s:告诉ar要在.a文件开头建立索引
    创建的文件名:libhfsecurity.a
    ** 静态库名字的命名规范一般是:libxxx.a的形式,不然编译器无法找到它
*/
ar -rcs libhfsecurity.a encrypt.o checksum.o

/*
    可以查看.a文件是由那些文件组成
*/
ar -t libhfsecurity.a

/*
    lhfsecurity对应去寻找上面创建的静态库的名字:libhfsecurity.a
    -I指定头文件位置
    -L告诉编译器去哪寻找存档
    当然如果你把.a的文件放在/usr/local/lib(用来存放本地自定义库或者系统类库/usr/lib)中,可以不指定-L参数
    gcc test.c  -lhfsecurity -o test
*/
gcc -I ./myHeader test.c -L myObject -lhfsecurity -o test &amp;&amp; ./test
</code></pre><h1 id="静态库例子"><a href="#静态库例子" class="headerlink" title="静态库例子"></a>静态库例子</h1><pre><code>目录结构:
|--myHeader
  --hfcal.h
|--myObject
|--treadmill
  --elliptical.c
  --hfcal.c

hfcal.h中的内容:
    void display_calories(float weight, float distance, float coeff);

hfcal.c文件中的内容:
    #include &lt;stdio.h&gt;
    #include &lt;hfcal.h&gt;

    void display_calories(float weight, float distance, float coeff)
    {
        printf(&quot;Weight:%3.2f lbs\n&quot;, weight);
        printf(&quot;Distance:%3.2f miles\n&quot;, distance);
        printf(&quot;Calories burned:%4.2f cal\n&quot;, coeff * weight * distance);
    }

elliptical.c文件中的内容:
    #include &lt;stdio.h&gt;
    #include &lt;hfcal.h&gt;

    int main()
    {
        display_calories(115.2, 11.3, 0.79);
        return 0;
    }

cd treadmill
gcc -I ../myHeader -c hfcal.c -o ../myObject/hfcal.o
gcc -I ../myHeader -c elliptical.c -o ../myObject/elliptical.o
ar -rcs ../myObject/libhfcal.a ../myObject/hfcal.o
cd ../myObject
gcc elliptical.o -L ./ -lhfcal -o elliptical
</code></pre><h1 id="创建动态库"><a href="#创建动态库" class="headerlink" title="创建动态库"></a>创建动态库</h1><pre><code>/*
    -I指定头文件目录,-c不要链接代码,-fPIC创建位置无关代码创建库
*/
gcc -I ../myHeader -fPIC -c hfcal.c -o ../myObject/hfcal.o

/*
    --shared告诉gcc把目标文件转化为动态库
    动态库在每个系统的后缀名都不一样
    windows中后缀名是.dll
    在linux和unix尚后缀名是.so
   在mac上后缀名是是.dylib
*/
cd ../myObject/


/*
    在一些稍微老一点的mac系统上,没有-shared选项,可以使用-dynamiclib代替
*/
                        libhfcal.dll.a      #windows上的cygwin
                        libhfcal.dylib         #mac
gcc -shared hfcal.o -o  hfcal.dll           #windows上的mingw
                        libhfcal.so         #linux或unix

cd ../treadmill/
gcc -I ../myHeader -c elliptical.c -o ../myObject/elliptical.o
cd ../myObject/

/*
    在linux和大部分unix中,编译器只会记录libhfcal.so库的文件名,而不会包含路径名,也就是说如果不把hfcal库保存到标准目录(/usr/lib),程序就找不到它
    一般解决方法是:把库目录添加到LD_LIBRARY_PATH中,并export它
    export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./
*/
gcc elliptical.o -L ./ -lhfcal -o elliptical
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="实现文件共享"><a href="#实现文件共享" class="headerlink" title="实现文件共享"></a>实现文件共享</h1><pre><code>例子:
目录结构如下:
|--myHeader
  --checksum.h
  --enc]]>
    </summary>
    
      <category term="C" scheme="http://www.cxyteam.com/tags/C/"/>
    
      <category term="C" scheme="http://www.cxyteam.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[代码设计]]></title>
    <link href="http://www.cxyteam.com/2016/09/09/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"/>
    <id>http://www.cxyteam.com/2016/09/09/代码设计/</id>
    <published>2016-09-09T09:29:39.000Z</published>
    <updated>2016-09-11T08:07:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="暂未找到合适的表述方法"><a href="#暂未找到合适的表述方法" class="headerlink" title="暂未找到合适的表述方法"></a>暂未找到合适的表述方法</h1>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="暂未找到合适的表述方法"><a href="#暂未找到合适的表述方法" class="headerlink" title="暂未找到合适的表述方法"></a>暂未找到合适的表述方法</h1>]]>
    </summary>
    
      <category term="Other" scheme="http://www.cxyteam.com/tags/Other/"/>
    
      <category term="Other" scheme="http://www.cxyteam.com/categories/Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git的使用]]></title>
    <link href="http://www.cxyteam.com/2016/09/02/git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.cxyteam.com/2016/09/02/git的使用/</id>
    <published>2016-09-02T04:17:48.000Z</published>
    <updated>2016-09-07T11:21:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="初始化一个git项目"><a href="#初始化一个git项目" class="headerlink" title="初始化一个git项目"></a>初始化一个git项目</h1><pre><code>git init
</code></pre><h1 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h1><pre><code>git add filename
</code></pre><h1 id="添加目录"><a href="#添加目录" class="headerlink" title="添加目录"></a>添加目录</h1><pre><code>git add .
</code></pre><h1 id="只提交已提交过得文件-不添加新增文件-只添加修改的文件"><a href="#只提交已提交过得文件-不添加新增文件-只添加修改的文件" class="headerlink" title="只提交已提交过得文件(不添加新增文件,只添加修改的文件)"></a>只提交已提交过得文件(不添加新增文件,只添加修改的文件)</h1><pre><code>git add -u
</code></pre><h1 id="查看当前工作区文件提交的状态"><a href="#查看当前工作区文件提交的状态" class="headerlink" title="查看当前工作区文件提交的状态"></a>查看当前工作区文件提交的状态</h1><pre><code>git status
git status -s 查看简便信息
</code></pre><h1 id="提交文件到本地"><a href="#提交文件到本地" class="headerlink" title="提交文件到本地"></a>提交文件到本地</h1><pre><code>git commit filename -m &apos;注释&apos;
</code></pre><h1 id="删除本地git提交"><a href="#删除本地git提交" class="headerlink" title="删除本地git提交"></a>删除本地git提交</h1><pre><code>git rm --cached .
</code></pre><h1 id="将文件推送到远程服务器"><a href="#将文件推送到远程服务器" class="headerlink" title="将文件推送到远程服务器"></a>将文件推送到远程服务器</h1><pre><code>git push
</code></pre><h1 id="将文件从远程拉取回来"><a href="#将文件从远程拉取回来" class="headerlink" title="将文件从远程拉取回来"></a>将文件从远程拉取回来</h1><pre><code>git pull
</code></pre><h1 id="添加忽略文件"><a href="#添加忽略文件" class="headerlink" title="添加忽略文件"></a>添加忽略文件</h1><pre><code>添加.gitignore到git项目目录
编辑.gitignore,添加.idea/(此处idea为需要提交时候忽略的文件)
</code></pre><h1 id="下载远程项目"><a href="#下载远程项目" class="headerlink" title="下载远程项目"></a>下载远程项目</h1><pre><code>git clone git_path
</code></pre><h1 id="创建裸版本库"><a href="#创建裸版本库" class="headerlink" title="创建裸版本库"></a>创建裸版本库</h1><pre><code>git clone --bare project_name path
</code></pre><h1 id="查看文件提交记录"><a href="#查看文件提交记录" class="headerlink" title="查看文件提交记录"></a>查看文件提交记录</h1><pre><code>git log filename
</code></pre><h1 id="查看修改文件差异-只能比较工作区和暂存区信息"><a href="#查看修改文件差异-只能比较工作区和暂存区信息" class="headerlink" title="查看修改文件差异(只能比较工作区和暂存区信息)"></a>查看修改文件差异(只能比较工作区和暂存区信息)</h1><pre><code>git diff file_name
git diff HEAD
</code></pre><h1 id="查看提交详细记录"><a href="#查看提交详细记录" class="headerlink" title="查看提交详细记录"></a>查看提交详细记录</h1><pre><code>git show file_name
</code></pre><h1 id="使用git移动修改文件-修改完之后-文件的日志记录都没了"><a href="#使用git移动修改文件-修改完之后-文件的日志记录都没了" class="headerlink" title="使用git移动修改文件(修改完之后,文件的日志记录都没了)"></a>使用git移动修改文件(修改完之后,文件的日志记录都没了)</h1><pre><code>git mv old_file_name new_file_name
</code></pre><h1 id="从git中删除"><a href="#从git中删除" class="headerlink" title="从git中删除"></a>从git中删除</h1><pre><code>git rm file_name
</code></pre><h1 id="删除非git管理文件-也就是没有add到git管理中的"><a href="#删除非git管理文件-也就是没有add到git管理中的" class="headerlink" title="删除非git管理文件(也就是没有add到git管理中的)"></a>删除非git管理文件(也就是没有add到git管理中的)</h1><pre><code>git clean
</code></pre><h1 id="查看即将被删除的非git管理文件"><a href="#查看即将被删除的非git管理文件" class="headerlink" title="查看即将被删除的非git管理文件"></a>查看即将被删除的非git管理文件</h1><pre><code>git clean -n
</code></pre><h1 id="删除非git管理文件-包含-gitignore中指定的文件"><a href="#删除非git管理文件-包含-gitignore中指定的文件" class="headerlink" title="删除非git管理文件,包含.gitignore中指定的文件"></a>删除非git管理文件,包含.gitignore中指定的文件</h1><pre><code>git clean -x
</code></pre><h1 id="强制删除所有的git非管理文件-git-clean需要设置clean-requireForce"><a href="#强制删除所有的git非管理文件-git-clean需要设置clean-requireForce" class="headerlink" title="强制删除所有的git非管理文件(git clean需要设置clean.requireForce)"></a>强制删除所有的git非管理文件(git clean需要设置clean.requireForce)</h1><pre><code>git clean -f
</code></pre><h1 id="还原正在手头修改-但是没有add到git的文件-相当于svn-revert-只不过git是本地的源"><a href="#还原正在手头修改-但是没有add到git的文件-相当于svn-revert-只不过git是本地的源" class="headerlink" title="还原正在手头修改,但是没有add到git的文件(相当于svn revert,只不过git是本地的源)"></a>还原正在手头修改,但是没有add到git的文件(相当于svn revert,只不过git是本地的源)</h1><pre><code>git checkout file_name
</code></pre><h1 id="删除已提交过的文件-把状态从add修改回来-可以使用checkout操作"><a href="#删除已提交过的文件-把状态从add修改回来-可以使用checkout操作" class="headerlink" title="删除已提交过的文件(把状态从add修改回来,可以使用checkout操作)"></a>删除已提交过的文件(把状态从add修改回来,可以使用checkout操作)</h1><pre><code>git reset HEAD file_name
</code></pre><h1 id="创建一个分支"><a href="#创建一个分支" class="headerlink" title="创建一个分支"></a>创建一个分支</h1><pre><code>git branch dirname
</code></pre><h1 id="查看存在的分支"><a href="#查看存在的分支" class="headerlink" title="查看存在的分支"></a>查看存在的分支</h1><pre><code>git branch
git branch -a 查看所有的分支
</code></pre><h1 id="切换到分支"><a href="#切换到分支" class="headerlink" title="切换到分支"></a>切换到分支</h1><pre><code>git checkout branch_name
</code></pre><h1 id="在某个版本上创建分支并求换"><a href="#在某个版本上创建分支并求换" class="headerlink" title="在某个版本上创建分支并求换"></a>在某个版本上创建分支并求换</h1><pre><code>git checkout commit_name -b branch_name
</code></pre><h1 id="切换到主干"><a href="#切换到主干" class="headerlink" title="切换到主干"></a>切换到主干</h1><pre><code>git checkout master
</code></pre><h1 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h1><pre><code>git merge branch_name
</code></pre><h1 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h1><pre><code>git branch -d branch_name
</code></pre><h1 id="强制删除分支"><a href="#强制删除分支" class="headerlink" title="强制删除分支"></a>强制删除分支</h1><pre><code>git branch -D branch_name
</code></pre><h1 id="查看所有的远程的分支"><a href="#查看所有的远程的分支" class="headerlink" title="查看所有的远程的分支"></a>查看所有的远程的分支</h1><pre><code>git branch -r
</code></pre><h1 id="重置提交-重置最近三次的提交"><a href="#重置提交-重置最近三次的提交" class="headerlink" title="重置提交(重置最近三次的提交)"></a>重置提交(重置最近三次的提交)</h1><pre><code>git reset --hard HEAD~3
</code></pre><h1 id="在分支上执行rebase"><a href="#在分支上执行rebase" class="headerlink" title="在分支上执行rebase"></a>在分支上执行rebase</h1><pre><code>git checkout branch_name
git rebase master
</code></pre><h1 id="rebase之后修改冲突-再提交"><a href="#rebase之后修改冲突-再提交" class="headerlink" title="rebase之后修改冲突,再提交"></a>rebase之后修改冲突,再提交</h1><pre><code>git add conflict_file
git rebase --continue
</code></pre><h1 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h1><pre><code>git tag tag_name
</code></pre><h1 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h1><pre><code>git tag
</code></pre><h1 id="显示包含标签资料的历史记录"><a href="#显示包含标签资料的历史记录" class="headerlink" title="显示包含标签资料的历史记录"></a>显示包含标签资料的历史记录</h1><pre><code>git log --decorate
</code></pre><h1 id="查看git提交的注释"><a href="#查看git提交的注释" class="headerlink" title="查看git提交的注释"></a>查看git提交的注释</h1><pre><code>git log
</code></pre><h1 id="编辑tag注释"><a href="#编辑tag注释" class="headerlink" title="编辑tag注释"></a>编辑tag注释</h1><pre><code>git tag -a tag_name
然后再文件中输入注释
</code></pre><h1 id="编辑tag注释-1"><a href="#编辑tag注释-1" class="headerlink" title="编辑tag注释"></a>编辑tag注释</h1><pre><code>git tag -am &quot;注释&quot; tag_name
</code></pre><h1 id="查看标签的提交记录"><a href="#查看标签的提交记录" class="headerlink" title="查看标签的提交记录"></a>查看标签的提交记录</h1><pre><code>git show tag
</code></pre><h1 id="查看tag注释"><a href="#查看tag注释" class="headerlink" title="查看tag注释"></a>查看tag注释</h1><pre><code>git tag -n
</code></pre><h1 id="删除tag"><a href="#删除tag" class="headerlink" title="删除tag"></a>删除tag</h1><pre><code>git tag -d tag_name
</code></pre><h1 id="合并提交注释"><a href="#合并提交注释" class="headerlink" title="合并提交注释"></a>合并提交注释</h1><pre><code>git commit --amend
进入编辑器,然后进行注释修改(使用git log进行提交注释查看)
</code></pre><h1 id="取消上一次提交"><a href="#取消上一次提交" class="headerlink" title="取消上一次提交"></a>取消上一次提交</h1><pre><code>git revert HEAD
</code></pre><h1 id="删除最近提交"><a href="#删除最近提交" class="headerlink" title="删除最近提交"></a>删除最近提交</h1><pre><code>git reset --hart HEAD~~
</code></pre><h1 id="查看远程git地址"><a href="#查看远程git地址" class="headerlink" title="查看远程git地址"></a>查看远程git地址</h1><pre><code>git remote -v
</code></pre><h1 id="查看git配置项"><a href="#查看git配置项" class="headerlink" title="查看git配置项"></a>查看git配置项</h1><pre><code>git config --list
</code></pre><h1 id="编辑git配置"><a href="#编辑git配置" class="headerlink" title="编辑git配置"></a>编辑git配置</h1><pre><code>git config -e
</code></pre><h1 id="保存本地工作进度"><a href="#保存本地工作进度" class="headerlink" title="保存本地工作进度"></a>保存本地工作进度</h1><pre><code>git stash
</code></pre><h1 id="查看保存的快照"><a href="#查看保存的快照" class="headerlink" title="查看保存的快照"></a>查看保存的快照</h1><pre><code>git stash list
</code></pre><h1 id="恢复stash中的内容到工作区"><a href="#恢复stash中的内容到工作区" class="headerlink" title="恢复stash中的内容到工作区"></a>恢复stash中的内容到工作区</h1><pre><code>git stash pop
</code></pre><h1 id="恢复缓冲区内容"><a href="#恢复缓冲区内容" class="headerlink" title="恢复缓冲区内容"></a>恢复缓冲区内容</h1><pre><code>git stash apply stash_name
</code></pre><h1 id="删除缓冲区中的内容"><a href="#删除缓冲区中的内容" class="headerlink" title="删除缓冲区中的内容"></a>删除缓冲区中的内容</h1><pre><code>git clear
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="初始化一个git项目"><a href="#初始化一个git项目" class="headerlink" title="初始化一个git项目"></a>初始化一个git项目</h1><pre><code>git init
</code></pre><h1 id="]]>
    </summary>
    
      <category term="Other" scheme="http://www.cxyteam.com/tags/Other/"/>
    
      <category term="Other" scheme="http://www.cxyteam.com/categories/Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言高级函数使用]]></title>
    <link href="http://www.cxyteam.com/2016/08/15/C%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.cxyteam.com/2016/08/15/C语言高级函数使用/</id>
    <published>2016-08-15T00:17:17.000Z</published>
    <updated>2016-09-11T08:49:52.000Z</updated>
    <content type="html"><![CDATA[<h1 id="函数的指针"><a href="#函数的指针" class="headerlink" title="函数的指针"></a>函数的指针</h1><pre><code>当你创建一个函数test的时候,同时也会创建test的指针变量,变量中保存了函数的地址
</code></pre><h1 id="创建函数指针"><a href="#创建函数指针" class="headerlink" title="创建函数指针"></a>创建函数指针</h1><pre><code>int(*warp_fn)(int);     #创建warp_fn的变量,用来保存test()函数的地址
warp_fn = test;
warp_fn(4);             #等同于调用test函数

char** (*names_fn)(char*, int);                     #创建一个names_fn的变量用来保存test函数
names_fn = test;
char** results = name_fn(1972);
</code></pre><h1 id="函数指针应用"><a href="#函数指针应用" class="headerlink" title="函数指针应用"></a>函数指针应用</h1><pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int NUM_ADS = 7;
char *ADS[] = {
    &quot;William:SBM GSON likes sport,TV,dining&quot;,
    &quot;Matt:SWM NS likes art,movies,theather&quot;,
    &quot;Luis:SLM ND likes books,theater,art&quot;,
    &quot;MIKE:DWM DS likes truncks,sports and bieber&quot;,
    &quot;Peter:SAM likes chess,working out and art&quot;,
    &quot;Josh:SJM likes sports,movies and theater&quot;,
    &quot;Jed:DBM likes theater,books and dining&quot;
};
/**
 * 都要定义哦
 */
void find();
int sports_no_bieber(char *s);
int sports_or_workout(char *s);
int ns_theater(char *s);

int main()
{
    find(sports_no_bieber);
    find(sports_or_workout);
    find(ns_theater);
    return 0;
}

/**
 * 注意find中传入的参数是函数的指针
 * char** 表示返回类型
 * *func 表示指针变量
 * char* 表示参数类型
 */
void find(char** (*func)(char*))
{
    int i;
    puts(&quot;Search results:&quot;);
    puts(&quot;---------------------&quot;);

    for(i=0;i&lt;NUM_ADS;i++) {
        if (func(ADS[i])) {
            printf(&quot;%s\n&quot;, ADS[i]);
        }
    }

    puts(&quot;----------------&quot;);
}

int sports_no_bieber(char *s)
{
    return strstr(s, &quot;sports&quot;) &amp;&amp; !strstr(s, &quot;bieber&quot;);
}

int sports_or_workout(char *s)
{
    return strstr(&quot;s&quot;, &quot;sports&quot;) || strstr(s, &quot;working out&quot;);
}

int ns_theater(char *s)
{
    return strstr(s, &quot;NS&quot;) &amp;&amp; strstr(s, &quot;theater&quot;);
}
</code></pre><h1 id="qsort使用"><a href="#qsort使用" class="headerlink" title="qsort使用"></a>qsort使用</h1><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int compare_scores(const void * scores_a, const void * scores_b);

typedef struct {
    int width;
    int height;
} rectangle;

int compare_areas(const void* a, const void* b);

int compare_name(const void* a, const void* b);

int main()
{
    int scores[] = {2,3,123,345,456,7,11,3,5,6};
    qsort(scores, 10, sizeof(int), compare_scores);
    int i;

    for(i=0;i&lt;10;i++) {
        printf(&quot;%i\n&quot;, scores[i]);
    }

    int areas[] = {2,3,345,123,1};
    qsort(areas, 5, sizeof(int), compare_areas);
    int x;

    for(x=0;x&lt;5;x++) {
        printf(&quot;%i\n&quot;, areas[x]);
    }

    char *names[] = {&quot;c&quot;, &quot;a&quot;,&quot;b&quot;};
    qsort(names, 3, sizeof(char*), compare_name);
    int z;

    for(z=0;z&lt;3;z++) {
        printf(&quot;%s\n&quot;, names[z]);
    }

    return 0;
}

/**
    void指针可以保存任何类型数据的地址,但使用前必须把它转换成具体类型
*/
int compare_scores(const void * scores_a, const void * scores_b)
{
    /**
        int * 把void指针转换成整形指针
        *(int *)获取获取scores_a中的整形值
    */
    int a = *(int *)scores_a;
    int b = *(int *)scores_b;

    return b-a;
}

int compare_areas(const void *a, const void *b)
{
    /**
        把指针转换成相应的类型
    */
    rectangle *ia = (rectangle*)a;
    rectangle *ib = (rectangle*)b;
    /**
        矩形面积计算
    */
    int area_a = (ia-&gt;width * ia-&gt;height);
    int area_b = (ia-&gt;width * ia-&gt;height);

    return area_a-area_b;
}

int compare_name(const void* a, const void* b)
{
    /**
        char** 代表的是指向字符指针的指针
    */
    char** sa = (char**)a;
    char** sb = (char**)b;

    /**
        strcmp接收的是char*的值,而char**是指针地址
    */
    return strcmp(*sa, *sb);
}
</code></pre><h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><pre><code>void(*function_name[])(response)={function_a,function_b};
void            声明返回类型
*               声明函数指针
function_name   变量名
[]              表明是函数数组
response        参数类型
例子:
    #include &lt;stdio.h&gt;

    enum response_type {DUMP, SECOND_CHANCE, MARRIAGE};

    typedef struct {
        char* name;
        enum response_type type;
    }response;

    void dump(response r);
    void second_chance(response r);
    void marriage(response r);

    int main()
    {
        response ra[] = {
            {&quot;test&quot;, DUMP},
            {&quot;test2&quot;, SECOND_CHANCE},
        };

        /**
            定义函数数组
        */
        void(*func_arr[])(response) = {dump, second_chance, marriage};

        int i;
        for (i=0;i&lt;2;i++) {
            /**
                使用函数数组定义的方法
            */
            (func_arr[ra[i].type])(ra[i]);

            /**
                受用switch的方法
            */
            switch(ra[i].type) {
                case DUMP:
                    dump(ra[i]);
                break;
                case SECOND_CHANCE:
                    second_chance(ra[i]);
                break;
                default:
                    marriage(ra[i]);
                break;
            }
        }

        return 0;
    }

    void dump(response r)
    {
        printf(&quot;hello,i&apos;m dump, you are %s\n&quot;, r.name);
    }

    void second_chance(response r)
    {
        printf(&quot;hello,i&apos;m second_chance, you are %s\n&quot;, r.name);
    }

    void marriage(response r)
    {
        printf(&quot;hello,i&apos;m marriage, you are %s\n&quot;, r.name);
    }
</code></pre><h1 id="可变参数个数"><a href="#可变参数个数" class="headerlink" title="可变参数个数"></a>可变参数个数</h1><pre><code>在C标准库中有一组宏可以建立自己的可变参数函数,&lt;stdarg.h&gt;
例子
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

void print_ints(int args, ...)
{
    /*
        保存传给函数的其他参数
    */
    va_list ap;

    /*
        表示可变参数从哪开始
    */
    va_start(ap, args);
    int i;
    /*
        循环遍历所有其他参数,args保存了参数的数目
    */
    for(i=0;i&lt;args;i++) {
        printf(&quot;argument:%i\n&quot;, va_arg(ap, int));
    }

    va_end(ap);
}

int main()
{
    print_ints(3, 79, 101, 32);
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="函数的指针"><a href="#函数的指针" class="headerlink" title="函数的指针"></a>函数的指针</h1><pre><code>当你创建一个函数test的时候,同时也会创建test的指针变量,变量中保存了函数的地址
</code]]>
    </summary>
    
      <category term="C" scheme="http://www.cxyteam.com/tags/C/"/>
    
      <category term="C" scheme="http://www.cxyteam.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言内存泄露检测Valgrind]]></title>
    <link href="http://www.cxyteam.com/2016/08/11/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8BValgrind/"/>
    <id>http://www.cxyteam.com/2016/08/11/C语言内存泄露检测Valgrind/</id>
    <published>2016-08-11T01:05:15.000Z</published>
    <updated>2016-08-12T00:41:15.000Z</updated>
    <content type="html"><![CDATA[<h1 id="valgrind使用场景"><a href="#valgrind使用场景" class="headerlink" title="valgrind使用场景"></a>valgrind使用场景</h1><pre><code>检查代码中在堆上分配存储器,但是没释放的位置,也就是找出存储器泄露位置
</code></pre><h1 id="valgrind工作原理"><a href="#valgrind工作原理" class="headerlink" title="valgrind工作原理"></a>valgrind工作原理</h1><pre><code>通过伪造malloc可以监控分配在堆上的数据,当程序想分配堆存储器时,valgrind将会拦截你对malloc和free的调用,然后运行自己的malloc和free函数,它会记录哪段代码分配了哪段存储器,结束的时候,valgrind会汇报堆上有哪些数据,并告诉你这些数据由哪段代码创建
</code></pre><h1 id="安装valgrind"><a href="#安装valgrind" class="headerlink" title="安装valgrind"></a>安装valgrind</h1><pre><code>curl -O http://valgrind.org/downloads/valgrind-3.11.0.tar.bz2
tar -xjvf valgrind-3.11.0.tar.bz2
cd valgrind-3.11.0
./configure &amp;&amp; make &amp;&amp; make install
valgrind --version
</code></pre><h1 id="使用valgrind"><a href="#使用valgrind" class="headerlink" title="使用valgrind"></a>使用valgrind</h1><pre><code>gcc -g test.c -o test (其中-g是告诉编译器要记录需编译代码的行号)
valgrind --leak-check=full ./test
</code></pre><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><pre><code>createByMalloc.c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

//结构定义函数体的外面多个函数才能共享
typedef struct island {
    char *name;
    char *open;
    char *close;
    struct island *next;
} island;


void display(island *start);
island* create(char *name);

int main()
{
    char name[80];
    fgets(name, 80, stdin);
    island *i = create(name);

    fgets(name, 80, stdin);
    island *i1 = create(name);
    i-&gt;next = i1;
    display(i);
    release(i);
}

island* create (char *name)
{
    island *i = malloc(sizeof(island));
    //注意在此处一定用用strdup在堆上存储,如果都是在栈上存储,函数结束后会释放内存空间,每次都只能保存最后传入的name指针指向的值
    i-&gt;name = strdup(name);
    i-&gt;open = &quot;09:00&quot;;
    i-&gt;close = &quot;17:00&quot;;
    i-&gt;next = NULL;

    return i;
}


void display(island *start) {
    island *i = start;
    for (;i!=NULL;i=i-&gt;next) {
        printf(&quot;name:%s,open:%s-%s\n&quot;,i-&gt;name, i-&gt;open, i-&gt;close);
    }
}

gcc -g createByMalloc.c -o createByMalloc
valgrind --leak-check=full ./createByMalloc
</code></pre><p><img src="/img/c_code/list/valgrind.png" alt="Alt text" title="错误信息图片"></p>
<pre><code>1.total heap usage: 520 allocs, 100 frees, 49,567 bytes allocated
    表示520次存储器,100次被释放

2.at 0x100007EA1: malloc (vg_replace_malloc.c:303)
  by 0x100000D7A: create (createByMalloc.c:33)
  by 0x100000CED: main (createByMalloc.c:23)
    明确指出了可能出问题的行,查看代码可以发现是create的33行分配的堆上的存储器没有被释放,所以加上释放代码就好了

正确例子:
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

//结构定义函数体的外面多个函数才能共享
typedef struct island {
    char *name;
    char *open;
    char *close;
    struct island *next;
} island;


void display(island *start);
void release1(island *start);
void release(island *start);
island* create(char *name);

int main()
{
    char name[80];
    fgets(name, 80, stdin);
    island *i = create(name);

    fgets(name, 80, stdin);
    island *i1 = create(name);
    i-&gt;next = i1;
    display(i);
}

island* create (char *name)
{
    island *i = malloc(sizeof(island));
    //注意在此处一定用用strdup在堆上存储,如果都是在栈上存储,函数结束后会释放内存空间,每次都只能保存最后传入的name指针指向的值
    i-&gt;name = strdup(name);
    i-&gt;open = &quot;09:00&quot;;
    i-&gt;close = &quot;17:00&quot;;
    i-&gt;next = NULL;

    return i;
}


void display(island *start) {
    island *i = start;
    for (;i!=NULL;i=i-&gt;next) {
        printf(&quot;name:%s,open:%s-%s\n&quot;,i-&gt;name, i-&gt;open, i-&gt;close);
    }
}

void release1(island *start) {
    island *i = NULL;
    for(i=start;i!=NULL;i=i-&gt;next) {
        free(i-&gt;name);
        free(i);
    }
}

void release(island *start) {
    island *i = start;
    island *next = NULL;
    for(;i!=NULL;i=next) {
        next = i-&gt;next;
        free(i-&gt;name);
        free(i);
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="valgrind使用场景"><a href="#valgrind使用场景" class="headerlink" title="valgrind使用场景"></a>valgrind使用场景</h1><pre><code>检查代码中在堆上分配存储器,但是没释放的位置]]>
    </summary>
    
      <category term="C" scheme="http://www.cxyteam.com/tags/C/"/>
    
      <category term="C" scheme="http://www.cxyteam.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言动态存储]]></title>
    <link href="http://www.cxyteam.com/2016/08/10/C%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8/"/>
    <id>http://www.cxyteam.com/2016/08/10/C语言动态存储/</id>
    <published>2016-08-10T00:12:39.000Z</published>
    <updated>2016-08-11T00:52:09.000Z</updated>
    <content type="html"><![CDATA[<h1 id="动态数据存储的位置"><a href="#动态数据存储的位置" class="headerlink" title="动态数据存储的位置"></a>动态数据存储的位置</h1><pre><code>堆,它是程序中用来保存长期使用数据的地方
</code></pre><h1 id="获取空间"><a href="#获取空间" class="headerlink" title="获取空间"></a>获取空间</h1><pre><code>使用malloc()函数进行申请
</code></pre><h1 id="如何释放"><a href="#如何释放" class="headerlink" title="如何释放"></a>如何释放</h1><pre><code>使用free()函数进行释放
</code></pre><h1 id="使用malloc"><a href="#使用malloc" class="headerlink" title="使用malloc"></a>使用malloc</h1><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

//结构定义函数体的外面多个函数才能共享
typedef struct island {
    char *name;
    char *open;
    char *close;
    struct island *next;
} island;
void display(island *start);
void release(island *start);
island* create();

int main()
{
    char name[80];
    fgets(name, 80, stdin);
    island *i = create(name);

    fgets(name, 80, stdin);
    island *i1 = create(name);
    i-&gt;next = i1;
    display(i);
    release(i);
}

island* create (char *name)
{
    island *i = malloc(sizeof(island));
    //注意在此处一定用用strdup在堆上存储,如果都是在栈上存储,函数结束后会释放内存空间,每次都只能保存最后传入的name指针指向的值
    i-&gt;name = strdup(name);
    i-&gt;open = &quot;09:00&quot;;
    i-&gt;close = &quot;17:00&quot;;
    i-&gt;next = NULL;

    return i;
}


void display(island *start) {
    island *i = start;
    for (;i!=NULL;i=i-&gt;next) {
        printf(&quot;name:%s,open:%s-%s\n&quot;,i-&gt;name, i-&gt;open, i-&gt;close);
    }
}

void release(island *start) {
    island *i = NULL;
    island *next = NULL;

    for(;i!=NULL;i=next) {
        next = i-&gt;next;
        free(i-&gt;name);
        free(i);
    }
}
</code></pre><h1 id="为什么island在堆上申请了内存-name还需要在堆上申请内存"><a href="#为什么island在堆上申请了内存-name还需要在堆上申请内存" class="headerlink" title="为什么island在堆上申请了内存,name还需要在堆上申请内存?"></a>为什么island在堆上申请了内存,name还需要在堆上申请内存?</h1><pre><code>因为结构只是把不同类型的数据写在一起,封装成一个大的数据类型,它不是创建了一个类型把所有数据都存储在它里面
</code></pre><h1 id="使用release的时候需要释放那些堆上的内存"><a href="#使用release的时候需要释放那些堆上的内存" class="headerlink" title="使用release的时候需要释放那些堆上的内存?"></a>使用release的时候需要释放那些堆上的内存?</h1><pre><code>因为name,和island在堆上申请了内存,所以只要释放他们的内存就好了,但是需要注意的是先释放name的内存,不然先释放了island就找不到name了
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="动态数据存储的位置"><a href="#动态数据存储的位置" class="headerlink" title="动态数据存储的位置"></a>动态数据存储的位置</h1><pre><code>堆,它是程序中用来保存长期使用数据的地方
</code></pre>]]>
    </summary>
    
      <category term="C" scheme="http://www.cxyteam.com/tags/C/"/>
    
      <category term="C" scheme="http://www.cxyteam.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言链表]]></title>
    <link href="http://www.cxyteam.com/2016/08/09/C%E8%AF%AD%E8%A8%80%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.cxyteam.com/2016/08/09/C语言链表/</id>
    <published>2016-08-08T23:57:33.000Z</published>
    <updated>2016-08-10T00:13:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><pre><code>是一种抽象的数据结构
</code></pre><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><pre><code>为了保存可变数量的数据,需要一样比数组更灵活的东西
</code></pre><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><pre><code>保存了一条数据和链向另一条数据的链接
</code></pre><h1 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h1><pre><code>#include &lt;stdio.h&gt;
//注意要先定义函数在main函数的外部
void display();
//结构定义函数体的外面多个函数才能共享
typedef struct island {
    char *name;
    char *open;
    char *close;
    struct island *next;
} island;

int main()
{
    island amity = {&quot;Amity&quot;, &quot;9:00&quot;, &quot;17:00&quot;, NULL};
    island craggy = {&quot;craggy&quot;, &quot;9:00&quot;, &quot;17:00&quot;, NULL};
    island shutter = {&quot;shutter&quot;, &quot;9:00&quot;, &quot;17:00&quot;, NULL};

    amity.next = &amp;craggy;
    craggy.next = &amp;shutter;

    display(&amp;amity);
    return 0;
}

void display(island *start) {
    island *i = start;
    for (;i!=NULL;i=i-&gt;next) {
        printf(&quot;name:%s,open:%s-%s\n&quot;,i-&gt;name, i-&gt;open, i-&gt;close);
    }
}
</code></pre><h1 id="递归结构"><a href="#递归结构" class="headerlink" title="递归结构"></a>递归结构</h1><pre><code>如果一个结构中包含一个链向同种结构的链接,那么这个结构就被称为递归结构
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><pre><code>是一种抽象的数据结构
</code></pre><h1 id="使用场景"><a href="#使用场景" class="h]]>
    </summary>
    
      <category term="C" scheme="http://www.cxyteam.com/tags/C/"/>
    
      <category term="C" scheme="http://www.cxyteam.com/categories/C/"/>
    
  </entry>
  
</feed>