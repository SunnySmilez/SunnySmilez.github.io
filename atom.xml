<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[狂奔的菜鸟]]></title>
  <subtitle><![CDATA[当你的实力支撑不起你的野心的时候，静下心来好好学习吧！]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.cxyteam.com/"/>
  <updated>2018-07-02T13:04:10.000Z</updated>
  <id>http://www.cxyteam.com/</id>
  
  <author>
    <name><![CDATA[狂奔的菜鸟]]></name>
    <email><![CDATA[phpchengxuyuan@sina.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[docker部署mysql的疑问]]></title>
    <link href="http://www.cxyteam.com/2018/07/02/docker%E9%83%A8%E7%BD%B2mysql%E7%9A%84%E7%96%91%E9%97%AE/"/>
    <id>http://www.cxyteam.com/2018/07/02/docker部署mysql的疑问/</id>
    <published>2018-07-02T12:52:34.000Z</published>
    <updated>2018-07-02T13:04:10.000Z</updated>
    <content type="html"><![CDATA[<h1 id="mysql的初始密码是什么"><a href="#mysql的初始密码是什么" class="headerlink" title="mysql的初始密码是什么"></a>mysql的初始密码是什么</h1><pre><code>设置环境变量：MYSQL_ROOT_PASSWORD
eg:
   docker run --name=mysql  -e MYSQL_ROOT_PASSWORD=123123 -e MYSQL_DATABASE=test1 -p 3307:3306 -d mysql_image_name
   注释：
     --name 指定容器名称
     -e 设置环境变量
        MYSQL_ROOT_PASSWORD   设置root的初始密码
        MYSQL_USER，MYSQL_PASSWORD  设置新用户及密码
        MYSQL_DATABASE 指定镜像启动容器时创建的数据库
     -p 设置端口映射，将宿主机端口3307映射到容器端口3306
     -d 后台运行
     mysql_image_name  镜像的名称
</code></pre><h1 id="mysql的数据会不会因为docker重启就消失了"><a href="#mysql的数据会不会因为docker重启就消失了" class="headerlink" title="mysql的数据会不会因为docker重启就消失了"></a>mysql的数据会不会因为docker重启就消失了</h1><pre><code>进行数据卷的挂载
eg:
    docker run --namee=mysql -e MYSQL_ROOT_PASSWORD=123123 -p 3307:3306 -v /data/mysql:/var/lib/mysql -d mysql_image_name
    注释：
        -v 设置挂载卷 将宿主机的/data/mysql挂载到容器的/var/lib/mysql
        这样重启的时候数据不会丢失，因为在宿主机上
</code></pre><h1 id="如何初始mysql数据"><a href="#如何初始mysql数据" class="headerlink" title="如何初始mysql数据"></a>如何初始mysql数据</h1><pre><code>将sql文件复制到mysql容器
    docker cp a.sql mysql_docker:/tmp

登录mysql容器
    docker exec -it mysql_docker /bin/bash

进入mysql    
    mysql -uroot -p

选择库，导入sql文件
    use database_name;
    source /tmp/a.sql
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="mysql的初始密码是什么"><a href="#mysql的初始密码是什么" class="headerlink" title="mysql的初始密码是什么"></a>mysql的初始密码是什么</h1><pre><code>设置环境变量：MYSQL_ROOT_]]>
    </summary>
    
      <category term="Docker" scheme="http://www.cxyteam.com/tags/Docker/"/>
    
      <category term="Docker" scheme="http://www.cxyteam.com/categories/Docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PhantomJS截图工具]]></title>
    <link href="http://www.cxyteam.com/2018/06/28/PhantomJS%E6%88%AA%E5%9B%BE%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.cxyteam.com/2018/06/28/PhantomJS截图工具/</id>
    <published>2018-06-28T12:41:52.000Z</published>
    <updated>2018-07-02T13:41:31.000Z</updated>
    <content type="html"><![CDATA[<h1 id="安装PhantomJS"><a href="#安装PhantomJS" class="headerlink" title="安装PhantomJS"></a>安装PhantomJS</h1><pre><code>直接在官网下载编译好的包就行
http://phantomjs.org/download.html
</code></pre><h1 id="截图使用介绍"><a href="#截图使用介绍" class="headerlink" title="截图使用介绍"></a>截图使用介绍</h1><pre><code>1、写一个需要被截图的页面
    用www.baidu.com做例子

2、写截图的js（test.js）
    var page = require(&apos;webpage&apos;).create(),
        system = require(&apos;system&apos;),
        address;

    page.viewportSize = { width: 720, height: 1247 };

    // 如果命令行没有给出网址
    if (system.args.length === 1) {
        console.log(&apos;Usage: page.js &lt;some URL&gt;&apos;);
        phantom.exit();
    }

    address = system.args[1];
    id = system.args[2];

    page.open(address, function (status) {
        page.evaluate(function() {
            document.body.bgColor = &apos;white&apos;;
        });

        page.render(&apos;/tmp/&apos;+id+&apos;.jpeg&apos;, {format: &apos;jpeg&apos;, quality: &apos;70&apos;});

        phantom.exit();
    });

3、运行phantomjs的服务端代码(a.php)
    $str = &apos;/usr/local/phantomjs/bin/phantomjs test.js http://www.baidu.com &apos;.$id;
    shell_exec($str);
    注释：
        /usr/local/phantomjs/bin/phantomjs是我的命令安装路径
        test.js 是js地址
        http://www.baidu.com 是需要截图的网站
        $id     是传入的参数
</code></pre><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><pre><code>官网
    http://phantomjs.org/

中文
    http://javascript.ruanyifeng.com/tool/phantomjs.html
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="安装PhantomJS"><a href="#安装PhantomJS" class="headerlink" title="安装PhantomJS"></a>安装PhantomJS</h1><pre><code>直接在官网下载编译好的包就行
http://phan]]>
    </summary>
    
      <category term="Other" scheme="http://www.cxyteam.com/tags/Other/"/>
    
      <category term="Other" scheme="http://www.cxyteam.com/categories/Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[centos安装docker]]></title>
    <link href="http://www.cxyteam.com/2018/06/27/centos%E5%AE%89%E8%A3%85docker/"/>
    <id>http://www.cxyteam.com/2018/06/27/centos安装docker/</id>
    <published>2018-06-27T13:48:57.000Z</published>
    <updated>2018-06-27T13:53:39.000Z</updated>
    <content type="html"><![CDATA[<h1 id="更新epel第三方软件库"><a href="#更新epel第三方软件库" class="headerlink" title="更新epel第三方软件库"></a>更新epel第三方软件库</h1><pre><code>yum install epel-release
</code></pre><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><pre><code>yum install docker-io
</code></pre><h1 id="验证是否成功"><a href="#验证是否成功" class="headerlink" title="验证是否成功"></a>验证是否成功</h1><pre><code>docker version 或者docker -h    
</code></pre><h1 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h1><pre><code>sevice docker start
</code></pre><h1 id="更改镜像源"><a href="#更改镜像源" class="headerlink" title="更改镜像源"></a>更改镜像源</h1><pre><code>vim /etc/docker/daemon.json
添加如下内容：
    {
      &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]
    }    
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="更新epel第三方软件库"><a href="#更新epel第三方软件库" class="headerlink" title="更新epel第三方软件库"></a>更新epel第三方软件库</h1><pre><code>yum install epel-relea]]>
    </summary>
    
      <category term="Docker" scheme="http://www.cxyteam.com/tags/Docker/"/>
    
      <category term="Docker" scheme="http://www.cxyteam.com/categories/Docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[vm搭建docker-swarm]]></title>
    <link href="http://www.cxyteam.com/2018/06/27/vm%E6%90%AD%E5%BB%BAdocker-swarm/"/>
    <id>http://www.cxyteam.com/2018/06/27/vm搭建docker-swarm/</id>
    <published>2018-06-27T02:38:52.000Z</published>
    <updated>2018-06-27T14:00:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="安装vm"><a href="#安装vm" class="headerlink" title="安装vm"></a>安装vm</h1><h1 id="安装cento6-8"><a href="#安装cento6-8" class="headerlink" title="安装cento6.8"></a>安装cento6.8</h1><pre><code>https://blog.csdn.net/Podge/article/details/79182615
记得设置启动方式为终端
    临时方式：init 3
    永久方式：vim /etc/inittab
        将id:5:中的5改为3
</code></pre><h1 id="配置网络"><a href="#配置网络" class="headerlink" title="配置网络"></a>配置网络</h1><pre><code>1、关闭防火墙
    永久关闭SELinux
        vi /etc/selinux/config
        将 SELINUX=enforcing 
        改为 SELINUX=disabled

    永久关闭防火墙
        chkconfig iptables off

2、配置网络
    设置vm为桥接
        在vm-&gt;审核之后-&gt;网络-&gt;连接方式选择桥接网卡-&gt;界面名称（看你希望桥接你本机电脑的哪个网络，en0一般是wifi）

    vim /etc/sysconfig/network-scripts/ifcfg-eth0
        DEVICE=eth0
        HWADDR=08:00:27:D8:2C:F8
        TYPE=Ethernet
        UUID=fd397c03-6719-4cf3-8e88-e6df26256ba1
        ONBOOT=yes
        NM_CONTROLLED=yes
        BOOTPROTO=static
        IPADDR=10.17.8.108
        NETMASK=255.255.192.0
        GATEWAY=10.17.0.1
        USERCTL=no
        DNS1=10.16.0.222
        DNS2=114.114.114.114

    注意：
        IPADDR保持和主机在同一个网段
        netmask，GATEWAY保持和你的主机一致

    vim /etc/sysconfig/network
        NETWORKING=yes
        HOSTNAME=swarm-node1
        GATEWAY=10.17.0.1

    重启
        service network restart
</code></pre><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><h1 id="安装docker-swarm"><a href="#安装docker-swarm" class="headerlink" title="安装docker swarm"></a>安装docker swarm</h1><h1 id="添加主节点"><a href="#添加主节点" class="headerlink" title="添加主节点"></a>添加主节点</h1><pre><code>docker swarm init --advertise-addr 10.17.8.102
</code></pre><h1 id="加入主节点"><a href="#加入主节点" class="headerlink" title="加入主节点"></a>加入主节点</h1><pre><code>docker swarm join --token SWMTKN-1-1muumruf8zsdl07li7z4gssp5gnfw6v01e5uovsaa8ik2exabl-e3ga0wgk05uaboouo64t1xxmg 10.17.8.102:2377
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="安装vm"><a href="#安装vm" class="headerlink" title="安装vm"></a>安装vm</h1><h1 id="安装cento6-8"><a href="#安装cento6-8" class="headerlink" titl]]>
    </summary>
    
      <category term="Docker" scheme="http://www.cxyteam.com/tags/Docker/"/>
    
      <category term="Docker" scheme="http://www.cxyteam.com/categories/Docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git服务搭建]]></title>
    <link href="http://www.cxyteam.com/2018/06/26/git%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA/"/>
    <id>http://www.cxyteam.com/2018/06/26/git服务搭建/</id>
    <published>2018-06-26T13:02:45.000Z</published>
    <updated>2018-06-26T14:06:31.000Z</updated>
    <content type="html"><![CDATA[<h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><pre><code>yum install git
</code></pre><h1 id="初始化git库（在-data目录下）"><a href="#初始化git库（在-data目录下）" class="headerlink" title="初始化git库（在/data目录下）"></a>初始化git库（在/data目录下）</h1><pre><code>git init --bare test.git
</code></pre><h1 id="修改目录权限"><a href="#修改目录权限" class="headerlink" title="修改目录权限"></a>修改目录权限</h1><pre><code>chmod -R 755 /data
</code></pre><h1 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h1><pre><code>useradd test
</code></pre><h1 id="创建密码"><a href="#创建密码" class="headerlink" title="创建密码"></a>创建密码</h1><pre><code>passwd test
</code></pre><h1 id="克隆代码"><a href="#克隆代码" class="headerlink" title="克隆代码"></a>克隆代码</h1><pre><code>git clone test@ip:/data/test.git
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h1><pre><code>yum install git
</code></pre><h1 id="初始化git库（在-dat]]>
    </summary>
    
      <category term="Other" scheme="http://www.cxyteam.com/tags/Other/"/>
    
      <category term="Other" scheme="http://www.cxyteam.com/categories/Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker-compose配置laravel环境]]></title>
    <link href="http://www.cxyteam.com/2018/06/21/docker-compose%E9%85%8D%E7%BD%AElaravel%E7%8E%AF%E5%A2%83/"/>
    <id>http://www.cxyteam.com/2018/06/21/docker-compose配置laravel环境/</id>
    <published>2018-06-21T02:43:07.000Z</published>
    <updated>2018-06-25T16:34:32.000Z</updated>
    <content type="html"><![CDATA[<h1 id="docker-compose搭建lareval环境遇到的坑"><a href="#docker-compose搭建lareval环境遇到的坑" class="headerlink" title="docker-compose搭建lareval环境遇到的坑"></a>docker-compose搭建lareval环境遇到的坑</h1><h3 id="images不存在"><a href="#images不存在" class="headerlink" title="images不存在"></a>images不存在</h3><pre><code>1、修改docker的镜像源
2、docker search 确认是否存在
</code></pre><h1 id="ENTRYPOINT脚本路径"><a href="#ENTRYPOINT脚本路径" class="headerlink" title="ENTRYPOINT脚本路径"></a>ENTRYPOINT脚本路径</h1><pre><code>1、先复制到/usr/local/bin目录下
2、在填入绝对路径
eg：（dockerfile文件中）
    COPY ./docker-entrypoint.sh /usr/local/bin/
    ENTRYPOINT [&quot;/usr/local/bin/docker-entrypoint.sh&quot;]
</code></pre><h1 id="ENTRYPOINT脚本权限"><a href="#ENTRYPOINT脚本权限" class="headerlink" title="ENTRYPOINT脚本权限"></a>ENTRYPOINT脚本权限</h1><pre><code>1、脚本记得给权限（dockerfile文件中）
eg: RUN chmod 755 /usr/local/bin/docker-entrypoint.sh
</code></pre><h1 id="mysql默认密码及库"><a href="#mysql默认密码及库" class="headerlink" title="mysql默认密码及库"></a>mysql默认密码及库</h1><pre><code>设置两个环境：（docker-compose.yaml文件中）
1、mysql初始密码：MYSQL_ROOT_PASSWORD
2、mysql初始化创建的数据库：MYSQL_DATABASE
eg: 
    MYSQL_ROOT_PASSWORD: 123123
    MYSQL_DATABASE: laravel_tet
</code></pre><h1 id="初始化sql"><a href="#初始化sql" class="headerlink" title="初始化sql"></a>初始化sql</h1><pre><code>1、搭建开发环境的时候，肯定会有已有的数据结果和数据，需要进行初始化
2、在docker mysql的官方镜像中，镜像首次启动时，会自动执行这个目录（/docker-entrypoint-initdb.d）下的脚本
3、所以我们直接把需要执行的脚本挂载到执行的目录中去
eg：
    volumes:
        - ./build/sql:/docker-entrypoint-initdb.d
</code></pre><h1 id="修改image名称"><a href="#修改image名称" class="headerlink" title="修改image名称"></a>修改image名称</h1><pre><code>1、设置image的值；如果是根据dockerfile来build，那么就是image的值；如果image是dockerhub中的镜像名称，那么就是这个镜像名称
eg:（docker-compose.yaml文件中）
    第一种：(名称为test_laravel_nginx)
        build: ./build/docker/nginx
        image: test_laravel_nginx

    第二种：（名称为redis）
        image: redis:latest
</code></pre><h1 id="修改容器名称"><a href="#修改容器名称" class="headerlink" title="修改容器名称"></a>修改容器名称</h1><pre><code>1、设置container_name的值
eg：（docker-compose.yaml文件中）
    container_name: test_laravel_php
</code></pre><h1 id="nginx日志查看"><a href="#nginx日志查看" class="headerlink" title="nginx日志查看"></a>nginx日志查看</h1><h1 id="php日志查看"><a href="#php日志查看" class="headerlink" title="php日志查看"></a>php日志查看</h1><h1 id="strace使用"><a href="#strace使用" class="headerlink" title="strace使用"></a>strace使用</h1><pre><code>1、使用特权启动：(--privileged)
    在run的时候使用
        docker run -t -i --privileged container_name /bin/bash
    在docker-compose使用
        privileged: true

2、docker-compose中设置权限
    cap_add: 添加linux的部分功能
    cap_drop：删除linux的部分功能
    eg:
        在run的时候使用
            docker run -t -i --cap_add=ALL  --cap_drop=MKNOD container_name /bin/bash

        在docker-compose使用
            cap_add:
              - ALL

            cap_drop:
              - NET_ADMIN
              - SYS_ADMIN
</code></pre><h1 id="如何跑crontab"><a href="#如何跑crontab" class="headerlink" title="如何跑crontab"></a>如何跑crontab</h1><pre><code>1、安装crontab
2、在docker-entrypoint.sh中写入如下语句：
        service crond start
        crontab /data/htdocs/test_laravel/app/Console/crontab
</code></pre><h1 id="nginx的容器如何安装软件"><a href="#nginx的容器如何安装软件" class="headerlink" title="nginx的容器如何安装软件"></a>nginx的容器如何安装软件</h1><pre><code>使用apt-get安装
eg:    
    1、apt-get update
    2、apt-get install vim
    3、apt-get install procps    (安装ps命令工具)
</code></pre><h1 id="容器一启动就退出"><a href="#容器一启动就退出" class="headerlink" title="容器一启动就退出"></a>容器一启动就退出</h1><pre><code>1、查看日志（docker logs container_name）
2、/usr/sbin/sshd -D
3、如果可以启动，登录容器查看
4、查看容器信息（docker inspect container_name）
</code></pre><h1 id="如何对外提供访问"><a href="#如何对外提供访问" class="headerlink" title="如何对外提供访问"></a>如何对外提供访问</h1><pre><code>端口映射
    1、宿主机解析域名
    2、设置端口映射
    3、访问宿主机指定端口
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="docker-compose搭建lareval环境遇到的坑"><a href="#docker-compose搭建lareval环境遇到的坑" class="headerlink" title="docker-compose搭建lareval环境遇到的坑"></a]]>
    </summary>
    
      <category term="Docker" scheme="http://www.cxyteam.com/tags/Docker/"/>
    
      <category term="Docker" scheme="http://www.cxyteam.com/categories/Docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker-compose文件语法]]></title>
    <link href="http://www.cxyteam.com/2018/06/20/docker-compose%E6%96%87%E4%BB%B6%E8%AF%AD%E6%B3%95/"/>
    <id>http://www.cxyteam.com/2018/06/20/docker-compose文件语法/</id>
    <published>2018-06-20T02:51:16.000Z</published>
    <updated>2018-06-20T12:58:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h1><pre><code>以&quot;yml&quot;或者&quot;yaml&quot;为文件后缀
</code></pre><h1 id="version"><a href="#version" class="headerlink" title="version"></a>version</h1><pre><code>设置docker compose解析语法版本号
eg: version: &quot;v1&quot;
</code></pre><h1 id="services"><a href="#services" class="headerlink" title="services"></a>services</h1><pre><code>一个结构体，表示服务配置开始
</code></pre><h1 id="build"><a href="#build" class="headerlink" title="build"></a>build</h1><pre><code>指定dockerfile所在路径，compose将使用该dickerfile构建镜像
eg: build: /dockerfile/path
</code></pre><h1 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h1><pre><code>设置容器名称，注意如果指定了容器名称，必须保证名称唯一
eg：
    container_name: test_php
</code></pre><h1 id="image"><a href="#image" class="headerlink" title="image"></a>image</h1><pre><code>指定要从中启动容器的镜像(如果是通过build方式构建镜像，设置这个参数相当于给镜像重命名)
eg: image: mysql:5.7
</code></pre><h1 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h1><pre><code>暴露端口信息，格式为：(宿主机端口:容器端口)；端口号最好大于60，因为yaml解析xx:yy这种格式为60进制
eg: ports: 
        - 8001:80
</code></pre><h1 id="expose"><a href="#expose" class="headerlink" title="expose"></a>expose</h1><pre><code>暴露端口，不映射到主机，只被链接访问
eg: expose:
        22
</code></pre><h1 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h1><pre><code>设置环境变量
eg : environment:
        - ENV:dev
</code></pre><h1 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h1><pre><code>从文件中获取环境变量，可以单个文件路径或者文件列表；

注意：
    如果docker-compose -f FILE 指定了模板文件，则 env_file 中路径会基于模板文件路径
    如果文件中指定的变量与environment中的变量有冲突，则以后者为准
    env文件中支持&apos;#&apos;好注释，使用ENV=dev这样的格式
eg: env_file:
        - ./build/env/php-fpm.env
        - ./build/env/nginx.env
</code></pre><h1 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h1><pre><code>挂载卷盘；宿主机目录:容器目录
volumes:
    ./public:/data/public
</code></pre><h1 id="links"><a href="#links" class="headerlink" title="links"></a>links</h1><pre><code>链接到其他服务中的容器(使用服务名称)
eg: links: 
        - test_mysql
        - test_redis
</code></pre><h1 id="external-links"><a href="#external-links" class="headerlink" title="external_links"></a>external_links</h1><pre><code>链接到docker-compose.yaml外部的容器，可以说非compose管理的容器
eg: external_links: 
        - test_mysql
        - test_redis
</code></pre><h1 id="command"><a href="#command" class="headerlink" title="command"></a>command</h1><pre><code>覆盖容器启动后默认执行的命令
eg: command: php-fpm
</code></pre><h1 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h1><pre><code>基于已有服务进行他拓展
eg: 我们有个公有的php服务（common-php.yaml）, 内容如下
    common_php:
        build: ./build/common_php
        command: php-fpm
        links:
          - jyd_mysql
          - jyd_redis

这时候有个新的需求，要求搭建一个新的php，需要设置一个环境变量，我们可以这样做（dev_xx.yaml）,内如如下：
    dev_xx:
    extends:
    file: common-php.yaml
    service: common_php
    environment:
        - DEBUG=true

后者的dev_xx.yaml会继承common-php.yaml中的common_php服务
</code></pre><h1 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h1><pre><code>添加主机名映射额
eg: extra_hosts
        - &quot;test.com:10.11.2.12&quot;
        - &quot;demo.com:10.12.22.42&quot;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h1><pre><code>以&quot;yml&quot;或者&quot;yaml&quot;为文件后缀
</code></pre><]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用doker-compose构建开发环境]]></title>
    <link href="http://www.cxyteam.com/2018/06/15/%E5%88%A9%E7%94%A8doker-compose%E6%9E%84%E5%BB%BA%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://www.cxyteam.com/2018/06/15/利用doker-compose构建开发环境/</id>
    <published>2018-06-15T09:45:09.000Z</published>
    <updated>2018-06-15T09:45:09.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="Docker" scheme="http://www.cxyteam.com/tags/Docker/"/>
    
      <category term="Docker" scheme="http://www.cxyteam.com/categories/Docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker镜像如何维护]]></title>
    <link href="http://www.cxyteam.com/2018/06/15/docker%E9%95%9C%E5%83%8F%E5%A6%82%E4%BD%95%E7%BB%B4%E6%8A%A4/"/>
    <id>http://www.cxyteam.com/2018/06/15/docker镜像如何维护/</id>
    <published>2018-06-15T07:05:46.000Z</published>
    <updated>2018-06-20T12:58:24.000Z</updated>
    <content type="html"><![CDATA[<h1 id="通过Dockerfile维护"><a href="#通过Dockerfile维护" class="headerlink" title="通过Dockerfile维护"></a>通过Dockerfile维护</h1><h6 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h6><pre><code>    编写Dockerfile -&gt; 通过docker build生成一个镜像 -&gt; docker push 提交到远程 -&gt; docker pull 别人拉取使用
或
    编写Dockerfile -&gt; 提交到github -&gt; docker hub 设置automated build -&gt; docker pull 别人拉取使用
</code></pre><h6 id="通过镜像直接维护"><a href="#通过镜像直接维护" class="headerlink" title="通过镜像直接维护"></a>通过镜像直接维护</h6><pre><code>本地docker pull最简单的镜像 -&gt; docker commit提交镜像 -&gt; docker push 提交到远程 -&gt; docker pull 别人拉取使用
</code></pre><h1 id="DockerFile流程"><a href="#DockerFile流程" class="headerlink" title="DockerFile流程"></a>DockerFile流程</h1><h6 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h6><pre><code>不重复，可以看之前的文章
注意一点，编写的时候，可以边写，边执行自己的命令进行测试，构建自己的系统；
</code></pre><h6 id="生成镜像"><a href="#生成镜像" class="headerlink" title="生成镜像"></a>生成镜像</h6><pre><code>docker build -t 容器名称 dockerfile路径(eg:docker build -t test_weeb ./)
执行的时候如果出错了，可以docker run生成一个容器，然后进行调试
需要注意的是，出错了之后不需要删除之前的，docker build会有缓存镜像，然后继续往下执行
</code></pre><h6 id="接下来的流程和”通过镜像维护差不多”"><a href="#接下来的流程和”通过镜像维护差不多”" class="headerlink" title="接下来的流程和”通过镜像维护差不多”"></a>接下来的流程和”通过镜像维护差不多”</h6><pre><code>创建容器
提交到本地库
....
需要注意的是每一条修改镜像的命令都写入到dockerfile中，下次构建的话就是最新的镜像了
</code></pre><h1 id="通过镜像维护"><a href="#通过镜像维护" class="headerlink" title="通过镜像维护"></a>通过镜像维护</h1><h6 id="搜索可用镜像"><a href="#搜索可用镜像" class="headerlink" title="搜索可用镜像"></a>搜索可用镜像</h6><pre><code>docker search alpine
</code></pre><h6 id="拉取远程镜像"><a href="#拉取远程镜像" class="headerlink" title="拉取远程镜像"></a>拉取远程镜像</h6><pre><code>docker  pull alpine
</code></pre><h6 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h6><pre><code>docker run -t -i -d -p 8004:80 --name=test -h 127.0.0.1 test_web /bin/bash
注意替换成自己需要的镜像名称
</code></pre><h6 id="提交到本地库"><a href="#提交到本地库" class="headerlink" title="提交到本地库"></a>提交到本地库</h6><pre><code>docker commit -m=&quot;this is test&quot; --author=&apos;sunnysmilez&apos; test test_web_bak:v1
</code></pre><h6 id="本地登录docker-hub"><a href="#本地登录docker-hub" class="headerlink" title="本地登录docker hub"></a>本地登录docker hub</h6><pre><code>查看文件（~/.docker/config.json）是否存在，不存在则创建
docker login 输入用户名密码
</code></pre><h6 id="修改本地镜像名称为远程的名称"><a href="#修改本地镜像名称为远程的名称" class="headerlink" title="修改本地镜像名称为远程的名称"></a>修改本地镜像名称为远程的名称</h6><pre><code>docker tag test_web_bak:v1 sunnysmilez/web-lnmpr
我远程的是sunnysmilez/web-lnmpr
</code></pre><h6 id="提交到远程"><a href="#提交到远程" class="headerlink" title="提交到远程"></a>提交到远程</h6><pre><code>docker push sunnysmilez/web-lnmpr
</code></pre><h1 id="如果别人想启动一样的环境有没有快速的办法"><a href="#如果别人想启动一样的环境有没有快速的办法" class="headerlink" title="如果别人想启动一样的环境有没有快速的办法"></a>如果别人想启动一样的环境有没有快速的办法</h1><h2 id="“拷贝，粘贴”"><a href="#“拷贝，粘贴”" class="headerlink" title="“拷贝，粘贴”"></a>“拷贝，粘贴”</h2><h6 id="导出本地容器"><a href="#导出本地容器" class="headerlink" title="导出本地容器"></a>导出本地容器</h6><pre><code>docker export web_test &gt; web_test.tar
</code></pre><h6 id="传递给别人"><a href="#传递给别人" class="headerlink" title="传递给别人"></a>传递给别人</h6><h6 id="导入本地"><a href="#导入本地" class="headerlink" title="导入本地"></a>导入本地</h6><pre><code>cat web_test.tar | docker import - web_test:latest
注意是导入本地形成了镜像，使用的话需要执行上面的创建容器命令
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="通过Dockerfile维护"><a href="#通过Dockerfile维护" class="headerlink" title="通过Dockerfile维护"></a>通过Dockerfile维护</h1><h6 id="整体流程"><a href="#整]]>
    </summary>
    
      <category term="Docker" scheme="http://www.cxyteam.com/tags/Docker/"/>
    
      <category term="Docker" scheme="http://www.cxyteam.com/categories/Docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[为什么要买重疾险]]></title>
    <link href="http://www.cxyteam.com/2018/06/12/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B9%B0%E9%87%8D%E7%96%BE%E9%99%A9/"/>
    <id>http://www.cxyteam.com/2018/06/12/为什么要买重疾险/</id>
    <published>2018-06-12T12:53:06.000Z</published>
    <updated>2018-06-12T13:12:26.000Z</updated>
    <content type="html"><![CDATA[<h1 id="保险分类"><a href="#保险分类" class="headerlink" title="保险分类"></a>保险分类</h1><h5 id="意外险"><a href="#意外险" class="headerlink" title="意外险"></a>意外险</h5><h5 id="重疾险"><a href="#重疾险" class="headerlink" title="重疾险"></a>重疾险</h5><pre><code>在合同约定的期间内，如果被保险人发生合同约定的重大疾病，或者达到约定的条件后，一次性给付保额
</code></pre><h5 id="医疗险"><a href="#医疗险" class="headerlink" title="医疗险"></a>医疗险</h5><h5 id="寿险"><a href="#寿险" class="headerlink" title="寿险"></a>寿险</h5><pre><code>在合同约定期内，如果被保险人因疾病或者意外造成死亡，则保险公司按照约定的保额给付保险金
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="保险分类"><a href="#保险分类" class="headerlink" title="保险分类"></a>保险分类</h1><h5 id="意外险"><a href="#意外险" class="headerlink" title="意外险"></a>意外]]>
    </summary>
    
      <category term="Other" scheme="http://www.cxyteam.com/tags/Other/"/>
    
      <category term="Other" scheme="http://www.cxyteam.com/categories/Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用beego]]></title>
    <link href="http://www.cxyteam.com/2018/06/06/%E4%BD%BF%E7%94%A8beego/"/>
    <id>http://www.cxyteam.com/2018/06/06/使用beego/</id>
    <published>2018-06-06T13:16:23.000Z</published>
    <updated>2018-06-06T14:10:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>govendor fetch  github.com/astaxie/beego
govendor fetch  github.com/beego/bee
</code></pre><h1 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h1><pre><code>编辑文件：
    sudo vim /etc/profile
    在末尾添加内容如下:
        PATH=$PATH:/usr/local/go/bin:/Users/sunnysmilez/Desktop/code/go_study/bin
        export GOPATH=/Users/sunnysmilez/Desktop/code/go_study
</code></pre><h1 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h1><pre><code>bee 
</code></pre><h1 id="新建项目"><a href="#新建项目" class="headerlink" title="新建项目"></a>新建项目</h1><pre><code>cd /Users/sunnysmilez/Desktop/code/go_study/src
bee new web
</code></pre><h1 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h1><pre><code>cd /Users/sunnysmilez/Desktop/code/go_study/src/web
bee run
</code></pre><h1 id="运行不同端口"><a href="#运行不同端口" class="headerlink" title="运行不同端口"></a>运行不同端口</h1><pre><code>修改文件(/Users/sunnysmilez/Desktop/code/go_study/src/web/conf/app.conf)中的的httpport
</code></pre><h1 id="其他使用事项"><a href="#其他使用事项" class="headerlink" title="其他使用事项"></a>其他使用事项</h1><pre><code>查看手册：https://beego.me/docs/install/bee.md
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre><code>govendor fetch  github.com/astaxie/beego
govendor fetch  githu]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go依赖管理工具]]></title>
    <link href="http://www.cxyteam.com/2018/06/06/go%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>http://www.cxyteam.com/2018/06/06/go依赖管理工具/</id>
    <published>2018-06-06T13:02:51.000Z</published>
    <updated>2018-06-06T13:16:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="设置GOPATH"><a href="#设置GOPATH" class="headerlink" title="设置GOPATH"></a>设置GOPATH</h1><pre><code>export GOPATH=/Users/sunnysmilez/Desktop/code/go_study
</code></pre><h1 id="获取govendor"><a href="#获取govendor" class="headerlink" title="获取govendor"></a>获取govendor</h1><pre><code>cd /Users/sunnysmilez/Desktop/code/go_study
go get -u github.com/kardianos/govendor
</code></pre><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><pre><code>cd /Users/sunnysmilez/Desktop/code/go_study/src
mkdir web
govendor init
</code></pre><h1 id="拉取远程资源"><a href="#拉取远程资源" class="headerlink" title="拉取远程资源"></a>拉取远程资源</h1><pre><code>govendor fetch  github.com/go-xorm/xorm
govendor fetch  github.com/astaxie/beego
govendor fetch  github.com/beego/bee
</code></pre><h1 id="查看本地的包"><a href="#查看本地的包" class="headerlink" title="查看本地的包"></a>查看本地的包</h1><pre><code>govendor list
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="设置GOPATH"><a href="#设置GOPATH" class="headerlink" title="设置GOPATH"></a>设置GOPATH</h1><pre><code>export GOPATH=/Users/sunnysmilez/Deskt]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mysql分表]]></title>
    <link href="http://www.cxyteam.com/2018/05/08/mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/"/>
    <id>http://www.cxyteam.com/2018/05/08/mysql分库分表/</id>
    <published>2018-05-08T10:46:59.000Z</published>
    <updated>2018-05-09T13:19:20.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li><p>问题<br>  1、做分页，检索</p>
<pre><code>合并查询
es
</code></pre><p>  2、跨库事务</p>
<pre><code>程序和数据库自己控制
分布式事务
</code></pre><p>  3、join，count，group by等操作</p>
<pre><code>分两次查询
</code></pre><p>  4、分布式id的生成</p>
<pre><code>雪花算法
uuid
</code></pre><p>  5、数据迁移，容量规划，扩容</p>
<pre><code>利用主从同步，或者双主，来冗余数据，重新搭建主从或者双主同步关系来实现成倍扩容
http://www.10tiao.com/html/249/201702/2651959883/1.html
</code></pre></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<ul>
<li><p>问题<br>  1、做分页，检索</p>
<pre><code>合并查询
es
</code></pre><p>  2、跨库事务</p>
<pre><code>程序和数据库自己控制
分布式事务
</code></pre><p>  3、join，count，]]>
    </summary>
    
      <category term="Mysql" scheme="http://www.cxyteam.com/tags/Mysql/"/>
    
      <category term="Mysql" scheme="http://www.cxyteam.com/categories/Mysql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis-ziplist源码阅读]]></title>
    <link href="http://www.cxyteam.com/2018/03/09/redis-ziplist%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://www.cxyteam.com/2018/03/09/redis-ziplist源码阅读/</id>
    <published>2018-03-09T02:23:29.000Z</published>
    <updated>2018-05-28T15:57:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="ziplist结构"><a href="#ziplist结构" class="headerlink" title="ziplist结构"></a>ziplist结构</h1><ol>
<li>zlbytes：记录整个压缩列表占用的内存字节数</li>
<li>zltail：记录压缩列表表尾节点距离压缩列表的起始地址有多少字节</li>
<li>zllen：记录了压缩列表包含的节点数量</li>
<li>entryX：压缩列表包含的各个节点，节点的长度由节点保存的内容决定</li>
<li>zlend：特殊值 0xFF （十进制 255 ），用于标记压缩列表的末端</li>
</ol>
<h1 id="节点结构"><a href="#节点结构" class="headerlink" title="节点结构"></a>节点结构</h1><pre><code>/*
 * 保存 ziplist 节点信息的结构
 */
typedef struct zlentry {

    // prevrawlen ：前置节点的长度
    // prevrawlensize ：编码 prevrawlen 所需的字节大小；只能是１字节或者５字节
    unsigned int prevrawlensize, prevrawlen;

    // len ：当前节点值的长度，指出实体字段的具体长度即真正存储数据的字段，单位是字节
    // lensize ：编码 len 所需的字节大小, 1字节，　２字节　５字节
    unsigned int lensize, len;

    // 当前节点 header 的大小
    // 等于 prevrawlensize + lensize
    unsigned int headersize;

    // 当前节点值所使用的编码类型
    unsigned char encoding;

    // 指向当前节点的指针
    unsigned char *p;

} zlentry;
</code></pre><p><img src="/img/redis/ziplist.png" alt="Alt text" title="ziplist结构"></p>
<ol>
<li>prevrawlensize：编码prevrawlen所需的字节大小</li>
<li>prevrawlen：前置节点的长度；当长度小于255字节时，用一个字节存储；当长度大于等于255时，用五个字节进行存储，其中第一个字节会被设置为255表示前一个entry的长度由后面四个字节表示</li>
<li>len：当前节点值的长度</li>
<li>lensize：编码 len 所需的字节大小, 1字节，　２字节　５字节</li>
<li>headersize：等于 prevrawlensize + lensize</li>
<li><p>encoding：当前节点值所使用的编码类；它会根据当前元素内容的不同会采用不同的编码方式<br> 如果元素内容为字符串，encoding的值分别为：<br> 00xx xxxx ：00开头表示该字符串的长度用6个bit表示。<br> 01xx xxxx | xxxx xxxx ：01开头表示字符串的长度由14bit表示，这14个bit采用大端存储。<br> 1000 0000 | xxxx xxxx | xxxx xxxx | xxxx xxxx | xxxx xxxx ：10开头表示后续的四个字节为字符串长度，这32个bit采用大端存储</p>
<p> 如果元素内容为数字，encoding的值分别为：<br> 1100 0000：表示数字占用后面2个字节。<br> 1101 0000：表示数字占用后面4个字节。<br> 1110 0000：表示数字占用后面8个字节。<br> 1111 0000 ：表示数字占用后面3个字节。<br> 1111 1110 ：表示数字占用后面1个字节。<br> 1111 1111 ：表示压缩链表中最后一个元素（特殊编码）。<br> 1111 xxxx ：表示只用后4位表示0~12的整数，由于0000，1110跟1111三种已经被占用，也就是说这里的xxxx四位只能表示0001~1101，转换成十进制就是数字1~13，但是redis规定它用来表示0~12，因此当遇到这个编码时，我们需要取出后四位然后减1来得到正确的值。</p>
</li>
<li><p>*p：指向当前节点的指针</p>
</li>
</ol>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ol>
<li>一个列表只含有少量列表项</li>
<li>每个列表项是小整数值或者长度比较短的字符串</li>
</ol>
<h1 id="编码，解码"><a href="#编码，解码" class="headerlink" title="编码，解码"></a>编码，解码</h1><h3 id="编码前置节点长度信息"><a href="#编码前置节点长度信息" class="headerlink" title="编码前置节点长度信息"></a>编码前置节点长度信息</h3><pre><code>/* Encode the length of the previous entry and write it to &quot;p&quot;. Return the
 * number of bytes needed to encode this length if &quot;p&quot; is NULL. 
 *
 * 对前置节点的长度 len 进行编码，并将它写入到 p 中，
 * 然后返回编码 len 所需的字节数量。
 *
 * 如果 p 为 NULL ，那么不进行写入，仅返回编码 len 所需的字节数量。
 *
 * T = O(1)
 * 前置节点的长度编码字节数只有１字节和５字节
 * 如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性的长度为 1 字节： 前一节点的长度就保存在这一个字节里面。
 * 如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE （十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。
 */
static unsigned int zipPrevEncodeLength(unsigned char *p, unsigned int len) {

    // 仅返回编码 len 所需的字节数量
    if (p == NULL) {
        return (len &lt; ZIP_BIGLEN) ? 1 : sizeof(len) + 1;
    } else {
        // 写入并返回编码 len 所需的字节数量
        // 1 字节
        if (len &lt; ZIP_BIGLEN) {
            p[0] = len;
            return 1;

        // 5 字节
        } else {
            // 添加 5 字节长度标识
            p[0] = ZIP_BIGLEN;
            // 写入编码
            memcpy(p + 1, &amp;len, sizeof(len));
            // 如果有必要的话，进行大小端转换
            memrev32ifbe(p + 1);
            // 返回编码长度
            return 1 + sizeof(len);
        }
    }
}
</code></pre><h3 id="解码前置节点长度信息"><a href="#解码前置节点长度信息" class="headerlink" title="解码前置节点长度信息"></a>解码前置节点长度信息</h3><pre><code>/* Decode the number of bytes required to store the length of the previous
 * element, from the perspective of the entry pointed to by &apos;ptr&apos;. 
 *
 * 解码 ptr 指针，
 * 取出编码前置节点长度所需的字节数，并将它保存到 prevlensize 变量中。
 *
 * T = O(1)
 */
#define ZIP_DECODE_PREVLENSIZE(ptr, prevlensize) do {                          \
    if ((ptr)[0] &lt; ZIP_BIGLEN) {                                               \
        (prevlensize) = 1;                                                     \
    } else {                                                                   \
        (prevlensize) = 5;                                                     \
    }                                                                          \
} while(0);

/* Decode the length of the previous element, from the perspective of the entry
 * pointed to by &apos;ptr&apos;. 
 *
 * 解码 ptr 指针，
 * 取出编码前置节点长度所需的字节数，
 * 并将这个字节数保存到 prevlensize 中。
 *
 * 然后根据 prevlensize ，从 ptr 中取出前置节点的长度值，
 * 并将这个长度值保存到 prevlen 变量中。
 *
 * T = O(1)
 */
#define ZIP_DECODE_PREVLEN(ptr, prevlensize, prevlen) do {                     \
                                                                               \
    /* 先计算被编码长度值的字节数 */                                           \
    ZIP_DECODE_PREVLENSIZE(ptr, prevlensize);                                  \
                                                                               \
    /* 再根据编码字节数来取出长度值 */                                         \
    if ((prevlensize) == 1) {                                                  \
        (prevlen) = (ptr)[0];                                                  \
    } else if ((prevlensize) == 5) {                                           \
        assert(sizeof((prevlensize)) == 4);                                    \
        memcpy(&amp;(prevlen), ((char*)(ptr)) + 1, 4);                             \
        memrev32ifbe(&amp;prevlen);                                                \
    }                                                                          \
} while(0);
</code></pre><h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><pre><code>/*
 * 根据指针 p 所指定的位置，将长度为 slen 的字符串 s 插入到 zl 中。
 *
 * 函数的返回值为完成插入操作之后的 ziplist
 *
 * T = O(N^2)
 */
static unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {
    // 记录当前 ziplist 的长度
    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen, prevlen = 0;
    size_t offset;
    int nextdiff = 0;
    unsigned char encoding = 0;
    long long value = 123456789; /* initialized to avoid warning. Using a value
                                    that is easy to see if for some reason
                                    we use it uninitialized. */
    zlentry entry, tail;

    /* Find out prevlen for the entry that is inserted. */
    if (p[0] != ZIP_END) {
        // 如果 p[0] 不指向列表末端，说明列表非空，并且 p 正指向列表的其中一个节点
        // 那么取出 p 所指向节点的信息，并将它保存到 entry 结构中
        // 然后用 prevlen 变量记录前置节点的长度
        // （当插入新节点之后 p 所指向的节点就成了新节点的前置节点）
        // T = O(1)
        entry = zipEntry(p);
        prevlen = entry.prevrawlen;
    } else {
        // 如果 p 指向表尾末端，那么程序需要检查列表是否为：
        // 1)如果 ptail 也指向 ZIP_END ，那么列表为空；
        // 2)如果列表不为空，那么 ptail 将指向列表的最后一个节点。
        unsigned char *ptail = ZIPLIST_ENTRY_TAIL(zl);
        if (ptail[0] != ZIP_END) {
            // 表尾节点为新节点的前置节点

            // 取出表尾节点的长度
            // T = O(1)
            prevlen = zipRawEntryLength(ptail);
        }
    }

    /* See if the entry can be encoded */
    // 尝试看能否将输入字符串转换为整数，如果成功的话：
    // 1)value 将保存转换后的整数值
    // 2)encoding 则保存适用于 value 的编码方式
    // 无论使用什么编码， reqlen 都保存节点值的长度
    // T = O(N)
    if (zipTryEncoding(s, slen, &amp;value, &amp;encoding)) {
        /* &apos;encoding&apos; is set to the appropriate integer encoding */
        reqlen = zipIntSize(encoding);
    } else {
        /* &apos;encoding&apos; is untouched, however zipEncodeLength will use the
         * string length to figure out how to encode it. */
        reqlen = slen;
    }
    /* We need space for both the length of the previous entry and
     * the length of the payload. */
    // 计算编码前置节点的长度所需的大小
    // T = O(1)
    reqlen += zipPrevEncodeLength(NULL, prevlen);
    // 计算编码当前节点值所需的大小
    // T = O(1)
    reqlen += zipEncodeLength(NULL, encoding, slen);

    /* When the insert position is not equal to the tail, we need to
     * make sure that the next entry can hold this entry&apos;s length in
     * its prevlen field. */
    // 只要新节点不是被添加到列表末端，
    // 那么程序就需要检查看 p 所指向的节点（的 header）能否编码新节点的长度。
    // nextdiff 保存了新旧编码之间的字节大小差，如果这个值大于 0
    // 那么说明需要对 p 所指向的节点（的 header ）进行扩展
    // T = O(1)
    nextdiff = (p[0] != ZIP_END) ? zipPrevLenByteDiff(p, reqlen) : 0;

    /* Store offset because a realloc may change the address of zl. */
    // 因为重分配空间可能会改变 zl 的地址
    // 所以在分配之前，需要记录 zl 到 p 的偏移量，然后在分配之后依靠偏移量还原 p
    offset = p-zl;
    // curlen 是 ziplist 原来的长度
    // reqlen 是整个新节点的长度
    // nextdiff 是新节点的后继节点扩展 header 的长度（要么 0 字节，要么 4 个字节）
    // T = O(N)
    zl = ziplistResize(zl, curlen + reqlen + nextdiff);
    p = zl + offset;

    /* Apply memory move when necessary and update tail offset. */
    if (p[0] != ZIP_END) {
        // 新元素之后还有节点，因为新元素的加入，需要对这些原有节点进行调整

        /* Subtract one because of the ZIP_END bytes */
        // 移动现有元素，为新元素的插入空间腾出位置
        // T = O(N)
        memmove(p + reqlen, p - nextdiff, curlen - offset - 1 + nextdiff);

        /* Encode this entry&apos;s raw length in the next entry. */
        // 将新节点的长度编码至后置节点
        // p+reqlen 定位到后置节点
        // reqlen 是新节点的长度
        // T = O(1)
        zipPrevEncodeLength(p + reqlen, reqlen);

        /* Update offset for tail */
        // 更新到达表尾的偏移量，将新节点的长度也算上
        ZIPLIST_TAIL_OFFSET(zl) =
                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)) + reqlen);

        /* When the tail contains more than one entry, we need to take
         * &quot;nextdiff&quot; in account as well. Otherwise, a change in the
         * size of prevlen doesn&apos;t have an effect on the *tail* offset. */
        // 如果新节点的后面有多于一个节点
        // 那么程序需要将 nextdiff 记录的字节数也计算到表尾偏移量中
        // 这样才能让表尾偏移量正确对齐表尾节点
        // T = O(1)
        tail = zipEntry(p + reqlen);
        if (p[reqlen + tail.headersize + tail.len] != ZIP_END) {
            ZIPLIST_TAIL_OFFSET(zl) =
                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)) + nextdiff);
        }
    } else {
        /* This element will be the new tail. */
        // 新元素是新的表尾节点
        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p - zl);
    }

    /* When nextdiff != 0, the raw length of the next entry has changed, so
     * we need to cascade the update throughout the ziplist */
    // 当 nextdiff != 0 时，新节点的后继节点的（header 部分）长度已经被改变，
    // 所以需要级联地更新后续的节点
    if (nextdiff != 0) {
        offset = p - zl;
        // T  = O(N^2)
        zl = __ziplistCascadeUpdate(zl, p + reqlen);
        p = zl + offset;
    }

    /* Write the entry */
    // 一切搞定，将前置节点的长度写入新节点的 header
    p += zipPrevEncodeLength(p, prevlen);
    // 将节点值的长度写入新节点的 header
    p += zipEncodeLength(p, encoding, slen);
    // 写入节点值
    if (ZIP_IS_STR(encoding)) {
        // T = O(N)
        memcpy(p, s, slen);
    } else {
        // T = O(1)
        zipSaveInteger(p, value, encoding);
    }

    // 更新列表的节点数量计数器
    // T = O(1)
    ZIPLIST_INCR_LENGTH(zl, 1);

    return zl;
}
</code></pre><h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><pre><code>/* Delete &quot;num&quot; entries, starting at &quot;p&quot;. Returns pointer to the ziplist.
 *
 * 从位置 p 开始，连续删除 num 个节点。
 *
 * 函数的返回值为处理删除操作之后的 ziplist 。
 *
 * T = O(N^2)
 */
static unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) {
    unsigned int i, totlen, deleted = 0;
    size_t offset;
    int nextdiff = 0;
    zlentry first, tail;

    // 计算被删除节点总共占用的内存字节数
    // 以及被删除节点的总个数
    // T = O(N)
    first = zipEntry(p);
    for (i = 0; p[0] != ZIP_END &amp;&amp; i &lt; num; i++) {
        p += zipRawEntryLength(p);
        deleted++;
    }

    // totlen 是所有被删除节点总共占用的内存字节数
    totlen = p-first.p;
    if (totlen &gt; 0) {
        if (p[0] != ZIP_END) {

            // 执行这里，表示被删除节点之后仍然有节点存在

            /* Storing `prevrawlen` in this entry may increase or decrease the
             * number of bytes required compare to the current `prevrawlen`.
             * There always is room to store this, because it was previously
             * stored by an entry that is now being deleted. */
            // 因为位于被删除范围之后的第一个节点的 header 部分的大小
            // 可能容纳不了新的前置节点，所以需要计算新旧前置节点之间的字节数差
            // T = O(1)
            nextdiff = zipPrevLenByteDiff(p, first.prevrawlen);
            // 如果有需要的话，将指针 p 后退 nextdiff 字节，为新 header 空出空间
            p -= nextdiff;
            // 将 first 的前置节点的长度编码至 p 中
            // T = O(1)
            zipPrevEncodeLength(p, first.prevrawlen);

            /* Update offset for tail */
            // 更新到达表尾的偏移量
            // T = O(1)
            ZIPLIST_TAIL_OFFSET(zl) =
                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)) - totlen);

            /* When the tail contains more than one entry, we need to take
             * &quot;nextdiff&quot; in account as well. Otherwise, a change in the
             * size of prevlen doesn&apos;t have an effect on the *tail* offset. */
            // 如果被删除节点之后，有多于一个节点
            // 那么程序需要将 nextdiff 记录的字节数也计算到表尾偏移量中
            // 这样才能让表尾偏移量正确对齐表尾节点
            // T = O(1)
            tail = zipEntry(p);
            if (p[tail.headersize+tail.len] != ZIP_END) {
                ZIPLIST_TAIL_OFFSET(zl) =
                        intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)) + nextdiff);
            }

            /* Move tail to the front of the ziplist */
            // 从表尾向表头移动数据，覆盖被删除节点的数据
            // T = O(N)
            memmove(first.p, p,
                    intrev32ifbe(ZIPLIST_BYTES(zl)) - (p - zl) - 1);
        } else {

            // 执行这里，表示被删除节点之后已经没有其他节点了

            /* The entire tail was deleted. No need to move memory. */
            // T = O(1)
            ZIPLIST_TAIL_OFFSET(zl) =
                    intrev32ifbe((first.p-zl) - first.prevrawlen);
        }

        /* Resize and update length */
        // 缩小并更新 ziplist 的长度
        offset = first.p - zl;
        zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl)) - totlen+nextdiff);
        ZIPLIST_INCR_LENGTH(zl, -deleted);
        p = zl + offset;

        /* When nextdiff != 0, the raw length of the next entry has changed, so
         * we need to cascade the update throughout the ziplist */
        // 如果 p 所指向的节点的大小已经变更，那么进行级联更新
        // 检查 p 之后的所有节点是否符合 ziplist 的编码要求
        // T = O(N^2)
        if (nextdiff != 0) {
            zl = __ziplistCascadeUpdate(zl, p);
        }
    }

    return zl;
}
</code></pre><h1 id="连锁更新"><a href="#连锁更新" class="headerlink" title="连锁更新"></a>连锁更新</h1><pre><code>/* When an entry is inserted, we need to set the prevlen field of the next
 * entry to equal the length of the inserted entry. It can occur that this
 * length cannot be encoded in 1 byte and the next entry needs to be grow
 * a bit larger to hold the 5-byte encoded prevlen. This can be done for free,
 * because this only happens when an entry is already being inserted (which
 * causes a realloc and memmove). However, encoding the prevlen may require
 * that this entry is grown as well. This effect may cascade throughout
 * the ziplist when there are consecutive entries with a size close to
 * ZIP_BIGLEN, so we need to check that the prevlen can be encoded in every
 * consecutive entry.
 *
 * 当将一个新节点添加到某个节点之前的时候，
 * 如果原节点的 header 空间不足以保存新节点的长度，
 * 那么就需要对原节点的 header 空间进行扩展（从 1 字节扩展到 5 字节）。
 *
 * 但是，当对原节点进行扩展之后，原节点的下一个节点的 prevlen 可能出现空间不足，
 * 这种情况在多个连续节点的长度都接近 ZIP_BIGLEN 时可能发生。
 *
 * 这个函数就用于检查并修复后续节点的空间问题。
 *
 * Note that this effect can also happen in reverse, where the bytes required
 * to encode the prevlen field can shrink. This effect is deliberately ignored,
 * because it can cause a &quot;flapping&quot; effect where a chain prevlen fields is
 * first grown and then shrunk again after consecutive inserts. Rather, the
 * field is allowed to stay larger than necessary, because a large prevlen
 * field implies the ziplist is holding large entries anyway.
 *
 * 反过来说，
 * 因为节点的长度变小而引起的连续缩小也是可能出现的，
 * 不过，为了避免扩展-缩小-扩展-缩小这样的情况反复出现（flapping，抖动），
 * 我们不处理这种情况，而是任由 prevlen 比所需的长度更长。

 * The pointer &quot;p&quot; points to the first entry that does NOT need to be
 * updated, i.e. consecutive fields MAY need an update.
 *
 * 注意，程序的检查是针对 p 的后续节点，而不是 p 所指向的节点。
 * 因为节点 p 在传入之前已经完成了所需的空间扩展工作。
 *
 * T = O(N^2)
 */
static unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {
    size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;
    size_t offset, noffset, extra;
    unsigned char *np;
    zlentry cur, next;

    // T = O(N^2)
    while (p[0] != ZIP_END) {

        // 将 p 所指向的节点的信息保存到 cur 结构中
        cur = zipEntry(p);
        // 当前节点的长度
        rawlen = cur.headersize + cur.len;
        // 计算编码当前节点的长度所需的字节数
        // T = O(1)
        rawlensize = zipPrevEncodeLength(NULL, rawlen);

        /* Abort if there is no next entry. */
        // 如果已经没有后续空间需要更新了，跳出
        if (p[rawlen] == ZIP_END) {
            break;
        }

        // 取出后续节点的信息，保存到 next 结构中
        // T = O(1)
        next = zipEntry(p + rawlen);

        /* Abort when &quot;prevlen&quot; has not changed. */
        // 后续节点编码当前节点的空间已经足够，无须再进行任何处理，跳出
        // 可以证明，只要遇到一个空间足够的节点，
        // 那么这个节点之后的所有节点的空间都是足够的
        if (next.prevrawlen == rawlen) {
            break;
        }

        if (next.prevrawlensize &lt; rawlensize) {

            /* The &quot;prevlen&quot; field of &quot;next&quot; needs more bytes to hold
             * the raw length of &quot;cur&quot;. */
            // 执行到这里，表示 next 空间的大小不足以编码 cur 的长度
            // 所以程序需要对 next 节点的（header 部分）空间进行扩展

            // 记录 p 的偏移量
            offset = p - zl;
            // 计算需要增加的节点数量
            extra = rawlensize - next.prevrawlensize;
            // 扩展 zl 的大小
            // T = O(N)
            zl = ziplistResize(zl, curlen + extra);
            // 还原指针 p
            p = zl + offset;

            /* Current pointer and offset for next element. */
            // 记录下一节点的偏移量
            np = p + rawlen;
            noffset = np - zl;

            /* Update tail offset when next element is not the tail element. */
            // 当 next 节点不是表尾节点时，更新列表到表尾节点的偏移量
            //
            // 不用更新的情况（next 为表尾节点）：
            //
            // |     | next |      ==&gt;    |     | new next          |
            //       ^                          ^
            //       |                          |
            //     tail                        tail
            //
            // 需要更新的情况（next 不是表尾节点）：
            //
            // | next |     |   ==&gt;     | new next          |     |
            //        ^                        ^
            //        |                        |
            //    old tail                 old tail
            //
            // 更新之后：
            //
            // | new next          |     |
            //                     ^
            //                     |
            //                  new tail
            // T = O(1)
            if ((zl + intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) {
                ZIPLIST_TAIL_OFFSET(zl) =
                        intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)) + extra);
            }

            /* Move the tail to the back. */
            // 向后移动 cur 节点之后的数据，为 cur 的新 header 腾出空间
            //
            // 示例：
            //
            // | header | value |  ==&gt;  | header |    | value |  ==&gt;  | header      | value |
            //                                   |&lt;--&gt;|
            //                            为新 header 腾出的空间
            // T = O(N)
            memmove(np+rawlensize,
                    np+next.prevrawlensize,
                    curlen - noffset - next.prevrawlensize - 1);
            // 将新的前一节点长度值编码进新的 next 节点的 header
            // T = O(1)
            zipPrevEncodeLength(np, rawlen);

            /* Advance the cursor */
            // 移动指针，继续处理下个节点
            p += rawlen;
            curlen += extra;
        } else {
            if (next.prevrawlensize &gt; rawlensize) {
                /* This would result in shrinking, which we want to avoid.
                 * So, set &quot;rawlen&quot; in the available bytes. */
                // 执行到这里，说明 next 节点编码前置节点的 header 空间有 5 字节
                // 而编码 rawlen 只需要 1 字节
                // 但是程序不会对 next 进行缩小，
                // 所以这里只将 rawlen 写入 5 字节的 header 中就算了。
                // T = O(1)
                zipPrevEncodeLengthForceLarge(p + rawlen, rawlen);
            } else {
                // 运行到这里，
                // 说明 cur 节点的长度正好可以编码到 next 节点的 header 中
                // T = O(1)
                zipPrevEncodeLength(p + rawlen, rawlen);
            }

            /* Stop here, as the raw length of &quot;next&quot; has not changed. */
            break;
        }
    }

    return zl;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="ziplist结构"><a href="#ziplist结构" class="headerlink" title="ziplist结构"></a>ziplist结构</h1><ol>
<li>zlbytes：记录整个压缩列表占用的内存字节数</li>
<li>zl]]>
    </summary>
    
      <category term="Redis" scheme="http://www.cxyteam.com/tags/Redis/"/>
    
      <category term="Redis" scheme="http://www.cxyteam.com/categories/Redis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[docker-如何解决container服务中配置文件个性化的问题]]></title>
    <link href="http://www.cxyteam.com/2018/03/02/docker-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%98%E6%9B%B4%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://www.cxyteam.com/2018/03/02/docker-如何解决配置文件变更的问题/</id>
    <published>2018-03-02T02:33:25.000Z</published>
    <updated>2018-05-10T11:12:37.000Z</updated>
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><ol>
<li>传统的服务中，如果我们需要修改nginx的配置，只需要对nginx.conf进行修改，然后重启nginx的服务即可生效</li>
<li>在docker搭建中，如果我们的image中已经使用了nginx.conf的配置文件，那么我docker run的container的配置文件和image中的配置文件是一致的，如果我想修改container中nginx的log路径，我应该怎么做呢？</li>
<li>是不是我需要这样，首先修改nginx.conf 然后再commit当前container，最后再push当前container，如果我需要运行两个container有不一致的nginx.conf呢？</li>
</ol>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ol>
<li>通过env传递，但是仅限于很简单的配置，像nginx这样的配置文件是不太可能使用这种方式</li>
<li>通过volume挂载宿主机文件，但如果在集群中，容器漂移到其他宿主机就找不到配置文件，缺乏横向扩展<br>  docker run -t -i -d -p 8004:80 –name=pay_game -h 127.0.0.1 -v ~/Desktop/devspace/apo_api:/data1/htdocs/apo_api -v ~/Desktop/devspace/apo_api/project/config/nginx/vhosts:/usr/local/openresty/nginx/conf/vhosts lnmpr</li>
<li>使用zookeeper或者etcd来存放配置文件数据，创建容器时通过 ENV 传递配置文件的 KEY，应用启动前用 KEY 拉取配置文件，然后启动应用</li>
</ol>
<h1 id="查看容器启动时的命令"><a href="#查看容器启动时的命令" class="headerlink" title="查看容器启动时的命令"></a>查看容器启动时的命令</h1><pre><code>docker inspect pay_game
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><ol>
<li>传统的服务中，如果我们需要修改nginx的配置，只需要对nginx.conf进行修改，然后重启nginx的服务即]]>
    </summary>
    
      <category term="Docker" scheme="http://www.cxyteam.com/tags/Docker/"/>
    
      <category term="Docker" scheme="http://www.cxyteam.com/categories/Docker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[活动机器数预估]]></title>
    <link href="http://www.cxyteam.com/2018/02/12/%E6%B4%BB%E5%8A%A8%E6%9C%BA%E5%99%A8%E6%95%B0%E9%A2%84%E4%BC%B0/"/>
    <id>http://www.cxyteam.com/2018/02/12/活动机器数预估/</id>
    <published>2018-02-12T01:35:24.000Z</published>
    <updated>2018-02-12T01:38:34.000Z</updated>
    <content type="html"><![CDATA[<h1 id="qps"><a href="#qps" class="headerlink" title="qps"></a>qps</h1><h3 id="php连接数"><a href="#php连接数" class="headerlink" title="php连接数"></a>php连接数</h3><h3 id="redis连接数"><a href="#redis连接数" class="headerlink" title="redis连接数"></a>redis连接数</h3><h3 id="mysql连接数"><a href="#mysql连接数" class="headerlink" title="mysql连接数"></a>mysql连接数</h3><h1 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h1>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="qps"><a href="#qps" class="headerlink" title="qps"></a>qps</h1><h3 id="php连接数"><a href="#php连接数" class="headerlink" title="php连接数"><]]>
    </summary>
    
      <category term="Other" scheme="http://www.cxyteam.com/tags/Other/"/>
    
      <category term="Other" scheme="http://www.cxyteam.com/categories/Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mysql字符集]]></title>
    <link href="http://www.cxyteam.com/2018/02/09/mysql%E5%AD%97%E7%AC%A6%E9%9B%86/"/>
    <id>http://www.cxyteam.com/2018/02/09/mysql字符集/</id>
    <published>2018-02-09T03:48:24.000Z</published>
    <updated>2018-02-11T09:56:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="影响mysql中文展示乱码的原因"><a href="#影响mysql中文展示乱码的原因" class="headerlink" title="影响mysql中文展示乱码的原因"></a>影响mysql中文展示乱码的原因</h1><ol>
<li>库的字符集</li>
<li>连接字符集</li>
<li>页面显示字符集</li>
</ol>
<h1 id="查看mysql字符集设置"><a href="#查看mysql字符集设置" class="headerlink" title="查看mysql字符集设置"></a>查看mysql字符集设置</h1><pre><code>SHOW VARIABLES LIKE &apos;character%&apos;;
</code></pre><h1 id="设置mysql字符集为utf8"><a href="#设置mysql字符集为utf8" class="headerlink" title="设置mysql字符集为utf8"></a>设置mysql字符集为utf8</h1><pre><code>SET character_set_client = utf8 ;  
SET character_set_connection = utf8 ;   
SET character_set_database = utf8 ;   
SET character_set_results = utf8 ;    
SET character_set_server = utf8;
SET collation_connection = utf8 ;  
SET collation_database = utf8 ;   
SET collation_server = utf8 ; 
SET NAMES &apos;utf8&apos;;
set collation_database=utf8_general_ci;
set collation_database=utf8_general_ci;
set collation_server=utf8_general_ci;
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="影响mysql中文展示乱码的原因"><a href="#影响mysql中文展示乱码的原因" class="headerlink" title="影响mysql中文展示乱码的原因"></a>影响mysql中文展示乱码的原因</h1><ol>
<li>库的字符集</l]]>
    </summary>
    
      <category term="Mysql" scheme="http://www.cxyteam.com/tags/Mysql/"/>
    
      <category term="Mysql" scheme="http://www.cxyteam.com/categories/Mysql/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis-intset源码阅读]]></title>
    <link href="http://www.cxyteam.com/2018/02/06/redis-intset%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://www.cxyteam.com/2018/02/06/redis-intset源码阅读/</id>
    <published>2018-02-06T13:52:05.000Z</published>
    <updated>2018-03-08T09:53:36.000Z</updated>
    <content type="html"><![CDATA[<h1 id="intset数据结构"><a href="#intset数据结构" class="headerlink" title="intset数据结构"></a>intset数据结构</h1><pre><code>typedef struct intset {

    // 编码方式
    uint32_t encoding;

    // 集合包含的元素数量
    uint32_t length;

    // 保存元素的数组
    int8_t contents[];

} intset;
</code></pre><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ol>
<li>元素类型只能是数字</li>
<li>元素有三种类型：int16_t,int32_t,int64_t</li>
<li>元素有序，不能重复</li>
<li>inset和sds一样，内存连续，就像数组一样</li>
<li>intset不提供降级操作，一旦对编码进行了升级，编码就会一直保持升级后的状态</li>
</ol>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ol>
<li>主要用于集合(set)的底层实现之一</li>
<li>当集合元素不大于设定值并且元素都是整数时</li>
</ol>
<h1 id="编码方式的获取"><a href="#编码方式的获取" class="headerlink" title="编码方式的获取"></a>编码方式的获取</h1><ol>
<li>这个函数试试判断传入的数据应该用什么数据类型进行存储</li>
<li>需要注意一点的是INT32_MIN是负值的最小值（-2147483648）<br> static uint8_t _intsetValueEncoding(int64_t v) {<pre><code>if (v &lt; INT32_MIN || v &gt; INT32_MAX) {
    return INTSET_ENC_INT64;
}
else if (v &lt; INT16_MIN || v &gt; INT16_MAX) {
    return INTSET_ENC_INT32;
}
else {
    return INTSET_ENC_INT16;
}
</code></pre> }</li>
</ol>
<h1 id="大小端模式"><a href="#大小端模式" class="headerlink" title="大小端模式"></a>大小端模式</h1><ol>
<li>大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放</li>
<li>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致<br><img src="/img/redis/duan.png" alt="Alt text" title="大小端模式"></li>
</ol>
<h1 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h1><ol>
<li>还是老一套，判断encode，修改值；修改length值，添加到content中</li>
<li>如果需要添加的值存在的话不会再进行添加</li>
</ol>
<pre><code>intset *intsetAdd(intset *is, int64_t value, uint8_t *success) {
    //printf(&quot;---------\n&quot;);
    //printf(&quot;start\n&quot;);
    // 计算编码 value 所需的长度
    uint8_t valenc = _intsetValueEncoding(value);
    uint32_t pos;
    // 默认设置插入为成功
    if (success) {
        *success = 1;
    }

    /* Upgrade encoding if necessary. If we need to upgrade, we know that
     * this value should be either appended (if &gt; 0) or prepended (if &lt; 0),
     * because it lies outside the range of existing values. */
    // 如果 value 的编码比整数集合现在的编码要大
    // 那么表示 value 必然可以添加到整数集合中
    // 并且整数集合需要对自身进行升级，才能满足 value 所需的编码
    if (valenc &gt; intrev32ifbe(is-&gt;encoding)) {
        //printf(&quot;大于\n&quot;);
        /* This always succeeds, so we don&apos;t need to curry *success. */
        // T = O(N)
        return intsetUpgradeAndAdd(is, value);
    } else {
        //printf(&quot;小于\n&quot;);
        // 运行到这里，表示整数集合现有的编码方式适用于 value

        /* Abort if the value is already present in the set.
         * This call will populate &quot;pos&quot; with the right position to insert
         * the value when it cannot be found. */
        // 在整数集合中查找 value ，看他是否存在：
        // - 如果存在，那么将 *success 设置为 0 ，并返回未经改动的整数集合
        // - 如果不存在，那么可以插入 value 的位置将被保存到 pos 指针中
        //   等待后续程序使用
        if (intsetSearch(is, value, &amp;pos)) {
            //printf(&quot;存在\n&quot;);
            if (success) {
                *success = 0;
            }
            return is;
        }

        //printf(&quot;不存在，search后的pos值：%d\n&quot;, pos);

        // 运行到这里，表示 value 不存在于集合中
        // 程序需要将 value 添加到整数集合中

        // 为 value 在集合中分配空间
        is = intsetResize(is, intrev32ifbe(is-&gt;length) + 1);
        // 如果新元素不是被添加到底层数组的末尾
        // 那么需要对现有元素的数据进行移动，空出 pos 上的位置，用于设置新值
        // 举个例子
        // 如果数组为：
        // | x | y | z | ? |
        //     |&lt;-----&gt;|
        // 而新元素 n 的 pos 为 1 ，那么数组将移动 y 和 z 两个元素
        // | x | y | y | z |
        //         |&lt;-----&gt;|
        // 这样就可以将新元素设置到 pos 上了：
        // | x | n | y | z |
        // T = O(N)
        //printf(&quot;pos:%d\n&quot;, pos);
        //printf(&quot;is-&gt;length:%d\n&quot;, intrev32ifbe(is-&gt;length));
        if (pos &lt; intrev32ifbe(is-&gt;length)) {
            //printf(&quot;pos&lt;length\n&quot;);
            intsetMoveTail(is, pos, pos + 1);
        }
    }

    // 将新值设置到底层数组的指定位置中
    _intsetSet(is, pos, value);
    //printf(&quot;value:%lld\n&quot;, value);

    // 增加集合元素数量的计数器
    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length) + 1);

    // 返回添加新元素后的整数集合
    return is;

    /* p.s. 上面的代码可以重构成以下更简单的形式：

    if (valenc &gt; intrev32ifbe(is-&gt;encoding)) {
        return intsetUpgradeAndAdd(is,value);
    }

    if (intsetSearch(is,value,&amp;pos)) {
        if (success) *success = 0;
        return is;
    } else {
        is = intsetResize(is,intrev32ifbe(is-&gt;length)+1);
        if (pos &lt; intrev32ifbe(is-&gt;length)) intsetMoveTail(is,pos,pos+1);
        _intsetSet(is,pos,value);

        is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+1);
        return is;
    }
    */
}
</code></pre><h1 id="搜索元素"><a href="#搜索元素" class="headerlink" title="搜索元素"></a>搜索元素</h1><ol>
<li>主要看看二分排序法</li>
<li>如果该值不存在，会把该值的前一个元素的pos返回回来（比如要查找8，但是intset结构中只存在6这个元素，就会把6所在的pos返回）</li>
</ol>
<pre><code>static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) {
    int min = 0, max = intrev32ifbe(is-&gt;length) - 1, mid = -1;
    int64_t cur = -1;

    /* The value can never be found when the set is empty */
    // 处理 is 为空时的情况
    if (intrev32ifbe(is-&gt;length) == 0) {
        if (pos) {
            *pos = 0;
        }
        printf(&quot;不存在,pos为：%d\n&quot;, *pos);
        return 0;
    } else {
        /* Check for the case where we know we cannot find the value,
         * but do know the insert position. */
        // 因为底层数组是有序的，如果 value 比数组中最后一个值都要大
        // 那么 value 肯定不存在于集合中，
        // 并且应该将 value 添加到底层数组的最末端
        if (value &gt; _intsetGet(is, intrev32ifbe(is-&gt;length) - 1)) {
            if (pos) {
                *pos = intrev32ifbe(is-&gt;length);//返回最末端的pos
            }
            printf(&quot;最大值,pos为：%d\n&quot;, *pos);
            return 0;
        // 因为底层数组是有序的，如果 value 比数组中最前一个值都要小
        // 那么 value 肯定不存在于集合中，
        // 并且应该将它添加到底层数组的最前端
        } else if (value &lt; _intsetGet(is,0)) {
            if (pos) {
                *pos = 0;
            }
            printf(&quot;最小值,pos为：%d\n&quot;, *pos);
            return 0;
        }
    }

    // 在有序数组中进行二分查找
    // T = O(log N)
    while(max &gt;= min) {
        mid = (min+max) / 2;
        cur = _intsetGet(is, mid);
        if (value &gt; cur) {
            min = mid + 1;
        } else if (value &lt; cur) {
            max = mid - 1;
        } else {
            break;
        }
    }

    // 检查是否已经找到了 value
    if (value == cur) {
        if (pos) {
            *pos = mid;
        }
        return 1;
    } else {
        if (pos) {//返回前面的节点
            *pos = min;
        }
        return 0;
    }
}
</code></pre><h1 id="编码升级"><a href="#编码升级" class="headerlink" title="编码升级"></a>编码升级</h1><ol>
<li>此处传入的value都是超过当前编码的值</li>
<li>需要考虑更新编码可能当前value在首部（负值的时候）也可能在尾部</li>
</ol>
<pre><code>static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {

    // 当前的编码方式
    uint8_t curenc = intrev32ifbe(is-&gt;encoding);

    // 新值所需的编码方式
    uint8_t newenc = _intsetValueEncoding(value);

    // 当前集合的元素数量
    int length = intrev32ifbe(is-&gt;length);

    // 根据 value 的值，决定是将它添加到底层数组的最前端还是最后端
    // 注意，因为 value 的编码比集合原有的其他元素的编码都要大
    // 所以 value 要么大于集合中的所有元素，要么小于集合中的所有元素
    // 因此，value 只能添加到底层数组的最前端或最后端
    // 此处需要考虑负数的情况，比如说现在是INTSET_ENC_INT16的编码方式，其范围为：-32768~32767，那么只有当value值大于32767的时候，或者小于-32768的时候才会进行扩容，因此，如果为负数就在最前端，为正数就在最后端
    int prepend = value &lt; 0 ? 1 : 0;

    /* First set new encoding and resize */
    // 更新集合的编码方式
    is-&gt;encoding = intrev32ifbe(newenc);
    // 根据新编码对集合（的底层数组）进行空间调整
    // T = O(N)
    is = intsetResize(is, intrev32ifbe(is-&gt;length) + 1);

    /* Upgrade back-to-front so we don&apos;t overwrite values.
     * Note that the &quot;prepend&quot; variable is used to make sure we have an empty
     * space at either the beginning or the end of the intset. */
    // 根据集合原来的编码方式，从底层数组中取出集合元素
    // 然后再将元素以新编码的方式添加到集合中
    // 当完成了这个步骤之后，集合中所有原有的元素就完成了从旧编码到新编码的转换
    // 因为新分配的空间都放在数组的后端，所以程序先从后端向前端移动元素
    // 举个例子，假设原来有 curenc 编码的三个元素，它们在数组中排列如下：
    // | x | y | z | 
    // 当程序对数组进行重分配之后，数组就被扩容了（符号 ？ 表示未使用的内存）：
    // | x | y | z | ? |   ?   |   ?   |
    // 这时程序从数组后端开始，重新插入元素：
    // | x | y | z | ? |   z   |   ?   |
    // | x | y |   y   |   z   |   ?   |
    // |   x   |   y   |   z   |   ?   |
    // 最后，程序可以将新元素添加到最后 ？ 号标示的位置中：
    // |   x   |   y   |   z   |  new  |
    // 上面演示的是新元素比原来的所有元素都大的情况，也即是 prepend == 0
    // 当新元素比原来的所有元素都小时（prepend == 1），调整的过程如下：
    // | x | y | z | ? |   ?   |   ?   |
    // | x | y | z | ? |   ?   |   z   |
    // | x | y | z | ? |   y   |   z   |
    // | x | y |   x   |   y   |   z   |
    // 当添加新值时，原本的 | x | y | 的数据将被新值代替
    // |  new  |   x   |   y   |   z   |
    // T = O(N)
    while(length--) {//这里是从高位开始一个个向后移动，如果低位开始移动会存在覆盖问题
        _intsetSet(is, length + prepend, _intsetGetEncoded(is, length, curenc));
    }

    /* Set the value at the beginning or the end. */
    // 设置新值，根据 prepend 的值来决定是添加到数组头还是数组尾
    if (prepend) {
        _intsetSet(is, 0, value);
    }
    else {
        _intsetSet(is, intrev32ifbe(is-&gt;length), value);
    }

    // 更新整数集合的元素数量
    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length) + 1);

    return is;
}    
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="intset数据结构"><a href="#intset数据结构" class="headerlink" title="intset数据结构"></a>intset数据结构</h1><pre><code>typedef struct intset {

    /]]>
    </summary>
    
      <category term="Redis" scheme="http://www.cxyteam.com/tags/Redis/"/>
    
      <category term="Redis" scheme="http://www.cxyteam.com/categories/Redis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis长连接与短连接]]></title>
    <link href="http://www.cxyteam.com/2018/02/05/redis%E9%95%BF%E8%BF%9E%E6%8E%A5%E4%B8%8E%E7%9F%AD%E8%BF%9E%E6%8E%A5/"/>
    <id>http://www.cxyteam.com/2018/02/05/redis长连接与短连接/</id>
    <published>2018-02-05T09:07:20.000Z</published>
    <updated>2018-02-05T11:16:19.000Z</updated>
    <content type="html"><![CDATA[<h1 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h1><ol>
<li>定义：在同一个进程下进行多次命令发送，只需要发起一次连接请求</li>
<li>优势：减少连接redis的次数，从而减少命令执行的时间，减少系统开销</li>
<li>劣势：<ol>
<li>如果该连接一直不产生活动，容易出现time_out错误</li>
<li>长期占用一个redis连接</li>
<li>高并发场景请求被串行（redis是单进程模式，例如一个php-fpm进程能处理多个请求，而redis需要一个个进行处理）</li>
</ol>
</li>
</ol>
<h1 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h1><ol>
<li>定义：每次发起命令都需要进行一次连接，命令执行完之后，释放连接</li>
<li><p>优势：及时释放连接，不占用redis连接数</p>
</li>
<li><p>劣势：每个命令执行都需要进行一次连接，延长命令执行时间，连接释放等操作需要占用内存，开销比较大</p>
</li>
</ol>
<h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><ol>
<li>长连接主要用于少数客户端与服务端的频繁通信，因为这时候如果用短连接频繁通信常会发生Socket出错，并且频繁创建Socket连接也是对资源的浪费</li>
<li>太多持久连接，大部分是sleep状态的，或者系统是高并发的，使用短连接更合适</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h1><ol>
<li>定义：在同一个进程下进行多次命令发送，只需要发起一次连接请求</li>
<li>优势：减少连接redis的次数，从而减少]]>
    </summary>
    
      <category term="Redis" scheme="http://www.cxyteam.com/tags/Redis/"/>
    
      <category term="Redis" scheme="http://www.cxyteam.com/categories/Redis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis-hyperloglog源码阅读]]></title>
    <link href="http://www.cxyteam.com/2018/02/03/redis-hyperloglog%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://www.cxyteam.com/2018/02/03/redis-hyperloglog源码阅读/</id>
    <published>2018-02-03T09:43:59.000Z</published>
    <updated>2018-02-03T10:18:00.000Z</updated>
    <content type="html"><![CDATA[<h1 id="hyperloglog结构"><a href="#hyperloglog结构" class="headerlink" title="hyperloglog结构"></a>hyperloglog结构</h1><pre><code>struct hllhdr {
    char magic[4];      // 固定‘HYLL’，用于标识hyperloglog键
    uint8_t encoding;   // 编码模式，有密集标识Dence和稀疏模式sparse
    uint8_t notused[3]; // 未使用字段，留着日后用
    uint8_t card[8];    // 基数缓存，存储上一次计算的基数
    uint8_t registers[]; // 桶个数，用来存放数据，Redis中大小为16384
};
</code></pre><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol>
<li>一般用于做基数统计，比如说，一个网站的独立ip的访问次数</li>
<li>传统的做法可能会存储下访问的ip，然后进行统计，这样的话，随着ip数目的增加，存储的空间越大，统计的延时越长</li>
<li>每个Hyperloglog键只需要12Kb的大小就能计算接近2^64个不同元素的基数，但是hyperloglog只会根据输入元素来计算基数，而不会存储元素本身，所以不能像集合那样返回各个元素本身</li>
</ol>
<h1 id="感觉"><a href="#感觉" class="headerlink" title="感觉"></a>感觉</h1><ol>
<li>直观感觉就是将数据做了hash运算，存储hash后的值（可能还有别的处理），然后进行统计，不存储原始数据</li>
</ol>
<h1 id="果断看不懂，全是算法，放弃"><a href="#果断看不懂，全是算法，放弃" class="headerlink" title="果断看不懂，全是算法，放弃"></a>果断看不懂，全是算法，放弃</h1>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="hyperloglog结构"><a href="#hyperloglog结构" class="headerlink" title="hyperloglog结构"></a>hyperloglog结构</h1><pre><code>struct hllhdr {
  ]]>
    </summary>
    
      <category term="Redis" scheme="http://www.cxyteam.com/tags/Redis/"/>
    
      <category term="Redis" scheme="http://www.cxyteam.com/categories/Redis/"/>
    
  </entry>
  
</feed>