<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[狂奔的菜鸟]]></title>
  <subtitle><![CDATA[当你的实力支撑不起你的野心的时候，静下心来好好学习吧！]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.cxyteam.com/"/>
  <updated>2016-12-01T07:15:57.000Z</updated>
  <id>http://www.cxyteam.com/</id>
  
  <author>
    <name><![CDATA[狂奔的菜鸟]]></name>
    <email><![CDATA[phpchengxuyuan@sina.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[linux配置网络]]></title>
    <link href="http://www.cxyteam.com/2016/12/01/linux%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C/"/>
    <id>http://www.cxyteam.com/2016/12/01/linux配置网络/</id>
    <published>2016-12-01T04:01:52.000Z</published>
    <updated>2016-12-01T07:15:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="设置网络为桥接模式"><a href="#设置网络为桥接模式" class="headerlink" title="设置网络为桥接模式"></a>设置网络为桥接模式</h1><h1 id="配置DNS"><a href="#配置DNS" class="headerlink" title="配置DNS"></a>配置DNS</h1><h4 id="vi-etc-resolv-conf"><a href="#vi-etc-resolv-conf" class="headerlink" title="vi /etc/resolv.conf"></a>vi /etc/resolv.conf</h4><pre><code>nameserver 202.106.0.20
nameserver 8.8.8.8
</code></pre><h1 id="配置网关"><a href="#配置网关" class="headerlink" title="配置网关"></a>配置网关</h1><h4 id="vi-etc-sysconfig-network"><a href="#vi-etc-sysconfig-network" class="headerlink" title="vi /etc/sysconfig/network"></a>vi /etc/sysconfig/network</h4><pre><code>NETWORKING=yes
HOSTNAME=dev
</code></pre><h1 id="配置IP地址"><a href="#配置IP地址" class="headerlink" title="配置IP地址"></a>配置IP地址</h1><h4 id="vi-etc-sysconfig-network-scripts-ifcfg-eth0"><a href="#vi-etc-sysconfig-network-scripts-ifcfg-eth0" class="headerlink" title="vi /etc/sysconfig/network-scripts/ifcfg-eth0"></a>vi /etc/sysconfig/network-scripts/ifcfg-eth0</h4><pre><code>DEVICE=eth0
BOOTPROTO=static
HWADDR=08:00:27:94:F4:CB
IPADDR=192.168.1.11
NETMASK=255.255.255.0
ONBOOT=yes
GATEWAY=192.168.1.1
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="设置网络为桥接模式"><a href="#设置网络为桥接模式" class="headerlink" title="设置网络为桥接模式"></a>设置网络为桥接模式</h1><h1 id="配置DNS"><a href="#配置DNS" class="header]]>
    </summary>
    
      <category term="Linux" scheme="http://www.cxyteam.com/tags/Linux/"/>
    
      <category term="Linux" scheme="http://www.cxyteam.com/categories/Linux/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis源码-目录结构]]></title>
    <link href="http://www.cxyteam.com/2016/11/04/redis%E6%BA%90%E7%A0%81-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>http://www.cxyteam.com/2016/11/04/redis源码-目录结构/</id>
    <published>2016-11-04T01:15:12.000Z</published>
    <updated>2016-11-04T06:59:24.000Z</updated>
    <content type="html"><![CDATA[<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><pre><code>|
|--deps
|
|-- src
   -- adlist.c          双链表结构,用于定义list
   -- ae.c              用于事件的处理
   -- ae_epoll.c        处理epoll事件
   -- ae_evport.c       通过event ports实现处理结构
   -- ae_kqueue.c       实现消息队列的处理
   -- ae_select.c       处理select事件
   -- anet.c            网络处理
   -- aof.c             实现aof模式
   -- asciilogo.h       定义欢迎界面的logo
   -- bio.c             在后台通过线程模式实现io处理
   -- bitops.c          与setbit,getbit相关的位操作
   -- blocked.c         支持类似blpop,wait的阻塞操作
   -- cluster.c         与集群创建,通信相关操作
   -- config.c          配置文件的解析
   -- crc16.c           基于CCITT标准的过滤算法
   -- crc64.c
   -- db.c              c-level数据库api实现
   -- debug.c           调试库和日志输出
   -- dict.c            字典实现
   -- endiancov.c       主机字节序编解码, redis致力于使用little endian来编码
   -- fmacros.h         用于Mac下的兼容性处理
   -- help.h            辅助于命令的提示信息
   -- hyperloglog.c
   -- intset.c          int集合类型实现
   -- lzf_c.c           lzf压缩算法
   -- lzf_d.c
   -- memtest.c         内存测试
   -- muti.c            批量命令操作的原子实现
   -- networking.c      网络通信实现
   -- notify.c
   -- object.c          对象存储类型
   -- pqsort.c          一种快速排序的实现
   -- pubsub.c          用于订阅模式的实现，有点类似于Client广播发送的方式
   -- rand.c            随机序列的生产
   -- rdb.c             rdb数据的load和dump
   -- redis.c           redis数据库的主程序入口
   -- redis-benchmark.c redis基准测试入口
   -- redis-check-aof.c aof文件检查入口
   -- redis-check-dump.c dump文件检查入口
   -- redis-cli.c       redis的shell的客户端
   -- release.c         版本发布信息
   -- replication.c     数据的主从备份
   -- rio.c             流式I/O的读写接口
   -- scripting.c       redis相关协议转换到lua环境下执行
   -- sds.c             强大的字符串处理机制
   -- sentinel.c        redis集群的监护程序
   -- setproctitle.c    程序名信息相关
   -- sha1.c            sha1加密算法
   -- slowlog.c         记录最近一段时间的查询等操作
   -- sort.c            排序算法及辅助函数
   -- syncio.c          同步io的实现
   -- t_hash.c          hash结构
   -- t_list.c          list结构
   -- t_set.c           set结构
   -- t_string.c        string结构
   -- t_zset.c          用两种数据结构存储同一个数据体
   -- util.c            辅助函数
   -- ziplist.c         ziplist结构
   -- zipmap.c          zipmap结构
   -- zmalloc.c         在malloc上进行封装,增加内存开销统计
|
|--tests
|
|--utils
</code></pre><h1 id="源码阅读顺序"><a href="#源码阅读顺序" class="headerlink" title="源码阅读顺序"></a><a href="https://github.com/huangz1990/blog/blob/master/diary/2014/how-to-read-redis-source-code.rst" title="源码阅读顺序" target="_blank" rel="external">源码阅读顺序</a></h1><h3 id="数据结构实现"><a href="#数据结构实现" class="headerlink" title="数据结构实现"></a>数据结构实现</h3><p>sds.h,sds.c                 动态字符串实现<br>adlist.h,adlist.c           双端链表实现<br>dict.h,dict.c               字典的实现</p>
<p>redis.h中的zskiplist结构和zskiplistNode结构,以及t_zset.c中所有以zsl开头的函数,比如zslCreate,zslInsert,zslDeleteNode                 跳跃表实现</p>
<p>hyperloglog.c中的hllhdr结构,以及所有以hll开头的函数。                      HyperLogLog实现</p>
<h3 id="阅读内存编码数据结构实现"><a href="#阅读内存编码数据结构实现" class="headerlink" title="阅读内存编码数据结构实现"></a>阅读内存编码数据结构实现</h3><p>intset.c            整数集合数据结构。<br>ziplist.c           压缩列表数据结构</p>
<h3 id="阅读数据类型实现"><a href="#阅读数据类型实现" class="headerlink" title="阅读数据类型实现"></a>阅读数据类型实现</h3><p>object.c            对象系统实现<br>t_string.c          字符串键的实现<br>t_list.c            列表键的实现<br>t_hash.c            散列键的实现<br>t_set.c             集合键的实现<br>t_zset.c中除zsl开头的函数之外的所有函数           有序集合键的实现<br>hyperloglog.c中所有以pf开头的函数                HyperLogLog 键的实现</p>
<h3 id="阅读数据库实现相关代码"><a href="#阅读数据库实现相关代码" class="headerlink" title="阅读数据库实现相关代码"></a>阅读数据库实现相关代码</h3><p>redis.h文件中的redisDb结构,以及 db.c文件              Redis的数据库实现<br>notify.c                Redis的数据库通知功能实现代码<br>rdb.h和rdb.c             Redis的RDB持久化实现代码<br>aof.c                   Redis 的 AOF 持久化实现代码</p>
<h3 id="选读"><a href="#选读" class="headerlink" title="选读"></a>选读</h3><p>redis.h文件的pubsubPattern结构,以及pubsub.c文件              发布与订阅功能的实现<br>redis.h文件的multiState结构以及multiCmd结构,multi.c文件       事务功能的实现<br>sort.c                      SORT命令的实现<br>bitops.c                    GETBIT,SETBIT等二进制位操作命令的实现</p>
<h3 id="阅读客户端和服务器的相关代码"><a href="#阅读客户端和服务器的相关代码" class="headerlink" title="阅读客户端和服务器的相关代码"></a>阅读客户端和服务器的相关代码</h3><p>ae.c,以及任意一个 ae_*.c文件（取决于你所使用的多路复用库）         Redis 的事件处理器实现<br>networking.c                Redis 的网络连接库，负责发送命令回复和接受命令请求， 同时也负责创建/销毁客户端， 以及通信协议分析等工作<br>redis.h和redis.c中和单机Redis服务器有关的部分            单机 Redis 服务器的实现</p>
<h3 id="选读-1"><a href="#选读-1" class="headerlink" title="选读"></a>选读</h3><p>scripting.c                 Lua 脚本功能的实现<br>slowlog.c                   慢查询功能的实现<br>monitor.c                   监视器功能的实现</p>
<h3 id="阅读多机功能的实现"><a href="#阅读多机功能的实现" class="headerlink" title="阅读多机功能的实现"></a>阅读多机功能的实现</h3><p>replication.c               复制功能的实现代码<br>sentinel.c                  Redis Sentinel 的实现代码<br>cluster.c                   Redis 集群的实现代码</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><pre><code>|
|--deps
|
|-- src
   -- adlist.c          双链表结构,用于定义]]>
    </summary>
    
      <category term="Redis" scheme="http://www.cxyteam.com/tags/Redis/"/>
    
      <category term="Redis" scheme="http://www.cxyteam.com/categories/Redis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gdb调试redis]]></title>
    <link href="http://www.cxyteam.com/2016/11/02/gdb%E8%B0%83%E8%AF%95redis/"/>
    <id>http://www.cxyteam.com/2016/11/02/gdb调试redis/</id>
    <published>2016-11-02T02:46:04.000Z</published>
    <updated>2016-11-02T03:02:53.000Z</updated>
    <content type="html"><![CDATA[<p>#<br>启动redis redis-server<br>连接redis redis-cli<br>获取进程id redis-cli info | grep process_id<br>gdb调试进程id sudo gdb -p pid<br>gdb查询代码 list<br>gdb 设置断点 break main</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>#<br>启动redis redis-server<br>连接redis redis-cli<br>获取进程id redis-cli info | grep process_id<br>gdb调试进程id sudo gdb -p pid<br>gdb查询代码 list<br]]>
    </summary>
    
      <category term="Redis" scheme="http://www.cxyteam.com/tags/Redis/"/>
    
      <category term="Redis" scheme="http://www.cxyteam.com/categories/Redis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[gdb调试]]></title>
    <link href="http://www.cxyteam.com/2016/10/26/gdb%E8%B0%83%E8%AF%95/"/>
    <id>http://www.cxyteam.com/2016/10/26/gdb调试/</id>
    <published>2016-10-25T23:44:26.000Z</published>
    <updated>2016-11-01T06:27:23.000Z</updated>
    <content type="html"><![CDATA[<h1 id="调试文件内容gdb-c"><a href="#调试文件内容gdb-c" class="headerlink" title="调试文件内容gdb.c"></a>调试文件内容gdb.c</h1><pre><code>#include &lt;stdio.h&gt;

int add_range(int low, int high)
{
        int i, sum;
        for (i = low; i &lt;= high; i++)
                sum = sum + i;
        return sum;
}

int main(void)
{
        int result[100];
        result[0] = add_range(1, 10);
        result[1] = add_range(1, 100);
        printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);
        return 0;
}
</code></pre><h1 id="编译文件"><a href="#编译文件" class="headerlink" title="编译文件"></a>编译文件</h1><pre><code>gcc -g gdb.c -o gdbtest
</code></pre><h1 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h1><pre><code>./gdbtest
</code></pre><p><img src="/img/gdb_test/result.png" alt="Alt text" title="运行结果"><br>很明显运行的结果是不对的:1加到10的结果是55,但是1加到100的,结果应该是5050才对,而不是5105,下面用两种gdb方式进行调试</p>
<h1 id="启动gdb"><a href="#启动gdb" class="headerlink" title="启动gdb"></a>启动gdb</h1><pre><code>sudo gdb gdbtest
</code></pre><p><img src="/img/gdb_test/gdb.png" alt="Alt text" title="启动gdb"></p>
<h1 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h1><pre><code>l
</code></pre><p>l以后直接进行回车能够查看到后续的内容<br><img src="/img/gdb_test/list.png" alt="Alt text" title="启动gdb"></p>
<h1 id="断点调试法"><a href="#断点调试法" class="headerlink" title="断点调试法"></a>断点调试法</h1><h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><pre><code>break 16                #设置16行为断点
break add_range         #设置add_range函数为断点
info break              #查看断点信息
break在你认为关键的,需要输出的位置进行设置
</code></pre><p><img src="/img/gdb_test/break.png" alt="Alt text" title="启动gdb"></p>
<h3 id="开启调试"><a href="#开启调试" class="headerlink" title="开启调试"></a>开启调试</h3><pre><code>start               #运行程序
n                   #单条语句执行，进入下一条
print i             #达因变量i的值
print sum
c                   #可以想象成continue的功能
当执行完c之后不知道代码执行到那个位置了,可以使用bt进行查看
</code></pre><p><img src="/img/gdb_test/start_break.png" alt="Alt text" title="断点输出"></p>
<h3 id="bt查看函数的堆栈"><a href="#bt查看函数的堆栈" class="headerlink" title="bt查看函数的堆栈"></a>bt查看函数的堆栈</h3><pre><code>如下图,表示在gdb.c的文件的第15行的main函数中调用了gdb.c文件中第六航的add_range函数,参数为low=1,high=100
    #0  add_range (low=1, high=100) at gdb.c:6
    #1  0x0000000100000f07 in main () at gdb.c:15
</code></pre><p><img src="/img/gdb_test/bt.png" alt="Alt text" title="查看函数堆栈"></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><pre><code>当我们在调试的时候,可以看出i和sum没有被初始化,而在循环中i进行了初始化,所以问题不大,sum执行完第一次调用后的值是55,所以最终运行完1到10相加,再运行1到100相加的最终结果是5105
</code></pre><h1 id="顺序调试"><a href="#顺序调试" class="headerlink" title="顺序调试"></a>顺序调试</h1><h3 id="查看mian函数-不能发现问题处在哪"><a href="#查看mian函数-不能发现问题处在哪" class="headerlink" title="查看mian函数,不能发现问题处在哪"></a>查看mian函数,不能发现问题处在哪</h3><pre><code>首先我们看到gdb停在第14行的位置,执行了add_range的函数调用,正等待我们执行命令
14        result[0] = add_range(1, 10);
接着我们执行了n,gdb执行下一条命令,
15        result[1] = add_range(1, 100);
最后知道输出结果
</code></pre><p><img src="/img/gdb_test/step_start.png" alt="Alt text" title="调试main函数"></p>
<h3 id="进入子函数add-range中-查看具体的执行步骤"><a href="#进入子函数add-range中-查看具体的执行步骤" class="headerlink" title="进入子函数add_range中,查看具体的执行步骤"></a>进入子函数add_range中,查看具体的执行步骤</h3><pre><code>调试子函数的第一次调用,gdb停留在add_range(1,10)这行代码的位置,直接使用s进入子函数
Temporary breakpoint 3, main () at gdb.c:14
14        result[0] = add_range(1, 10);
(gdb) s
add_range (low=1, high=10) at gdb.c:6
6        for (i = low; i &lt;= high; i++)

接着直接回车进入下一步,在使用info locals进行当前栈帧局部变量的值,也就是add_range函数中i和sum的值
在使用f 1进入1号栈帧也就是main函数中,查看main栈帧局部变量的值(info locals)
本次调用(add_range(1,10))没有错误,直接使用finish运行完当前函数,并让gdb回到main函数中,等待命令发出
</code></pre><p><img src="/img/gdb_test/subfunc_start.png" alt="Alt text" title="调试子函数"></p>
<pre><code>让gdb进入下一条命令(n),
(gdb) n
    15        result[1] = add_range(1, 100);

再进入子函数(add_range(1,100))中,并查看当前栈帧局部变量的值
(gdb) s
    add_range (low=1, high=100) at gdb.c:6
    6        for (i = low; i &lt;= high; i++)

发现当前的i和sum没有进行初始化,还是上次函数add_range(1,10)执行完后的结果
(gdb) info locals
i = 11
sum = 55

使用bt查看函数的调用栈(当前调用add_range的蚕食是low=1,high=100),
(gdb) bt
    #0  add_range (low=1, high=100) at gdb.c:6
    #1  0x0000000100000f07 in main () at gdb.c:15

并进入下一步,设置i和sum的初始值(set var i=0),
(gdb) set var i=0
    (gdb) set var sum=0
    (gdb) s
    7            sum = sum + i;

接着确认当前i和sum的值(p i),
(gdb) p i
    $2 = 1
    (gdb) p sum
    $3 = 0

在用finish连续运行完当前函数,结果返回的值为5050
(gdb) finish
    Run till exit from #0  add_range (low=1, high=100) at gdb.c:7
    0x0000000100000f07 in main () at gdb.c:15
    15        result[1] = add_range(1, 100);
    Value returned is $4 = 5050

也就是说,函数返回了正确的结果,错误原因是在第一次add_range的调用之后,没有对i和sum进行初始化
</code></pre><p><img src="/img/gdb_test/subfunc_end.png" alt="Alt text" title="调试子函数"></p>
<h1 id="命令总结"><a href="#命令总结" class="headerlink" title="命令总结"></a>命令总结</h1><pre><code>命令                           描述
backtrace（或bt）              查看各级函数调用及参数
finish                        连续运行到当前函数返回为止，然后停下来等待命令
frame（或f）                   帧编号    选择栈帧
info（或i）locals              查看当前栈帧局部变量的值
list（或l）                      列出源代码，接着上次的位置往下列，每次列10行
list 行号                      列出从第几行开始的源代码
list 函数名                      列出某个函数的源代码
next（或n）                      执行下一行语句
print（或p）                      打印表达式的值，通过表达式可以修改变量的值或者调用函数
quit（或q）                      退出gdb调试环境
set var                          修改变量的值
start                          开始执行程序，停在main函数第一行语句前面等待命令
step（或s）                      执行下一行语句，如果有函数调用则进入到函数中
next(或n)                     执行下一条语句
break 行号                     在源码的行数设置断点
break 函数名                   在函数的入口处,设置断点
info break                    查看断点信息
continue(或c)                 继续运行程序
print(或p) 变量名名            打印变量的值
frame(或f)                    选择栈帧
set var                       修改变量的值


==========
其他事例中没用到的命令
call 函数                     调用函数
print 函数                    调用函数
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="调试文件内容gdb-c"><a href="#调试文件内容gdb-c" class="headerlink" title="调试文件内容gdb.c"></a>调试文件内容gdb.c</h1><pre><code>#include &lt;stdio.h&gt;

]]>
    </summary>
    
      <category term="C" scheme="http://www.cxyteam.com/tags/C/"/>
    
      <category term="C" scheme="http://www.cxyteam.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[mac安装gdb]]></title>
    <link href="http://www.cxyteam.com/2016/10/21/mac%E5%AE%89%E8%A3%85gdb/"/>
    <id>http://www.cxyteam.com/2016/10/21/mac安装gdb/</id>
    <published>2016-10-21T09:32:25.000Z</published>
    <updated>2016-10-25T00:33:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Mac安装GDB"><a href="#Mac安装GDB" class="headerlink" title="Mac安装GDB"></a>Mac安装GDB</h1><h3 id="安装GDB"><a href="#安装GDB" class="headerlink" title="安装GDB"></a>安装GDB</h3><pre><code>brew install gdb
</code></pre><h1 id="使用gdb进行调试"><a href="#使用gdb进行调试" class="headerlink" title="使用gdb进行调试"></a>使用gdb进行调试</h1><h3 id="gbd-c文件中的内容"><a href="#gbd-c文件中的内容" class="headerlink" title="gbd.c文件中的内容"></a>gbd.c文件中的内容</h3><pre><code>#include &lt;stdio.h&gt;

int add_range(int low, int high)
{
        int i, sum;
        for (i = low; i &lt;= high; i++)
                sum = sum + i;
        return sum;
}

int main(void)
{
        int result[100];
        result[0] = add_range(1, 10);
        result[1] = add_range(1, 100);
        printf(&quot;result[0]=%d\nresult[1]=%d\n&quot;, result[0], result[1]);
        return 0;
}
</code></pre><h3 id="编译并使用gdb"><a href="#编译并使用gdb" class="headerlink" title="编译并使用gdb"></a>编译并使用gdb</h3><pre><code>gcc -g gdb.c -o gdbtest &amp;&amp; gdb gdbtest
</code></pre><h3 id="gdb开始调试"><a href="#gdb开始调试" class="headerlink" title="gdb开始调试"></a>gdb开始调试</h3><pre><code>start
</code></pre><h3 id="mac下出现如下错误"><a href="#mac下出现如下错误" class="headerlink" title="mac下出现如下错误"></a>mac下出现如下错误</h3><p><img src="/img/mac_gdb/gdb-error.png" alt="Alt text" title="gdb错误信息"></p>
<h3 id="mac下对gdb进行签名"><a href="#mac下对gdb进行签名" class="headerlink" title="mac下对gdb进行签名"></a>mac下对gdb进行签名</h3><p><img src="/img/mac_gdb/key.png" alt="Alt text" title="启动key"></p>
<p><img src="/img/mac_gdb/create-key.png" alt="Alt text" title="创建证书"></p>
<p><img src="/img/mac_gdb/gdb-cert-first.png" alt="Alt text" title="选择代码签名"></p>
<p><img src="/img/mac_gdb/gdb-cert-second.png" alt="Alt text" title="设置过期时间"></p>
<h3 id="接下来所有步骤都选择默认选项-直到选择证书存储的时候选择系统"><a href="#接下来所有步骤都选择默认选项-直到选择证书存储的时候选择系统" class="headerlink" title="接下来所有步骤都选择默认选项,直到选择证书存储的时候选择系统"></a>接下来所有步骤都选择默认选项,直到选择证书存储的时候选择系统</h3><p><img src="/img/mac_gdb/gdb-cert-third.png" alt="Alt text" title="选择存储位置"></p>
<h3 id="创建的证书"><a href="#创建的证书" class="headerlink" title="创建的证书"></a>创建的证书</h3><p><img src="/img/mac_gdb/gdb-cert-last.png" alt="Alt text" title="证书"></p>
<h3 id="设置信任"><a href="#设置信任" class="headerlink" title="设置信任"></a>设置信任</h3><p><img src="/img/mac_gdb/gdb-auth-1.png" alt="Alt text" title="找到证书简介"><br><img src="/img/mac_gdb/gdb-auth-2.png" alt="Alt text" title="设置代码签名始终信任"></p>
<h1 id="对gdb进行代码签名"><a href="#对gdb进行代码签名" class="headerlink" title="对gdb进行代码签名"></a>对gdb进行代码签名</h1><h3 id="关闭taskgated进程"><a href="#关闭taskgated进程" class="headerlink" title="关闭taskgated进程"></a>关闭taskgated进程</h3><p><img src="/img/mac_gdb/gdb-cert-sign-1.png" alt="Alt text" title="打开活动检测器"><br><img src="/img/mac_gdb/taskgated.png" alt="Alt text" title="检索taskgated进程并退出"></p>
<h3 id="对gdb进行签名"><a href="#对gdb进行签名" class="headerlink" title="对gdb进行签名"></a>对gdb进行签名</h3><pre><code>codesign -s gdb-cert /usr/local/bin/gdb
</code></pre><h3 id="检测是否安装成功"><a href="#检测是否安装成功" class="headerlink" title="检测是否安装成功"></a>检测是否安装成功</h3><pre><code>codesign -v gdb (`如果没有任何信息输出代表签名成功`)
</code></pre><h3 id="再次使用gdb进行调试"><a href="#再次使用gdb进行调试" class="headerlink" title="再次使用gdb进行调试"></a>再次使用gdb进行调试</h3><pre><code>gcc -g gdb.c -o gdbtest &amp;&amp; sudo gdb gdbtest (`注意sudo不能少,这个坑我趟了好几个小时,最终在google找到答案`)
start
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Mac安装GDB"><a href="#Mac安装GDB" class="headerlink" title="Mac安装GDB"></a>Mac安装GDB</h1><h3 id="安装GDB"><a href="#安装GDB" class="headerlink]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis源码阅读-准备工作]]></title>
    <link href="http://www.cxyteam.com/2016/10/21/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/"/>
    <id>http://www.cxyteam.com/2016/10/21/redis源码阅读-准备工作/</id>
    <published>2016-10-21T09:29:44.000Z</published>
    <updated>2016-11-04T02:33:01.000Z</updated>
    <content type="html"><![CDATA[<h1 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h1><h1 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h1>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h1><h1 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h]]>
    </summary>
    
      <category term="Redis" scheme="http://www.cxyteam.com/tags/Redis/"/>
    
      <category term="Redis" scheme="http://www.cxyteam.com/categories/Redis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Primary script unknown排查]]></title>
    <link href="http://www.cxyteam.com/2016/10/21/Primary-script-unknown%E6%8E%92%E6%9F%A5/"/>
    <id>http://www.cxyteam.com/2016/10/21/Primary-script-unknown排查/</id>
    <published>2016-10-21T04:21:14.000Z</published>
    <updated>2016-10-21T09:27:14.000Z</updated>
    <content type="html"><![CDATA[<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>#<br>    tcpdump  -i  lo -Anns0 port 9000</p>
<p>#<br>    ps aux|grep fpm|grep -v grep |awk ‘{printf “ -p “ $2}’<br>    strace</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h1><p>#<br>    tcpdump  -i  lo -Anns0 port 9000</p>
<p>#<br>    ps aux|grep ]]>
    </summary>
    
      <category term="PHP" scheme="http://www.cxyteam.com/tags/PHP/"/>
    
      <category term="PHP" scheme="http://www.cxyteam.com/categories/PHP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言进程间通信]]></title>
    <link href="http://www.cxyteam.com/2016/10/16/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>http://www.cxyteam.com/2016/10/16/C语言进程间通信/</id>
    <published>2016-10-16T08:02:11.000Z</published>
    <updated>2016-10-18T02:14:12.000Z</updated>
    <content type="html"><![CDATA[<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><pre><code>标准输入:stdin          对应描述符:0
标准输出:stdout         对应描述符:1
标准错误:stderr         对应描述符:2
</code></pre><h1 id="重定向数据流"><a href="#重定向数据流" class="headerlink" title="重定向数据流"></a>重定向数据流</h1><pre><code>重定向输出数据流 &quot;&gt;&quot;,&quot;&gt;&gt;&quot;
重定向输入数据流 &quot;&lt;&quot;,&quot;&lt;&lt;&quot;
</code></pre><h1 id="fileni返回描述符号"><a href="#fileni返回描述符号" class="headerlink" title="fileni返回描述符号"></a>fileni返回描述符号</h1><h1 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h1>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h1><pre><code>标准输入:stdin          对应描述符:0
标准输出:stdout         对应描述符:1
标准]]>
    </summary>
    
      <category term="C" scheme="http://www.cxyteam.com/tags/C/"/>
    
      <category term="C" scheme="http://www.cxyteam.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言进程与系统调用]]></title>
    <link href="http://www.cxyteam.com/2016/10/14/C%E8%AF%AD%E8%A8%80%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://www.cxyteam.com/2016/10/14/C语言进程与系统调用/</id>
    <published>2016-10-14T02:34:53.000Z</published>
    <updated>2016-10-16T07:57:42.000Z</updated>
    <content type="html"><![CDATA[<h1 id="execl-execlp-execle"><a href="#execl-execlp-execle" class="headerlink" title="execl,execlp,execle"></a>execl,execlp,execle</h1><pre><code>第一个参数是exec系列函数告诉将要运行什么程序(区别就是execlp可以就是命令的名字,而execl和execle需要完整路径名)
第一个命令行的参数必须是程序名,因此第二个参数和第一个参数是一致的
中间都被当做脚本所需要的参数
最后一个参数是NULL,告诉函数没有其他参数了
如果是以e结尾的exec系列函数(例如execle),还可以传递环境变量数组

例子:
execl(&apos;/tmp/test&apos;, &apos;/tmp/test&apos;, &apos;param1&apos;, &apos;param2&apos;, &apos;param3&apos;, NULL);
execlp(&apos;test&apos;, &apos;test&apos;, &apos;param1&apos;, &apos;param2&apos;, &apos;param3&apos;, NULL);
execle(&apos;/tmp/test&apos;, &apos;/tmp/test&apos;, &apos;param1&apos;, &apos;param2&apos;, &apos;param3&apos;, NULL, env_vars);
</code></pre><h1 id="execv-execvp-execve"><a href="#execv-execvp-execve" class="headerlink" title="execv,execvp,execve"></a>execv,execvp,execve</h1><pre><code>参数类型,只是把后面的参数传递给了数组

例子:
execv(&apos;/tmp/test&apos;, my_args);
execvp(&apos;test&apos;, my_args);
</code></pre><h1 id="错误信息的一些规定"><a href="#错误信息的一些规定" class="headerlink" title="错误信息的一些规定"></a>错误信息的一些规定</h1><pre><code>不允许操作               1
没有该文件或目录          2
没有改进程               3
错误                    -1
正常返回                 0
</code></pre><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><pre><code>#include &lt;stdio.h&gt;
/*
    为了使用exec函数
*/
#include &lt;unistd.h&gt;
/*
    为了使用errno变量
*/
#include &lt;errno.h&gt;
#include &lt;string.h&gt;

int main()
{
    if (execl(&quot;/sbin/ifconfig&quot;, &quot;/sbin/ifconfig&quot;, NULL) == -1)
    {
        if (execlp(&quot;ipconfig&quot;, &quot;ipconfig&quot;, NULL) == -1)
        {
            fprintf(stderr, &quot;Cannot run ipconfig: %s&quot;, strerror(errno));

            return 1;
        }
    }

    return 0;
}
</code></pre><h1 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h1><pre><code>fork会向子进程返回0,父进程返回非0值
</code></pre><h1 id="copy-on-write"><a href="#copy-on-write" class="headerlink" title="copy-on-write"></a>copy-on-write</h1><pre><code>为了让fork进程变快,操作系统做了很多技巧,比如操作系统不会真的复制父进程的数据,而是让父子进程共享数据,当子进程需要修改存储器,就会为他复制一份数据
</code></pre><h1 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h1><pre><code>exec系列函数执行的时候会启动一个进程,后面的代码不会运行
伪代码:
    code1
    exec系列函数
    code2
    此例中的code2代码不会再运行

如果需要运行获取多个exec系列函数的结果需要使用fork进行
伪代码:
    code1
    pid_t pid_t = fork();
    exec系列函数
    pid_t pid_t = fork();
    exec系列函数
</code></pre><h1 id="事例-此事例中需要安装python环境-下载rss-gossip脚本https-github-com-dogriffiths-rssgossip-zipball-master"><a href="#事例-此事例中需要安装python环境-下载rss-gossip脚本https-github-com-dogriffiths-rssgossip-zipball-master" class="headerlink" title="事例(此事例中需要安装python环境,下载rss gossip脚本https://github.com/dogriffiths/rssgossip/zipball/master)"></a>事例(此事例中需要安装python环境,下载rss gossip脚本<a href="https://github.com/dogriffiths/rssgossip/zipball/master" target="_blank" rel="external">https://github.com/dogriffiths/rssgossip/zipball/master</a>)</h1><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;

 int main(int argc, char *argv[])
 {
    char *feeds[] = {&quot;http://wwww.cnn.com/rss/celebs.xml&quot;,
                    &quot;http://www.rollingstone/rock.xml&quot;,
                    &quot;http://eonline.com/gossip.xml&quot;
                    };
    int times = 3;
    char *phrase = argv[1];
    int i;
    for(i = 0; i&lt; times; i++) {
        char var[255];
        sprintf(var, &quot;RSS_FEED=%s&quot;, feeds[i]);
        char *vars[] = {var, NULL};
        /*
            pid_t是可以理解成一种int的类型
        */
        pid_t pid_t = fork();
        if (pid_t == -1) {
            fprintf(stderr, &quot;can&apos;t fork process:%s\n&quot;, strerror(errno));
            return 1;
        }

        if (!pid_t &amp;&amp; execle(&quot;/usr/bin/python&quot;, &quot;/usr/bin/python&quot;, &quot;./rssgossip.py&quot;, phrase, NULL, vars) == -1) {
            fprintf(stderr, &quot;can&apos;t run script:%s\n&quot;, strerror(errno));
            return 1;
        }
    }

    return 0;
 }
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="execl-execlp-execle"><a href="#execl-execlp-execle" class="headerlink" title="execl,execlp,execle"></a>execl,execlp,execle</h1><pre>]]>
    </summary>
    
      <category term="C" scheme="http://www.cxyteam.com/tags/C/"/>
    
      <category term="C" scheme="http://www.cxyteam.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言静态库和动态库]]></title>
    <link href="http://www.cxyteam.com/2016/09/11/C%E8%AF%AD%E8%A8%80%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    <id>http://www.cxyteam.com/2016/09/11/C语言静态库和动态库/</id>
    <published>2016-09-11T08:51:13.000Z</published>
    <updated>2016-09-13T10:10:26.000Z</updated>
    <content type="html"><![CDATA[<h1 id="实现文件共享"><a href="#实现文件共享" class="headerlink" title="实现文件共享"></a>实现文件共享</h1><pre><code>例子:
目录结构如下:
|--myHeader
  --checksum.h
  --encrypt.h
|--checksum.c
|--encrypt.c
|--test.c
|--myObject

在myHeader文件中建立头文件checksum.h
int checksum(char *message);
在myHeader文件中建立头文件encrypt.h
void encrypt(char *message);

checksum.c内容:
#include &lt;checksum.h&gt;

int checksum(char *message)
{
 int c = 0;
 while (*message) {
     c += c ^ (int)(*message);
     message++;
 }

 return c;
}

encrypt.c内容:
#include &quot;./myHeader/encrypt.h&quot;

void encrypt(char *message)
{
 char c;
 while(*message) {
     *message = *message ^ 31;
     message++;
 }
}

test.c的内容:
#include &lt;stdio.h&gt;
#include &quot;./myHeader/encrypt.h&quot;
#include &quot;./myHeader/checksum.h&quot;

int main()
{
     char s[] = &quot;Speak friend and enter&quot;;
     encrypt(s);
     printf(&quot;Encrypt to &apos;%s&apos;\n&quot;, s);
     printf(&quot;checksum is %i\n&quot;, checksum(s));
     encrypt(s);
     printf(&quot;Decrypt to &apos;%s&apos;\n&quot;, s);
     printf(&quot;checksum is %i\n&quot;, checksum(s));
     return 0;
}

/*
    把头文件和编译后的文件都保存在固定的文件中方便共享(myHeader和myObject)
    -I告诉编译器去哪里找头文件
*/
执行命令:(执行命令每次都要指定.o的文件路径,是不是太麻烦?)
    gcc -I ./myHeader -c checksum.c -o ./myObject/checksum.o
    gcc -I ./myHeader -c encrypt.c -o ./myObject/encrypt.o
    gcc -I ./myHeader test.c ./myObject/checksum.o ./myObject/encrypt.o -o test &amp;&amp; ./test
</code></pre><h1 id="创建静态库的方式"><a href="#创建静态库的方式" class="headerlink" title="创建静态库的方式"></a>创建静态库的方式</h1><pre><code>/*
    r:如果.a文件存在就更新它
    c:表示创建存档时不显示反馈信息
    s:告诉ar要在.a文件开头建立索引
    创建的文件名:libhfsecurity.a
    ** 静态库名字的命名规范一般是:libxxx.a的形式,不然编译器无法找到它
*/
ar -rcs libhfsecurity.a encrypt.o checksum.o

/*
    可以查看.a文件是由那些文件组成
*/
ar -t libhfsecurity.a

/*
    lhfsecurity对应去寻找上面创建的静态库的名字:libhfsecurity.a
    -I指定头文件位置
    -L告诉编译器去哪寻找存档
    当然如果你把.a的文件放在/usr/local/lib(用来存放本地自定义库或者系统类库/usr/lib)中,可以不指定-L参数
    gcc test.c  -lhfsecurity -o test
*/
gcc -I ./myHeader test.c -L myObject -lhfsecurity -o test &amp;&amp; ./test
</code></pre><h1 id="静态库例子"><a href="#静态库例子" class="headerlink" title="静态库例子"></a>静态库例子</h1><pre><code>目录结构:
|--myHeader
  --hfcal.h
|--myObject
|--treadmill
  --elliptical.c
  --hfcal.c

hfcal.h中的内容:
    void display_calories(float weight, float distance, float coeff);

hfcal.c文件中的内容:
    #include &lt;stdio.h&gt;
    #include &lt;hfcal.h&gt;

    void display_calories(float weight, float distance, float coeff)
    {
        printf(&quot;Weight:%3.2f lbs\n&quot;, weight);
        printf(&quot;Distance:%3.2f miles\n&quot;, distance);
        printf(&quot;Calories burned:%4.2f cal\n&quot;, coeff * weight * distance);
    }

elliptical.c文件中的内容:
    #include &lt;stdio.h&gt;
    #include &lt;hfcal.h&gt;

    int main()
    {
        display_calories(115.2, 11.3, 0.79);
        return 0;
    }

cd treadmill
gcc -I ../myHeader -c hfcal.c -o ../myObject/hfcal.o
gcc -I ../myHeader -c elliptical.c -o ../myObject/elliptical.o
ar -rcs ../myObject/libhfcal.a ../myObject/hfcal.o
cd ../myObject
gcc elliptical.o -L ./ -lhfcal -o elliptical
</code></pre><h1 id="创建动态库"><a href="#创建动态库" class="headerlink" title="创建动态库"></a>创建动态库</h1><pre><code>/*
    -I指定头文件目录,-c不要链接代码,-fPIC创建位置无关代码创建库
*/
gcc -I ../myHeader -fPIC -c hfcal.c -o ../myObject/hfcal.o

/*
    --shared告诉gcc把目标文件转化为动态库
    动态库在每个系统的后缀名都不一样
    windows中后缀名是.dll
    在linux和unix尚后缀名是.so
   在mac上后缀名是是.dylib
*/
cd ../myObject/


/*
    在一些稍微老一点的mac系统上,没有-shared选项,可以使用-dynamiclib代替
*/
                        libhfcal.dll.a      #windows上的cygwin
                        libhfcal.dylib         #mac
gcc -shared hfcal.o -o  hfcal.dll           #windows上的mingw
                        libhfcal.so         #linux或unix

cd ../treadmill/
gcc -I ../myHeader -c elliptical.c -o ../myObject/elliptical.o
cd ../myObject/

/*
    在linux和大部分unix中,编译器只会记录libhfcal.so库的文件名,而不会包含路径名,也就是说如果不把hfcal库保存到标准目录(/usr/lib),程序就找不到它
    一般解决方法是:把库目录添加到LD_LIBRARY_PATH中,并export它
    export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:./
*/
gcc elliptical.o -L ./ -lhfcal -o elliptical
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="实现文件共享"><a href="#实现文件共享" class="headerlink" title="实现文件共享"></a>实现文件共享</h1><pre><code>例子:
目录结构如下:
|--myHeader
  --checksum.h
  --enc]]>
    </summary>
    
      <category term="C" scheme="http://www.cxyteam.com/tags/C/"/>
    
      <category term="C" scheme="http://www.cxyteam.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[代码设计]]></title>
    <link href="http://www.cxyteam.com/2016/09/09/%E4%BB%A3%E7%A0%81%E8%AE%BE%E8%AE%A1/"/>
    <id>http://www.cxyteam.com/2016/09/09/代码设计/</id>
    <published>2016-09-09T09:29:39.000Z</published>
    <updated>2016-09-11T08:07:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="暂未找到合适的表述方法"><a href="#暂未找到合适的表述方法" class="headerlink" title="暂未找到合适的表述方法"></a>暂未找到合适的表述方法</h1>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="暂未找到合适的表述方法"><a href="#暂未找到合适的表述方法" class="headerlink" title="暂未找到合适的表述方法"></a>暂未找到合适的表述方法</h1>]]>
    </summary>
    
      <category term="Other" scheme="http://www.cxyteam.com/tags/Other/"/>
    
      <category term="Other" scheme="http://www.cxyteam.com/categories/Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[git的使用]]></title>
    <link href="http://www.cxyteam.com/2016/09/02/git%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.cxyteam.com/2016/09/02/git的使用/</id>
    <published>2016-09-02T04:17:48.000Z</published>
    <updated>2016-09-07T11:21:40.000Z</updated>
    <content type="html"><![CDATA[<h1 id="初始化一个git项目"><a href="#初始化一个git项目" class="headerlink" title="初始化一个git项目"></a>初始化一个git项目</h1><pre><code>git init
</code></pre><h1 id="添加文件"><a href="#添加文件" class="headerlink" title="添加文件"></a>添加文件</h1><pre><code>git add filename
</code></pre><h1 id="添加目录"><a href="#添加目录" class="headerlink" title="添加目录"></a>添加目录</h1><pre><code>git add .
</code></pre><h1 id="只提交已提交过得文件-不添加新增文件-只添加修改的文件"><a href="#只提交已提交过得文件-不添加新增文件-只添加修改的文件" class="headerlink" title="只提交已提交过得文件(不添加新增文件,只添加修改的文件)"></a>只提交已提交过得文件(不添加新增文件,只添加修改的文件)</h1><pre><code>git add -u
</code></pre><h1 id="查看当前工作区文件提交的状态"><a href="#查看当前工作区文件提交的状态" class="headerlink" title="查看当前工作区文件提交的状态"></a>查看当前工作区文件提交的状态</h1><pre><code>git status
git status -s 查看简便信息
</code></pre><h1 id="提交文件到本地"><a href="#提交文件到本地" class="headerlink" title="提交文件到本地"></a>提交文件到本地</h1><pre><code>git commit filename -m &apos;注释&apos;
</code></pre><h1 id="删除本地git提交"><a href="#删除本地git提交" class="headerlink" title="删除本地git提交"></a>删除本地git提交</h1><pre><code>git rm --cached .
</code></pre><h1 id="将文件推送到远程服务器"><a href="#将文件推送到远程服务器" class="headerlink" title="将文件推送到远程服务器"></a>将文件推送到远程服务器</h1><pre><code>git push
</code></pre><h1 id="将文件从远程拉取回来"><a href="#将文件从远程拉取回来" class="headerlink" title="将文件从远程拉取回来"></a>将文件从远程拉取回来</h1><pre><code>git pull
</code></pre><h1 id="添加忽略文件"><a href="#添加忽略文件" class="headerlink" title="添加忽略文件"></a>添加忽略文件</h1><pre><code>添加.gitignore到git项目目录
编辑.gitignore,添加.idea/(此处idea为需要提交时候忽略的文件)
</code></pre><h1 id="下载远程项目"><a href="#下载远程项目" class="headerlink" title="下载远程项目"></a>下载远程项目</h1><pre><code>git clone git_path
</code></pre><h1 id="创建裸版本库"><a href="#创建裸版本库" class="headerlink" title="创建裸版本库"></a>创建裸版本库</h1><pre><code>git clone --bare project_name path
</code></pre><h1 id="查看文件提交记录"><a href="#查看文件提交记录" class="headerlink" title="查看文件提交记录"></a>查看文件提交记录</h1><pre><code>git log filename
</code></pre><h1 id="查看修改文件差异-只能比较工作区和暂存区信息"><a href="#查看修改文件差异-只能比较工作区和暂存区信息" class="headerlink" title="查看修改文件差异(只能比较工作区和暂存区信息)"></a>查看修改文件差异(只能比较工作区和暂存区信息)</h1><pre><code>git diff file_name
git diff HEAD
</code></pre><h1 id="查看提交详细记录"><a href="#查看提交详细记录" class="headerlink" title="查看提交详细记录"></a>查看提交详细记录</h1><pre><code>git show file_name
</code></pre><h1 id="使用git移动修改文件-修改完之后-文件的日志记录都没了"><a href="#使用git移动修改文件-修改完之后-文件的日志记录都没了" class="headerlink" title="使用git移动修改文件(修改完之后,文件的日志记录都没了)"></a>使用git移动修改文件(修改完之后,文件的日志记录都没了)</h1><pre><code>git mv old_file_name new_file_name
</code></pre><h1 id="从git中删除"><a href="#从git中删除" class="headerlink" title="从git中删除"></a>从git中删除</h1><pre><code>git rm file_name
</code></pre><h1 id="删除非git管理文件-也就是没有add到git管理中的"><a href="#删除非git管理文件-也就是没有add到git管理中的" class="headerlink" title="删除非git管理文件(也就是没有add到git管理中的)"></a>删除非git管理文件(也就是没有add到git管理中的)</h1><pre><code>git clean
</code></pre><h1 id="查看即将被删除的非git管理文件"><a href="#查看即将被删除的非git管理文件" class="headerlink" title="查看即将被删除的非git管理文件"></a>查看即将被删除的非git管理文件</h1><pre><code>git clean -n
</code></pre><h1 id="删除非git管理文件-包含-gitignore中指定的文件"><a href="#删除非git管理文件-包含-gitignore中指定的文件" class="headerlink" title="删除非git管理文件,包含.gitignore中指定的文件"></a>删除非git管理文件,包含.gitignore中指定的文件</h1><pre><code>git clean -x
</code></pre><h1 id="强制删除所有的git非管理文件-git-clean需要设置clean-requireForce"><a href="#强制删除所有的git非管理文件-git-clean需要设置clean-requireForce" class="headerlink" title="强制删除所有的git非管理文件(git clean需要设置clean.requireForce)"></a>强制删除所有的git非管理文件(git clean需要设置clean.requireForce)</h1><pre><code>git clean -f
</code></pre><h1 id="还原正在手头修改-但是没有add到git的文件-相当于svn-revert-只不过git是本地的源"><a href="#还原正在手头修改-但是没有add到git的文件-相当于svn-revert-只不过git是本地的源" class="headerlink" title="还原正在手头修改,但是没有add到git的文件(相当于svn revert,只不过git是本地的源)"></a>还原正在手头修改,但是没有add到git的文件(相当于svn revert,只不过git是本地的源)</h1><pre><code>git checkout file_name
</code></pre><h1 id="删除已提交过的文件-把状态从add修改回来-可以使用checkout操作"><a href="#删除已提交过的文件-把状态从add修改回来-可以使用checkout操作" class="headerlink" title="删除已提交过的文件(把状态从add修改回来,可以使用checkout操作)"></a>删除已提交过的文件(把状态从add修改回来,可以使用checkout操作)</h1><pre><code>git reset HEAD file_name
</code></pre><h1 id="创建一个分支"><a href="#创建一个分支" class="headerlink" title="创建一个分支"></a>创建一个分支</h1><pre><code>git branch dirname
</code></pre><h1 id="查看存在的分支"><a href="#查看存在的分支" class="headerlink" title="查看存在的分支"></a>查看存在的分支</h1><pre><code>git branch
git branch -a 查看所有的分支
</code></pre><h1 id="切换到分支"><a href="#切换到分支" class="headerlink" title="切换到分支"></a>切换到分支</h1><pre><code>git checkout branch_name
</code></pre><h1 id="在某个版本上创建分支并求换"><a href="#在某个版本上创建分支并求换" class="headerlink" title="在某个版本上创建分支并求换"></a>在某个版本上创建分支并求换</h1><pre><code>git checkout commit_name -b branch_name
</code></pre><h1 id="切换到主干"><a href="#切换到主干" class="headerlink" title="切换到主干"></a>切换到主干</h1><pre><code>git checkout master
</code></pre><h1 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h1><pre><code>git merge branch_name
</code></pre><h1 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h1><pre><code>git branch -d branch_name
</code></pre><h1 id="强制删除分支"><a href="#强制删除分支" class="headerlink" title="强制删除分支"></a>强制删除分支</h1><pre><code>git branch -D branch_name
</code></pre><h1 id="查看所有的远程的分支"><a href="#查看所有的远程的分支" class="headerlink" title="查看所有的远程的分支"></a>查看所有的远程的分支</h1><pre><code>git branch -r
</code></pre><h1 id="重置提交-重置最近三次的提交"><a href="#重置提交-重置最近三次的提交" class="headerlink" title="重置提交(重置最近三次的提交)"></a>重置提交(重置最近三次的提交)</h1><pre><code>git reset --hard HEAD~3
</code></pre><h1 id="在分支上执行rebase"><a href="#在分支上执行rebase" class="headerlink" title="在分支上执行rebase"></a>在分支上执行rebase</h1><pre><code>git checkout branch_name
git rebase master
</code></pre><h1 id="rebase之后修改冲突-再提交"><a href="#rebase之后修改冲突-再提交" class="headerlink" title="rebase之后修改冲突,再提交"></a>rebase之后修改冲突,再提交</h1><pre><code>git add conflict_file
git rebase --continue
</code></pre><h1 id="添加标签"><a href="#添加标签" class="headerlink" title="添加标签"></a>添加标签</h1><pre><code>git tag tag_name
</code></pre><h1 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h1><pre><code>git tag
</code></pre><h1 id="显示包含标签资料的历史记录"><a href="#显示包含标签资料的历史记录" class="headerlink" title="显示包含标签资料的历史记录"></a>显示包含标签资料的历史记录</h1><pre><code>git log --decorate
</code></pre><h1 id="查看git提交的注释"><a href="#查看git提交的注释" class="headerlink" title="查看git提交的注释"></a>查看git提交的注释</h1><pre><code>git log
</code></pre><h1 id="编辑tag注释"><a href="#编辑tag注释" class="headerlink" title="编辑tag注释"></a>编辑tag注释</h1><pre><code>git tag -a tag_name
然后再文件中输入注释
</code></pre><h1 id="编辑tag注释-1"><a href="#编辑tag注释-1" class="headerlink" title="编辑tag注释"></a>编辑tag注释</h1><pre><code>git tag -am &quot;注释&quot; tag_name
</code></pre><h1 id="查看标签的提交记录"><a href="#查看标签的提交记录" class="headerlink" title="查看标签的提交记录"></a>查看标签的提交记录</h1><pre><code>git show tag
</code></pre><h1 id="查看tag注释"><a href="#查看tag注释" class="headerlink" title="查看tag注释"></a>查看tag注释</h1><pre><code>git tag -n
</code></pre><h1 id="删除tag"><a href="#删除tag" class="headerlink" title="删除tag"></a>删除tag</h1><pre><code>git tag -d tag_name
</code></pre><h1 id="合并提交注释"><a href="#合并提交注释" class="headerlink" title="合并提交注释"></a>合并提交注释</h1><pre><code>git commit --amend
进入编辑器,然后进行注释修改(使用git log进行提交注释查看)
</code></pre><h1 id="取消上一次提交"><a href="#取消上一次提交" class="headerlink" title="取消上一次提交"></a>取消上一次提交</h1><pre><code>git revert HEAD
</code></pre><h1 id="删除最近提交"><a href="#删除最近提交" class="headerlink" title="删除最近提交"></a>删除最近提交</h1><pre><code>git reset --hart HEAD~~
</code></pre><h1 id="查看远程git地址"><a href="#查看远程git地址" class="headerlink" title="查看远程git地址"></a>查看远程git地址</h1><pre><code>git remote -v
</code></pre><h1 id="查看git配置项"><a href="#查看git配置项" class="headerlink" title="查看git配置项"></a>查看git配置项</h1><pre><code>git config --list
</code></pre><h1 id="编辑git配置"><a href="#编辑git配置" class="headerlink" title="编辑git配置"></a>编辑git配置</h1><pre><code>git config -e
</code></pre><h1 id="保存本地工作进度"><a href="#保存本地工作进度" class="headerlink" title="保存本地工作进度"></a>保存本地工作进度</h1><pre><code>git stash
</code></pre><h1 id="查看保存的快照"><a href="#查看保存的快照" class="headerlink" title="查看保存的快照"></a>查看保存的快照</h1><pre><code>git stash list
</code></pre><h1 id="恢复stash中的内容到工作区"><a href="#恢复stash中的内容到工作区" class="headerlink" title="恢复stash中的内容到工作区"></a>恢复stash中的内容到工作区</h1><pre><code>git stash pop
</code></pre><h1 id="恢复缓冲区内容"><a href="#恢复缓冲区内容" class="headerlink" title="恢复缓冲区内容"></a>恢复缓冲区内容</h1><pre><code>git stash apply stash_name
</code></pre><h1 id="删除缓冲区中的内容"><a href="#删除缓冲区中的内容" class="headerlink" title="删除缓冲区中的内容"></a>删除缓冲区中的内容</h1><pre><code>git clear
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="初始化一个git项目"><a href="#初始化一个git项目" class="headerlink" title="初始化一个git项目"></a>初始化一个git项目</h1><pre><code>git init
</code></pre><h1 id="]]>
    </summary>
    
      <category term="Other" scheme="http://www.cxyteam.com/tags/Other/"/>
    
      <category term="Other" scheme="http://www.cxyteam.com/categories/Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言高级函数使用]]></title>
    <link href="http://www.cxyteam.com/2016/08/15/C%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.cxyteam.com/2016/08/15/C语言高级函数使用/</id>
    <published>2016-08-15T00:17:17.000Z</published>
    <updated>2016-09-11T08:49:52.000Z</updated>
    <content type="html"><![CDATA[<h1 id="函数的指针"><a href="#函数的指针" class="headerlink" title="函数的指针"></a>函数的指针</h1><pre><code>当你创建一个函数test的时候,同时也会创建test的指针变量,变量中保存了函数的地址
</code></pre><h1 id="创建函数指针"><a href="#创建函数指针" class="headerlink" title="创建函数指针"></a>创建函数指针</h1><pre><code>int(*warp_fn)(int);     #创建warp_fn的变量,用来保存test()函数的地址
warp_fn = test;
warp_fn(4);             #等同于调用test函数

char** (*names_fn)(char*, int);                     #创建一个names_fn的变量用来保存test函数
names_fn = test;
char** results = name_fn(1972);
</code></pre><h1 id="函数指针应用"><a href="#函数指针应用" class="headerlink" title="函数指针应用"></a>函数指针应用</h1><pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int NUM_ADS = 7;
char *ADS[] = {
    &quot;William:SBM GSON likes sport,TV,dining&quot;,
    &quot;Matt:SWM NS likes art,movies,theather&quot;,
    &quot;Luis:SLM ND likes books,theater,art&quot;,
    &quot;MIKE:DWM DS likes truncks,sports and bieber&quot;,
    &quot;Peter:SAM likes chess,working out and art&quot;,
    &quot;Josh:SJM likes sports,movies and theater&quot;,
    &quot;Jed:DBM likes theater,books and dining&quot;
};
/**
 * 都要定义哦
 */
void find();
int sports_no_bieber(char *s);
int sports_or_workout(char *s);
int ns_theater(char *s);

int main()
{
    find(sports_no_bieber);
    find(sports_or_workout);
    find(ns_theater);
    return 0;
}

/**
 * 注意find中传入的参数是函数的指针
 * char** 表示返回类型
 * *func 表示指针变量
 * char* 表示参数类型
 */
void find(char** (*func)(char*))
{
    int i;
    puts(&quot;Search results:&quot;);
    puts(&quot;---------------------&quot;);

    for(i=0;i&lt;NUM_ADS;i++) {
        if (func(ADS[i])) {
            printf(&quot;%s\n&quot;, ADS[i]);
        }
    }

    puts(&quot;----------------&quot;);
}

int sports_no_bieber(char *s)
{
    return strstr(s, &quot;sports&quot;) &amp;&amp; !strstr(s, &quot;bieber&quot;);
}

int sports_or_workout(char *s)
{
    return strstr(&quot;s&quot;, &quot;sports&quot;) || strstr(s, &quot;working out&quot;);
}

int ns_theater(char *s)
{
    return strstr(s, &quot;NS&quot;) &amp;&amp; strstr(s, &quot;theater&quot;);
}
</code></pre><h1 id="qsort使用"><a href="#qsort使用" class="headerlink" title="qsort使用"></a>qsort使用</h1><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int compare_scores(const void * scores_a, const void * scores_b);

typedef struct {
    int width;
    int height;
} rectangle;

int compare_areas(const void* a, const void* b);

int compare_name(const void* a, const void* b);

int main()
{
    int scores[] = {2,3,123,345,456,7,11,3,5,6};
    qsort(scores, 10, sizeof(int), compare_scores);
    int i;

    for(i=0;i&lt;10;i++) {
        printf(&quot;%i\n&quot;, scores[i]);
    }

    int areas[] = {2,3,345,123,1};
    qsort(areas, 5, sizeof(int), compare_areas);
    int x;

    for(x=0;x&lt;5;x++) {
        printf(&quot;%i\n&quot;, areas[x]);
    }

    char *names[] = {&quot;c&quot;, &quot;a&quot;,&quot;b&quot;};
    qsort(names, 3, sizeof(char*), compare_name);
    int z;

    for(z=0;z&lt;3;z++) {
        printf(&quot;%s\n&quot;, names[z]);
    }

    return 0;
}

/**
    void指针可以保存任何类型数据的地址,但使用前必须把它转换成具体类型
*/
int compare_scores(const void * scores_a, const void * scores_b)
{
    /**
        int * 把void指针转换成整形指针
        *(int *)获取获取scores_a中的整形值
    */
    int a = *(int *)scores_a;
    int b = *(int *)scores_b;

    return b-a;
}

int compare_areas(const void *a, const void *b)
{
    /**
        把指针转换成相应的类型
    */
    rectangle *ia = (rectangle*)a;
    rectangle *ib = (rectangle*)b;
    /**
        矩形面积计算
    */
    int area_a = (ia-&gt;width * ia-&gt;height);
    int area_b = (ia-&gt;width * ia-&gt;height);

    return area_a-area_b;
}

int compare_name(const void* a, const void* b)
{
    /**
        char** 代表的是指向字符指针的指针
    */
    char** sa = (char**)a;
    char** sb = (char**)b;

    /**
        strcmp接收的是char*的值,而char**是指针地址
    */
    return strcmp(*sa, *sb);
}
</code></pre><h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><pre><code>void(*function_name[])(response)={function_a,function_b};
void            声明返回类型
*               声明函数指针
function_name   变量名
[]              表明是函数数组
response        参数类型
例子:
    #include &lt;stdio.h&gt;

    enum response_type {DUMP, SECOND_CHANCE, MARRIAGE};

    typedef struct {
        char* name;
        enum response_type type;
    }response;

    void dump(response r);
    void second_chance(response r);
    void marriage(response r);

    int main()
    {
        response ra[] = {
            {&quot;test&quot;, DUMP},
            {&quot;test2&quot;, SECOND_CHANCE},
        };

        /**
            定义函数数组
        */
        void(*func_arr[])(response) = {dump, second_chance, marriage};

        int i;
        for (i=0;i&lt;2;i++) {
            /**
                使用函数数组定义的方法
            */
            (func_arr[ra[i].type])(ra[i]);

            /**
                受用switch的方法
            */
            switch(ra[i].type) {
                case DUMP:
                    dump(ra[i]);
                break;
                case SECOND_CHANCE:
                    second_chance(ra[i]);
                break;
                default:
                    marriage(ra[i]);
                break;
            }
        }

        return 0;
    }

    void dump(response r)
    {
        printf(&quot;hello,i&apos;m dump, you are %s\n&quot;, r.name);
    }

    void second_chance(response r)
    {
        printf(&quot;hello,i&apos;m second_chance, you are %s\n&quot;, r.name);
    }

    void marriage(response r)
    {
        printf(&quot;hello,i&apos;m marriage, you are %s\n&quot;, r.name);
    }
</code></pre><h1 id="可变参数个数"><a href="#可变参数个数" class="headerlink" title="可变参数个数"></a>可变参数个数</h1><pre><code>在C标准库中有一组宏可以建立自己的可变参数函数,&lt;stdarg.h&gt;
例子
#include &lt;stdio.h&gt;
#include &lt;stdarg.h&gt;

void print_ints(int args, ...)
{
    /*
        保存传给函数的其他参数
    */
    va_list ap;

    /*
        表示可变参数从哪开始
    */
    va_start(ap, args);
    int i;
    /*
        循环遍历所有其他参数,args保存了参数的数目
    */
    for(i=0;i&lt;args;i++) {
        printf(&quot;argument:%i\n&quot;, va_arg(ap, int));
    }

    va_end(ap);
}

int main()
{
    print_ints(3, 79, 101, 32);
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="函数的指针"><a href="#函数的指针" class="headerlink" title="函数的指针"></a>函数的指针</h1><pre><code>当你创建一个函数test的时候,同时也会创建test的指针变量,变量中保存了函数的地址
</code]]>
    </summary>
    
      <category term="C" scheme="http://www.cxyteam.com/tags/C/"/>
    
      <category term="C" scheme="http://www.cxyteam.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言内存泄露检测Valgrind]]></title>
    <link href="http://www.cxyteam.com/2016/08/11/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%B5%8BValgrind/"/>
    <id>http://www.cxyteam.com/2016/08/11/C语言内存泄露检测Valgrind/</id>
    <published>2016-08-11T01:05:15.000Z</published>
    <updated>2016-08-12T00:41:15.000Z</updated>
    <content type="html"><![CDATA[<h1 id="valgrind使用场景"><a href="#valgrind使用场景" class="headerlink" title="valgrind使用场景"></a>valgrind使用场景</h1><pre><code>检查代码中在堆上分配存储器,但是没释放的位置,也就是找出存储器泄露位置
</code></pre><h1 id="valgrind工作原理"><a href="#valgrind工作原理" class="headerlink" title="valgrind工作原理"></a>valgrind工作原理</h1><pre><code>通过伪造malloc可以监控分配在堆上的数据,当程序想分配堆存储器时,valgrind将会拦截你对malloc和free的调用,然后运行自己的malloc和free函数,它会记录哪段代码分配了哪段存储器,结束的时候,valgrind会汇报堆上有哪些数据,并告诉你这些数据由哪段代码创建
</code></pre><h1 id="安装valgrind"><a href="#安装valgrind" class="headerlink" title="安装valgrind"></a>安装valgrind</h1><pre><code>curl -O http://valgrind.org/downloads/valgrind-3.11.0.tar.bz2
tar -xjvf valgrind-3.11.0.tar.bz2
cd valgrind-3.11.0
./configure &amp;&amp; make &amp;&amp; make install
valgrind --version
</code></pre><h1 id="使用valgrind"><a href="#使用valgrind" class="headerlink" title="使用valgrind"></a>使用valgrind</h1><pre><code>gcc -g test.c -o test (其中-g是告诉编译器要记录需编译代码的行号)
valgrind --leak-check=full ./test
</code></pre><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><pre><code>createByMalloc.c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

//结构定义函数体的外面多个函数才能共享
typedef struct island {
    char *name;
    char *open;
    char *close;
    struct island *next;
} island;


void display(island *start);
island* create(char *name);

int main()
{
    char name[80];
    fgets(name, 80, stdin);
    island *i = create(name);

    fgets(name, 80, stdin);
    island *i1 = create(name);
    i-&gt;next = i1;
    display(i);
    release(i);
}

island* create (char *name)
{
    island *i = malloc(sizeof(island));
    //注意在此处一定用用strdup在堆上存储,如果都是在栈上存储,函数结束后会释放内存空间,每次都只能保存最后传入的name指针指向的值
    i-&gt;name = strdup(name);
    i-&gt;open = &quot;09:00&quot;;
    i-&gt;close = &quot;17:00&quot;;
    i-&gt;next = NULL;

    return i;
}


void display(island *start) {
    island *i = start;
    for (;i!=NULL;i=i-&gt;next) {
        printf(&quot;name:%s,open:%s-%s\n&quot;,i-&gt;name, i-&gt;open, i-&gt;close);
    }
}

gcc -g createByMalloc.c -o createByMalloc
valgrind --leak-check=full ./createByMalloc
</code></pre><p><img src="/img/c_code/list/valgrind.png" alt="Alt text" title="错误信息图片"></p>
<pre><code>1.total heap usage: 520 allocs, 100 frees, 49,567 bytes allocated
    表示520次存储器,100次被释放

2.at 0x100007EA1: malloc (vg_replace_malloc.c:303)
  by 0x100000D7A: create (createByMalloc.c:33)
  by 0x100000CED: main (createByMalloc.c:23)
    明确指出了可能出问题的行,查看代码可以发现是create的33行分配的堆上的存储器没有被释放,所以加上释放代码就好了

正确例子:
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

//结构定义函数体的外面多个函数才能共享
typedef struct island {
    char *name;
    char *open;
    char *close;
    struct island *next;
} island;


void display(island *start);
void release1(island *start);
void release(island *start);
island* create(char *name);

int main()
{
    char name[80];
    fgets(name, 80, stdin);
    island *i = create(name);

    fgets(name, 80, stdin);
    island *i1 = create(name);
    i-&gt;next = i1;
    display(i);
}

island* create (char *name)
{
    island *i = malloc(sizeof(island));
    //注意在此处一定用用strdup在堆上存储,如果都是在栈上存储,函数结束后会释放内存空间,每次都只能保存最后传入的name指针指向的值
    i-&gt;name = strdup(name);
    i-&gt;open = &quot;09:00&quot;;
    i-&gt;close = &quot;17:00&quot;;
    i-&gt;next = NULL;

    return i;
}


void display(island *start) {
    island *i = start;
    for (;i!=NULL;i=i-&gt;next) {
        printf(&quot;name:%s,open:%s-%s\n&quot;,i-&gt;name, i-&gt;open, i-&gt;close);
    }
}

void release1(island *start) {
    island *i = NULL;
    for(i=start;i!=NULL;i=i-&gt;next) {
        free(i-&gt;name);
        free(i);
    }
}

void release(island *start) {
    island *i = start;
    island *next = NULL;
    for(;i!=NULL;i=next) {
        next = i-&gt;next;
        free(i-&gt;name);
        free(i);
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="valgrind使用场景"><a href="#valgrind使用场景" class="headerlink" title="valgrind使用场景"></a>valgrind使用场景</h1><pre><code>检查代码中在堆上分配存储器,但是没释放的位置]]>
    </summary>
    
      <category term="C" scheme="http://www.cxyteam.com/tags/C/"/>
    
      <category term="C" scheme="http://www.cxyteam.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言动态存储]]></title>
    <link href="http://www.cxyteam.com/2016/08/10/C%E8%AF%AD%E8%A8%80%E5%8A%A8%E6%80%81%E5%AD%98%E5%82%A8/"/>
    <id>http://www.cxyteam.com/2016/08/10/C语言动态存储/</id>
    <published>2016-08-10T00:12:39.000Z</published>
    <updated>2016-08-11T00:52:09.000Z</updated>
    <content type="html"><![CDATA[<h1 id="动态数据存储的位置"><a href="#动态数据存储的位置" class="headerlink" title="动态数据存储的位置"></a>动态数据存储的位置</h1><pre><code>堆,它是程序中用来保存长期使用数据的地方
</code></pre><h1 id="获取空间"><a href="#获取空间" class="headerlink" title="获取空间"></a>获取空间</h1><pre><code>使用malloc()函数进行申请
</code></pre><h1 id="如何释放"><a href="#如何释放" class="headerlink" title="如何释放"></a>如何释放</h1><pre><code>使用free()函数进行释放
</code></pre><h1 id="使用malloc"><a href="#使用malloc" class="headerlink" title="使用malloc"></a>使用malloc</h1><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

//结构定义函数体的外面多个函数才能共享
typedef struct island {
    char *name;
    char *open;
    char *close;
    struct island *next;
} island;
void display(island *start);
void release(island *start);
island* create();

int main()
{
    char name[80];
    fgets(name, 80, stdin);
    island *i = create(name);

    fgets(name, 80, stdin);
    island *i1 = create(name);
    i-&gt;next = i1;
    display(i);
    release(i);
}

island* create (char *name)
{
    island *i = malloc(sizeof(island));
    //注意在此处一定用用strdup在堆上存储,如果都是在栈上存储,函数结束后会释放内存空间,每次都只能保存最后传入的name指针指向的值
    i-&gt;name = strdup(name);
    i-&gt;open = &quot;09:00&quot;;
    i-&gt;close = &quot;17:00&quot;;
    i-&gt;next = NULL;

    return i;
}


void display(island *start) {
    island *i = start;
    for (;i!=NULL;i=i-&gt;next) {
        printf(&quot;name:%s,open:%s-%s\n&quot;,i-&gt;name, i-&gt;open, i-&gt;close);
    }
}

void release(island *start) {
    island *i = NULL;
    island *next = NULL;

    for(;i!=NULL;i=next) {
        next = i-&gt;next;
        free(i-&gt;name);
        free(i);
    }
}
</code></pre><h1 id="为什么island在堆上申请了内存-name还需要在堆上申请内存"><a href="#为什么island在堆上申请了内存-name还需要在堆上申请内存" class="headerlink" title="为什么island在堆上申请了内存,name还需要在堆上申请内存?"></a>为什么island在堆上申请了内存,name还需要在堆上申请内存?</h1><pre><code>因为结构只是把不同类型的数据写在一起,封装成一个大的数据类型,它不是创建了一个类型把所有数据都存储在它里面
</code></pre><h1 id="使用release的时候需要释放那些堆上的内存"><a href="#使用release的时候需要释放那些堆上的内存" class="headerlink" title="使用release的时候需要释放那些堆上的内存?"></a>使用release的时候需要释放那些堆上的内存?</h1><pre><code>因为name,和island在堆上申请了内存,所以只要释放他们的内存就好了,但是需要注意的是先释放name的内存,不然先释放了island就找不到name了
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="动态数据存储的位置"><a href="#动态数据存储的位置" class="headerlink" title="动态数据存储的位置"></a>动态数据存储的位置</h1><pre><code>堆,它是程序中用来保存长期使用数据的地方
</code></pre>]]>
    </summary>
    
      <category term="C" scheme="http://www.cxyteam.com/tags/C/"/>
    
      <category term="C" scheme="http://www.cxyteam.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言链表]]></title>
    <link href="http://www.cxyteam.com/2016/08/09/C%E8%AF%AD%E8%A8%80%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.cxyteam.com/2016/08/09/C语言链表/</id>
    <published>2016-08-08T23:57:33.000Z</published>
    <updated>2016-08-10T00:13:59.000Z</updated>
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><pre><code>是一种抽象的数据结构
</code></pre><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><pre><code>为了保存可变数量的数据,需要一样比数组更灵活的东西
</code></pre><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><pre><code>保存了一条数据和链向另一条数据的链接
</code></pre><h1 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h1><pre><code>#include &lt;stdio.h&gt;
//注意要先定义函数在main函数的外部
void display();
//结构定义函数体的外面多个函数才能共享
typedef struct island {
    char *name;
    char *open;
    char *close;
    struct island *next;
} island;

int main()
{
    island amity = {&quot;Amity&quot;, &quot;9:00&quot;, &quot;17:00&quot;, NULL};
    island craggy = {&quot;craggy&quot;, &quot;9:00&quot;, &quot;17:00&quot;, NULL};
    island shutter = {&quot;shutter&quot;, &quot;9:00&quot;, &quot;17:00&quot;, NULL};

    amity.next = &amp;craggy;
    craggy.next = &amp;shutter;

    display(&amp;amity);
    return 0;
}

void display(island *start) {
    island *i = start;
    for (;i!=NULL;i=i-&gt;next) {
        printf(&quot;name:%s,open:%s-%s\n&quot;,i-&gt;name, i-&gt;open, i-&gt;close);
    }
}
</code></pre><h1 id="递归结构"><a href="#递归结构" class="headerlink" title="递归结构"></a>递归结构</h1><pre><code>如果一个结构中包含一个链向同种结构的链接,那么这个结构就被称为递归结构
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><pre><code>是一种抽象的数据结构
</code></pre><h1 id="使用场景"><a href="#使用场景" class="h]]>
    </summary>
    
      <category term="C" scheme="http://www.cxyteam.com/tags/C/"/>
    
      <category term="C" scheme="http://www.cxyteam.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言联合]]></title>
    <link href="http://www.cxyteam.com/2016/07/27/C%E8%AF%AD%E8%A8%80%E8%81%94%E5%90%88/"/>
    <id>http://www.cxyteam.com/2016/07/27/C语言联合/</id>
    <published>2016-07-26T23:42:29.000Z</published>
    <updated>2016-07-27T00:32:47.000Z</updated>
    <content type="html"><![CDATA[<h1 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h1><pre><code>用union关键字定义的一个叫&quot;量&quot;的数据类型
typedef union {
    short count;
    float volume;
    float weight;
} quantity;
</code></pre><h1 id="联合的特点"><a href="#联合的特点" class="headerlink" title="联合的特点"></a>联合的特点</h1><pre><code>1.可以有效的使用存储器空间
    当定义联合的时候,计算机只为其中一个最大的字段分配空间,然后由你决定里面保存什么值(上面例子的name,age,weight都会存储在一个位置)
</code></pre><h1 id="如何使用联合"><a href="#如何使用联合" class="headerlink" title="如何使用联合"></a>如何使用联合</h1><pre><code>1.c89方式:只能设置联合的第一个字段也就是上述中的name字段
    例子:quantity a = {1};

2.指定初始化器:按名设置联合字段的值
    quantity b = {.volume = 4.6};

3.点表示法:先创建变量,在设置字段的值
    quantity c;
    c.weight = 3.7;

注意:无论哪种方法设置联合的值,都只会保存一条数据。联合只是提供了一种让你创建支持不同数据类型的变量的方法
实例:
    #include &lt;stdio.h&gt;

    int main()
    {
        typedef union {
            short count;
            float volume;
            float weight;
        } quantity;

        quantity a = {1};

        quantity b = {.volume = 4.6};

        quantity c;
        c.weight = 3.7;
        printf(&quot;%i,%f,%f&quot;, a.count, b.volume, c.weight);
        return 0;
    }
</code></pre><h1 id="结构和联合一起使用"><a href="#结构和联合一起使用" class="headerlink" title="结构和联合一起使用"></a>结构和联合一起使用</h1><pre><code>#include &lt;stdio.h&gt;

typedef union {
    short count;
    float volume;
    float weight;
} quantity;

typedef struct {
    const char *name;
    const char *country;
    quantity amount;
} fruit_order;

int main()
{
    /*
        此处的.amount表示fruit_order中的amount字段,.count表示quantity中的字段
    */
    fruit_order apples = {&quot;apple&quot;, &quot;china&quot;, .amount.count = 20};
    printf(&quot;%s,%s,%i&quot;, apples.name, apples.country, apples.amount.count);

    return 0;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h1><pre><code>用union关键字定义的一个叫&quot;量&quot;的数据类型
typedef union {
    short co]]>
    </summary>
    
      <category term="C" scheme="http://www.cxyteam.com/tags/C/"/>
    
      <category term="C" scheme="http://www.cxyteam.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言结构]]></title>
    <link href="http://www.cxyteam.com/2016/07/26/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84/"/>
    <id>http://www.cxyteam.com/2016/07/26/C语言结构/</id>
    <published>2016-07-26T00:14:25.000Z</published>
    <updated>2016-11-07T02:03:39.000Z</updated>
    <content type="html"><![CDATA[<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><pre><code>把不同的数据类型写在一起,封装成一个大数据类型;结构的大小固定;结构中的数据都有名字
例如:
    定义新结构
    /*
        注意fish只是结构的名字
    */
    struct fish {
        /*
            const char * 是用来保存不想修改的字符串,也就是字符串的字面值
        */
        const char *name;
        const char *species;
        int teeth;
        int age;
    };

    创建数据
    struct fish snappy = {&quot;snappy&quot;, &quot;piranha&quot;, 69, 4}

    复制结构内容
    struct fish snappy1 = snappy;
</code></pre><h1 id="读取结构内容"><a href="#读取结构内容" class="headerlink" title="读取结构内容"></a>读取结构内容</h1><pre><code>尽管结构可以向数组那样在结构中保存字段,但读取时只能按名访问;可以使用&quot;.&quot;运算符访问结构字段
fish.c的文件:
#include &lt;stdio.h&gt;

int main()
{
    struct fish {
        /*
            const char * 是用来保存不想修改的字符串,也就是字符串的字面值
        */
        const char *name;
        const char *species;
        int teeth;
        int age;
    };

    struct fish snappy = {
        /*
            注意依然不能使用单引号
        */
        &quot;snappy&quot;,
        &quot;piranha&quot;,
        69,
        4
    };

    /*
        获取的时候是定义的结构数据的名字,而不是结构本身的名字(是snappy而不是fish)
    */
    printf(&quot;%s,%s,%i,%i&quot;, snappy.name, snappy.species, snappy.teeth, snappy.age);

    return 0;
}

使用make编译:make fish &amp;&amp; ./fish
</code></pre><h1 id="存储器中的结构"><a href="#存储器中的结构" class="headerlink" title="存储器中的结构"></a>存储器中的结构</h1><pre><code>在定义结构时,并没有让计算机在存储器中创建任何东西,只是给了计算机一个模板,告诉它你希望新的数据类型长什么样子
当定义新变量时,计算机则需要在存储器中为结构的实例创建空间,这块空间必须足够大,以装下结构中的所有字段
把一个结构变量赋给另一个结构变量时,计算机会创建一个全新的结构副本,也就是说,计算机需要再分配一块存储器空间,大小和原来相同,然后把每个字段都复制过去
</code></pre><h1 id="结构的嵌套"><a href="#结构的嵌套" class="headerlink" title="结构的嵌套"></a>结构的嵌套</h1><pre><code>#include &lt;stdio.h&gt;

int main()
{
    /*
        注意结束的分号不要忘记打,这个不是数组
    */
    struct preferences {
        /*
            此处结尾是分号,不是逗号
        */
        const char *food;
        float exercise_hours;
    };

    struct fish {
        const char *name;
        const char *species;
        int teeth;
        int age;
        /*
            结构的嵌套:在结构中定义结构
            此处定义的不是一个结构体,而是一个结构创建后的数据(是struct preferences care而不是struct preferences)
        */
        struct preferences care;
    };

    struct fish snappy = {
        &quot;snappy&quot;,
        &quot;piranha&quot;,
        69,
        4,
        {
            &quot;fish&quot;,
            4.00
        }
    };

    /*
        获取嵌套的结构中的数据注意care是嵌套的结构的名字
    */
    printf(&quot;%s,%f&quot;, snappy.care.food, snappy.care.exercise_hours);
}
</code></pre><h1 id="创建别名"><a href="#创建别名" class="headerlink" title="创建别名"></a>创建别名</h1><pre><code>使用typedef将struct name重命名rename,在后续创建结构数据的时候,可以直接使用rename
其实struct name是结构名,rename是类型名
typedef struct name {} rename;

例子:
#include &lt;stdio.h&gt;

int main()
{
    typedef struct big_fish {
        /*
            const char * 是用来保存不想修改的字符串,也就是字符串的字面值
        */
        const char *name;
        const char *species;
        int teeth;
        int age;
    } fish;

    fish snappy = {
        /*
            注意依然不能使用单引号
        */
        &quot;snappy&quot;,
        &quot;piranha&quot;,
        69,
        4
    };

    printf(&quot;%s,%s,%i,%i&quot;, snappy.name, snappy.species, snappy.teeth, snappy.age);
    return 0;
}
</code></pre><h1 id="匿名结构"><a href="#匿名结构" class="headerlink" title="匿名结构"></a>匿名结构</h1><pre><code>typeof struct {} rename
不存在name(结构名)只存在rename(类型名)
</code></pre><h1 id="更新结构"><a href="#更新结构" class="headerlink" title="更新结构"></a>更新结构</h1><pre><code>#include &lt;stdio.h&gt;

typedef struct {
    const char *name;
    const char *species;
    int age;
} turtle;

void happy_birthday(turtle t)
{
    /*
        关键在此处更新结构
    */
    t.age = t.age + 1;
    printf(&quot;happy birthday %s,you are %i years old!\n&quot;, t.name, t.age);
}

int main()
{
    turtle myrtle = {&quot;Myrtle&quot;, &quot;Leatherback sea turtle&quot;, 99};
    happy_birthday(myrtle);
    printf(&quot;%s&apos;s age is now %i\n&quot;, myrtle.name, myrtle.age);

    return 0;
}

为什么最终输出来的值是:
    happy birthday Myrtle,you are 100 years old!
    Myrtle&apos;s age is now 99

为什么传给函数happy_birthday的时候age递增1变成100,调用完之后再次查看age的值结果是99?
因为你传入的是结构的值,不是结构的指针,所以他会对结构的值进行复制
</code></pre><h1 id="指针更新结构"><a href="#指针更新结构" class="headerlink" title="指针更新结构"></a>指针更新结构</h1><pre><code>#include &lt;stdio.h&gt;

typedef struct {
    const char *name;
    const char *species;
    int age;
} turtle;

void happy_birthday(turtle *t)
{
    /*
        (*t)表示myrtle指针指向的值,一定要打括号,表示一个整体
        (*t).age表示的是t指向的结构的指针,最后得到的是年龄
        *t.age表示的是t.age这个存储器单元中的内容
    */
    (*t).age = (*t).age + 1;
    printf(&quot;happy birthday %s,you are %i years old!\n&quot;, (*t).name, (*t).age);
}

int main()
{
    turtle myrtle = {&quot;Myrtle&quot;, &quot;Leatherback sea turtle&quot;, 99};
    /*
        注意此处传入的是结构的指针,使用&apos;&amp;&apos;获取指针
    */
    happy_birthday((&amp;myrtle));
    printf(&quot;%s&apos;s age is now %i\n&quot;, myrtle.name, myrtle.age);

    return 0;
}
</code></pre><h1 id="易读的表达方式"><a href="#易读的表达方式" class="headerlink" title="易读的表达方式"></a>易读的表达方式</h1><pre><code>#include &lt;stdio.h&gt;

typedef struct {
    const char *name;
    const char *species;
    int age;
} turtle;

void happy_birthday(turtle *t)
{
    /*
        (*t).age == t-&gt;age
    */
    t-&gt;age = t-&gt;age + 1;
    printf(&quot;happy birthday %s,you are %i years old!\n&quot;, (*t).name, (*t).age);
}

int main()
{
    turtle myrtle = {&quot;Myrtle&quot;, &quot;Leatherback sea turtle&quot;, 99};
    happy_birthday((&amp;myrtle));
    printf(&quot;%s&apos;s age is now %i\n&quot;, myrtle.name, myrtle.age);

    return 0;
}6
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><pre><code>把不同的数据类型写在一起,封装成一个大数据类型;结构的大小固定;结构中的数据都有名字
例如:
    定义新结构
    /]]>
    </summary>
    
      <category term="C" scheme="http://www.cxyteam.com/tags/C/"/>
    
      <category term="C" scheme="http://www.cxyteam.com/categories/C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言声明与定义分离]]></title>
    <link href="http://www.cxyteam.com/2016/07/24/C%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E5%A4%9A%E4%B8%AA%E6%BA%90%E6%96%87%E4%BB%B6/"/>
    <id>http://www.cxyteam.com/2016/07/24/C语言使用多个源文件/</id>
    <published>2016-07-24T09:56:26.000Z</published>
    <updated>2016-09-11T08:48:01.000Z</updated>
    <content type="html"><![CDATA[<h1 id="为什么要使用声明与定义分离-它解决了什么问题"><a href="#为什么要使用声明与定义分离-它解决了什么问题" class="headerlink" title="为什么要使用声明与定义分离,它解决了什么问题"></a>为什么要使用声明与定义分离,它解决了什么问题</h1><pre><code>1.代码顺序的问题
    #include &lt;stdio.h&gt;
        /*
            由于函数定义顺序产生的一个编译的错误
        */
        int main()
        {
            demo();

            return 0;
        }

        float demo()
        {
            return 1.00;
        }

2.解决了代码的互相依赖的问题,在a方法中调用了b方法,在b方法中又调用了b方法
    #include &lt;stdio.h&gt;
    int demo()
    {
        test();
    }

    int test()
    {
        demo();
    }

    int main()
    {
        demo();
        return 0;
    }
</code></pre><h1 id="如下代码为什么会报错"><a href="#如下代码为什么会报错" class="headerlink" title="如下代码为什么会报错"></a>如下代码为什么会报错</h1><pre><code>#include &lt;stdio.h&gt;
/*
    由于函数定义顺序产生的一个编译的错误
*/
int main()
{
    demo();

    return 0;
}

float demo()
{
    return 1.00;
}

1.编译器看到不认识的函数调用(函数未定义),认为它会在之后的源文件中找到这个函数的详细信息。它会先记录下来,随后在文件中查找
2.编译器需要知道函数的返回类型,由于函数未定义,所以不知道它的返回类型,所以只好假设它返回int
3.等编译器看到实际的函数,返回&quot;conflicting types for &apos;demo&apos;&quot;的错误,因为编译器认为有两个同名的函数,一个是文件中的函数,一个是编译器假设返回int的那个
</code></pre><h1 id="什么是声明与定义分离"><a href="#什么是声明与定义分离" class="headerlink" title="什么是声明与定义分离"></a>什么是声明与定义分离</h1><pre><code>如果在第二步函数就知道返回类型了,就不需要再找了,所以为了防止编译器假设函数的返回类型,可以显示的告诉他,告诉编译器函数会返回什么类型的语句就叫函数声明;一旦声明了,编译器就不需要假设了,完全可以先调用函数,再定义函数
声明只是一个函数签名:一条包含函数名,形参类型与返回类型的记录
</code></pre><h1 id="如何让声明与定义分离"><a href="#如何让声明与定义分离" class="headerlink" title="如何让声明与定义分离"></a>如何让声明与定义分离</h1><pre><code>例如:
    #include &lt;stdio.h&gt;

    /*
        此处声明了函数
    */
    int demo();

    int main()
    {
        demo();
        puts(&quot;this is main function&quot;);

        return 0;
    }

    /*
        此处定义了函数
    */
    int demo()
    {
        puts(&quot;this is demo function&quot;);
        return 0;
    }
</code></pre><h1 id="创建完全和函数体分离的头文件"><a href="#创建完全和函数体分离的头文件" class="headerlink" title="创建完全和函数体分离的头文件"></a>创建完全和函数体分离的头文件</h1><pre><code>demo.h文件内容:
    int demo();

函数体中的内容:
    #include &lt;stdio.h&gt;
    /*
        注意这里是双引号,且没有分号,文件在当前目录下,是相对路径,里面之定义了头信息(就是函数的返回值以及类型)
    */
    #include &quot;demo.h&quot;

    int main()
    {
        /*
            调用未定义的函数,不报错(因为上面加载了函数头信息)
        */
        demo();
        puts(&quot;this is main function&quot;);

        return 0;
    }

    int demo()
    {
        puts(&quot;this is demo function&quot;);
        return 0;
    }
</code></pre><h1 id="什么是预处理"><a href="#什么是预处理" class="headerlink" title="什么是预处理"></a>什么是预处理</h1><pre><code>预处理是把c源码转化成可执行文件的第一个阶段,预处理会在编译开始之前修改代码,创建一个新的源文件(为了提高效率,编译器通常会用管道在两个阶段之间发送数据)
</code></pre><h1 id="include-lt-gt-和include-“”有什么区别"><a href="#include-lt-gt-和include-“”有什么区别" class="headerlink" title="include &lt;&gt; 和include “”有什么区别"></a>include &lt;&gt; 和include “”有什么区别</h1><pre><code>引号表示使用以相对路径查找头文件,如果不加目录名,只包含一个文件名,编译器就会在当前目录下查找头文件;如果遇到尖括号,会到标准库代码所在目录查找头文件
</code></pre><h1 id="gcc一般会去哪些位置寻找头文件"><a href="#gcc一般会去哪些位置寻找头文件" class="headerlink" title="gcc一般会去哪些位置寻找头文件"></a>gcc一般会去哪些位置寻找头文件</h1><pre><code>gcc知道标准库的头文件被保存的位置,头文件一般保存在/usr/local/include,/usr/include这些地方
</code></pre><h1 id="编译器是如何工作的"><a href="#编译器是如何工作的" class="headerlink" title="编译器是如何工作的"></a>编译器是如何工作的</h1><pre><code>1.预处理:修改代码
    用include指令添加相关头文件;跳过程序中的某些代码;补充一些代码

2.编译:转换成汇编代码
    计算机只理解底层的机器代码指令,在这一步,会把语句或函数调用转化成一串汇编语言指令

3.汇编:生成目标代码
    编译器将符号代码汇编成机器代码或目标代码,也就是CPU内部电路执行的二进制代码

4.链接:放在一起
    一旦有了目标代码,就需要将它们拼在一起,构成可执行程序,当某个代码调用另外一个目标代码的函数时,编译器会把它们连接在一起。同时,链接还会确保程序能够调用库代码。最后程序会写到一个可执行程序文件中,文件格式视操作系统而定,操作系统根据文件格式把程序加载到存储器中运行
</code></pre><h1 id="如何进行代码共享"><a href="#如何进行代码共享" class="headerlink" title="如何进行代码共享"></a>如何进行代码共享</h1><pre><code>例如在将数据写入到数据库中需要进行加密,在将数据写入到缓存中中也要进行加密,他们的加密方法是一致的,不需要在两个文件中都写一份加密的代码
1.创建自己的头文件
    encrypt.h文件
        void encrypt(char *message);

2.引用头文件
    encrypt.c文件
    #include &quot;encrypt.h&quot;

    void encrypt(char *message)
    {
        char c;
        while(*message) {
            *message = *message ^ 31;
            message++;
        }
    }

    db.c文件
    #include &lt;stdio.h&gt;
    #include &quot;encrypt.h&quot;

    int main()
    {
        char msg[80];
        while(fgets(msg, 80, stdin)) {
            encrypt(msg);
            printf(&quot;%s\n&quot;, msg);
        }
    }

3.执行命令(将多个文件编译成一个可执行文件)
    gcc db.c encrypt.c -o db &amp;&amp; ./db
</code></pre><h1 id="如果源文件很多-每次编译都需要耗费很长的时间-如何做到只重新编译改了的文件"><a href="#如果源文件很多-每次编译都需要耗费很长的时间-如何做到只重新编译改了的文件" class="headerlink" title="如果源文件很多,每次编译都需要耗费很长的时间,如何做到只重新编译改了的文件"></a>如果源文件很多,每次编译都需要耗费很长的时间,如何做到只重新编译改了的文件</h1><pre><code>回顾下编译器的工作原理,如果源文件没有进行变化的话,那么只有最后一步需要重新做(也就是链接);如果文件修改了毫无疑问需要重新编译
</code></pre><h1 id="如何做能让gcc把目标代码保存在文件中-然后让编译器把目标文件链接起来"><a href="#如何做能让gcc把目标代码保存在文件中-然后让编译器把目标文件链接起来" class="headerlink" title="如何做能让gcc把目标代码保存在文件中?然后让编译器把目标文件链接起来?"></a>如何做能让gcc把目标代码保存在文件中?然后让编译器把目标文件链接起来?</h1><pre><code>1.首先把源代码编译为目标文件
    gcc -c *.c

2.把目标文件链接起来
    gcc *.o -o demo
</code></pre><h1 id="修改代码的编译流程变成了这样"><a href="#修改代码的编译流程变成了这样" class="headerlink" title="修改代码的编译流程变成了这样"></a>修改代码的编译流程变成了这样</h1><pre><code>1.首次编译
    gcc *.c -o demo

2.修改了test.c文件

3.再次编译
    gcc -c test.c

4.再次链接
    gcc *.o -o demo
</code></pre><h1 id="如果我修改了很多文件-记录下来修改哪些文件也很麻烦"><a href="#如果我修改了很多文件-记录下来修改哪些文件也很麻烦" class="headerlink" title="如果我修改了很多文件,记录下来修改哪些文件也很麻烦"></a>如果我修改了很多文件,记录下来修改哪些文件也很麻烦</h1><pre><code>使用make工具自动化构建
</code></pre><h1 id="make"><a href="#make" class="headerlink" title="make"></a>make</h1><pre><code>make是一个可以运行编译命令的工具。make会检查源文件和目标文件的时间戳,如果目标文件过期,make就会重新编译它
</code></pre><h1 id="需要提供给make的条件"><a href="#需要提供给make的条件" class="headerlink" title="需要提供给make的条件"></a>需要提供给make的条件</h1><pre><code>1.依赖项;生成目标需要用哪些文件
2.生成方法;生成该文件时要用哪些指令
例如
    将demo.c编译成demo.o,依赖项和生成方法分别是什么?
    demo.o就是目标,因为需要生成这个文件,demo.c就是依赖项,因为编译器创建demo.o的时候需要它
    生成方法就是将demo.c转化成demo.o的命令也就是gcc -c demo.c
</code></pre><h1 id="怎样把依赖项和生成方法告诉make"><a href="#怎样把依赖项和生成方法告诉make" class="headerlink" title="怎样把依赖项和生成方法告诉make"></a>怎样把依赖项和生成方法告诉make</h1><pre><code>所有目标,依赖项和生成方法的细节信息需要保存在一个叫makefile或Makefile的文件中
拿加密的例子说:
最终的加密程序db由encrypt.o和db.o文件链接组成,这两个文件是由C文件和头文件编译而成,db.o依赖encrypt.h文件,因为db.o需要调用encrypt.c中的函数
db.o: db.c encrypt.c encrypt.h
    gcc -c db.c

encrypt.o: encrypt.c encrypt.h
    gcc -c encrypt.c

db: db.o encrypt.o
    gcc db.o encrypt.o -o db
</code></pre><h1 id="创建makefile很麻烦"><a href="#创建makefile很麻烦" class="headerlink" title="创建makefile很麻烦"></a>创建makefile很麻烦</h1><pre><code>使用autoconf来自动生成makefile
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="为什么要使用声明与定义分离-它解决了什么问题"><a href="#为什么要使用声明与定义分离-它解决了什么问题" class="headerlink" title="为什么要使用声明与定义分离,它解决了什么问题"></a>为什么要使用声明与定义分离,它解决了什么]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[C语言标准输入标准输出]]></title>
    <link href="http://www.cxyteam.com/2016/07/22/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA/"/>
    <id>http://www.cxyteam.com/2016/07/22/C语言标准输入标准输出/</id>
    <published>2016-07-21T23:51:22.000Z</published>
    <updated>2016-07-22T08:58:58.000Z</updated>
    <content type="html"><![CDATA[<h1 id="标准输入"><a href="#标准输入" class="headerlink" title="标准输入"></a>标准输入</h1><pre><code>将键盘或终端其他设备的输入存储的位置(自己理解瞎定义的),一般使用&apos;&lt;&apos;操作符告诉操作系统,标准输入的来源,默认情况下从键盘和终端读取数据
eg:./demo &lt; input.txt 表示运行demo程序的数据来源是input.txt文件
</code></pre><h1 id="标准输出"><a href="#标准输出" class="headerlink" title="标准输出"></a>标准输出</h1><pre><code>将显示在屏幕的输出存储的位置(自己理解瞎定义的),一般使用&apos;&gt;&apos;操作符告诉操作系统,标准输出的位置,默认情况下会发送到显示器
eg:./demo &gt; output.txt 表示运行demo程序产生的结果输出到output.txt文件
</code></pre><h1 id="为什么要使用标准输入-标准输出"><a href="#为什么要使用标准输入-标准输出" class="headerlink" title="为什么要使用标准输入,标准输出?"></a>为什么要使用标准输入,标准输出?</h1><pre><code>因为一旦有了标准输入,标准输出,就可以重定向标准输入,标准输出,让程序从键盘以外的地方读取数据,往显示器以外的地方写数据
</code></pre><h1 id="标准输入与标准输出的实例"><a href="#标准输入与标准输出的实例" class="headerlink" title="标准输入与标准输出的实例"></a>标准输入与标准输出的实例</h1><pre><code>#include &lt;stdio.h&gt;

int main()
{
    float latitude;
    float longitude;
    char info[80];

    int started=0;
    puts(&quot;data=[&quot;);
    while (scanf(&quot;%f,%f,%79[^\n]&quot;, &amp;latitude, &amp;longitude, info) == 3) {
        if (started) {
            printf(&quot;,\n&quot;);
        } else {
            started = 1;
        }
        printf(&quot;{latitude:%f, longitude:%f, info:&apos;%s&apos;}&quot;, latitude, longitude, info);
    }
    puts(&quot;\n]&quot;);

    return 0;
}

input.txt内容为:
    12.12,22.33,speed=21
    33.33,45.21,speed=24
    12.44,55.32,seppd=44
    11.55,44.33,speed=22
    423.63182,-71.095833,speed=22
    28.345,-74.232,speed=44

以上程序在tool.c的文件中,gcc tool.c -o tool &amp;&amp; ./tool &lt; input.txt &gt; output.txt
程序的标准输入是input.txt文件,标准输出到了output.txt文件
</code></pre><h1 id="如果程序出错了如何看到结果"><a href="#如果程序出错了如何看到结果" class="headerlink" title="如果程序出错了如何看到结果?"></a>如果程序出错了如何看到结果?</h1><pre><code>程序执行完之后再终端输入:echo $?
如果返回结果是0代表正常执行,如果返回结果是其他值,就是程序中报错的值(main函数正常返回0)
</code></pre><h1 id="如果其中一条数据出错了怎么办-终止程序的运行-错误的信息也写入到了output-txt"><a href="#如果其中一条数据出错了怎么办-终止程序的运行-错误的信息也写入到了output-txt" class="headerlink" title="如果其中一条数据出错了怎么办?终止程序的运行,错误的信息也写入到了output.txt?"></a>如果其中一条数据出错了怎么办?终止程序的运行,错误的信息也写入到了output.txt?</h1><pre><code>我们需要将正常输出和异常输出分开来
</code></pre><h1 id="标准错误"><a href="#标准错误" class="headerlink" title="标准错误"></a>标准错误</h1><pre><code>将错误的信息输出的位置,一般使用fprintf(stderr,msg)进行输出
例子:
    #include &lt;stdio.h&gt;

    int main()
    {
        float latitude;
        float longitude;
        char info[80];
        int started = 0;

        puts(&quot;data=[&quot;);
        while (scanf(&quot;%f,%f,%79[^\n]&quot;, &amp;latitude, &amp;longitude, info) == 3) {
            if (started) {
                printf(&quot;,\n&quot;);
            } else {
                started = 1;
            }

            if ((latitude &lt; -90.0) || (latitude &gt; 90.0)) {
                fprintf(stderr, &quot;Invoid latitude : %f\n&quot;, latitude);
                return 2;
            }

            if ((longitude &lt; -180.0) || (longitude &gt; 180.0)) {
                fprintf(stderr, &quot;Invoid latitude : %f\n&quot;, latitude);
                return 2;
            }

            printf(&quot;{latitude:%f, longitude:%f, info:&apos;%s&apos;}&quot;, latitude, longitude, info);
        }
        puts(&quot;\n]&quot;);
        return 0;
    }

    以上程序在tool.c的文件中,gcc tool.c -o tool &amp;&amp; ./tool &lt; input.txt &gt; output.txt
    程序的标准输入是input.txt文件,标准输出到了output.txt文件,标准错误输出到了终端的显示界面上
</code></pre><h1 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h1><pre><code>将一个进程的标准输出与另一个进程的标准输入连接起来。用符号&apos;|&apos;表示

一个例子:
    #include &lt;stdio.h&gt;

    int main()
    {
        float latitude;
        float longitude;
        char info[80];
        while(scanf(&quot;%f, %f, %79[^\n]&quot;, &amp;latitude, &amp;longitude, info) == 3) {
            if ((latitude &gt; 26) &amp;&amp; (latitude &lt; 34)) {
                if ((longitude &gt; -76) &amp;&amp; (longitude &lt; -64)) {
                    printf(&quot;%f, %f, %s\n&quot;, latitude, longitude, info);
                }
            }
        }

        return 0;
    }

    以上程序在filter.c的文件中,gcc filter.c -o filter &amp;&amp; (./filter | ./tool &lt; input.txt &gt; output.txt
    程序的标准输入是input.txt文件,标准输出到了output.txt文件,标准错误输出到了终端的显示界面上
</code></pre><h1 id="如果我需要把数据进行分类输出到多个文件中呢-标准输出和标准错误输出只有两种形式-满足不了需求怎么办"><a href="#如果我需要把数据进行分类输出到多个文件中呢-标准输出和标准错误输出只有两种形式-满足不了需求怎么办" class="headerlink" title="如果我需要把数据进行分类输出到多个文件中呢?标准输出和标准错误输出只有两种形式,满足不了需求怎么办?"></a>如果我需要把数据进行分类输出到多个文件中呢?标准输出和标准错误输出只有两种形式,满足不了需求怎么办?</h1><pre><code>需要在程序运行时创建自己的数据流
</code></pre><h1 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h1><pre><code>FILE *in_file = fopen(&quot;input.txt&quot;, &quot;r&quot;);
fscanf(in_file, &quot;%79[^\n]\n&quot;, demo);
</code></pre><h1 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h1><pre><code>FILE *out_file = fopen(&quot;output.txt&quot;, &quot;w&quot;);
fprintf(out_file, &quot;this is %s&quot;, &quot;demo&quot;);
</code></pre><h1 id="关闭数据流"><a href="#关闭数据流" class="headerlink" title="关闭数据流"></a>关闭数据流</h1><pre><code>fclose(in_file);
fclose(out_file);
</code></pre><h1 id="创建数据流例子"><a href="#创建数据流例子" class="headerlink" title="创建数据流例子"></a>创建数据流例子</h1><pre><code>以下是file.c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

/*
    argc代表传入函数main的参数的个数
    argv表示实际的参数数组
*/
int main(int argc, char *argv[])
{
    char line[80];

    /*
        argc第0个参数是函数名,所以一共有6个参数
    */
    if (argc != 6) {
        fprintf(stderr, &quot;you need to give 5 arguments\n&quot;);
        return 1;
    }

    /*
        注意:一定要是双引号,写别的语言惹的祸
    */
    FILE *in = fopen(&quot;spooky.csv&quot;, &quot;r&quot;);
    FILE *file1 = fopen(argv[2], &quot;w&quot;);
    FILE *file2 = fopen(argv[4], &quot;w&quot;);
    FILE *file3 = fopen(argv[5], &quot;w&quot;);
    /*
        用fscanf读取自定义数据流
    */
    while(fscanf(in, &quot;%79[^\n]\n&quot;, line) == 1) {
        if (strstr(line, argv[1])) {
            /*
                用fprintf输出自定义数据流
            */
            fprintf(file1, &quot;%s\n&quot;, line);
        } else if (strstr(line, argv[3])) {
            fprintf(file2, &quot;%s\n&quot;, line);
        } else {
            fprintf(file3, &quot;%s\n&quot;, line);
        }
    }

    fclose(file1);
    fclose(file2);
    fclose(file3);
    return 0;
}

以下是spooky.csv

30.453,-68.1212,Type=Yeti
28.2342,-74.1212,Type=UFO
29.303.-71.1323,Type=Ship
28.1212,-62.2342,Type=Elvis
27.1313,-68.1212,Type=Goatsucker
30.12123,-73.12132,Type=Disappearance
26.121,-71.123213,Type=UFO
29.12,-66.1212,Type=Ship
37.234,-69.23424,Type=Elvis
22.234,-68.23424,Type=Elvis
27.234,-87.23424,Type=Elvis

运行:gcc file.c -o file &amp;&amp; ./file UFO aliens.txt Elvis elviss.txt the_rest.txt
会得到多个自定义的输出流:aliens.txt,elviss.txt


# 函数参数的传入太过复杂,该如何处理呢?
    使用unistd.h替代函数参数的处理

# 函数参数处理的例子
    #include &lt;stdio.h&gt;
    #include &lt;unistd.h&gt;

    /*
        argc代表传入函数main的参数的个数
        argv表示实际的参数数组
    */
    int main(int argc, char *argv[])
    {
        char *delivery = &quot;&quot;;
        int thick = 0;
        int count = 0;
        char ch;

        while((ch = getopt(argc, argv, &quot;d:t&quot;)) != EOF) {
            switch(ch) {
                case &apos;d&apos;:
                    delivery = optarg;
                    break;
                case &apos;t&apos;:
                    thick = 1;
                    break;
                default:
                    fprintf(stderr, &quot;Unknow option: &apos;%s&apos;\n&quot;, optarg);
                    return 1;
            }
        }

        argc -= optind;
        argv += optind;

        if (thick) {
            puts(&quot;thick crust&quot;);
        }

        if (delivery[0]) {
            printf(&quot;to be delivered %s.\n&quot;, delivery);
        }

        puts(&quot;Ingredients:&quot;);
        for(count = 0; count&lt;argc;count++) {
            puts(argv[count]);
        }
        return 0;
    }

    gcc unistd.c -o unistd
    ./unistd Anchovies Pineapple
    ./unistd -d now Anchovies Pineapple
    ./unistd -d now -t Anchovies Pineapple
    ./unistd -f
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="标准输入"><a href="#标准输入" class="headerlink" title="标准输入"></a>标准输入</h1><pre><code>将键盘或终端其他设备的输入存储的位置(自己理解瞎定义的),一般使用&apos;&lt;&apos;操作符告诉]]>
    </summary>
    
      <category term="C" scheme="http://www.cxyteam.com/tags/C/"/>
    
      <category term="C" scheme="http://www.cxyteam.com/categories/C/"/>
    
  </entry>
  
</feed>