<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[狂奔的菜鸟]]></title>
  <subtitle><![CDATA[当你的实力支撑不起你的野心的时候，静下心来好好学习吧！]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.cxyteam.com/"/>
  <updated>2017-03-12T08:46:56.000Z</updated>
  <id>http://www.cxyteam.com/</id>
  
  <author>
    <name><![CDATA[狂奔的菜鸟]]></name>
    <email><![CDATA[phpchengxuyuan@sina.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[go学习笔记并发-channel]]></title>
    <link href="http://www.cxyteam.com/2017/03/08/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%B9%B6%E5%8F%91-channel/"/>
    <id>http://www.cxyteam.com/2017/03/08/go学习笔记并发-channel/</id>
    <published>2017-03-08T12:43:15.000Z</published>
    <updated>2017-03-12T08:46:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="引用类型channel是CSP模式的具体实现，用于多个goroutine通讯。其内部实现了同步没确保并发安全，默认为同步模式，需要发送和接收配对。否则会被阻塞，直到另一方准备好被唤醒"><a href="#引用类型channel是CSP模式的具体实现，用于多个goroutine通讯。其内部实现了同步没确保并发安全，默认为同步模式，需要发送和接收配对。否则会被阻塞，直到另一方准备好被唤醒" class="headerlink" title="引用类型channel是CSP模式的具体实现，用于多个goroutine通讯。其内部实现了同步没确保并发安全，默认为同步模式，需要发送和接收配对。否则会被阻塞，直到另一方准备好被唤醒"></a>引用类型channel是CSP模式的具体实现，用于多个goroutine通讯。其内部实现了同步没确保并发安全，默认为同步模式，需要发送和接收配对。否则会被阻塞，直到另一方准备好被唤醒</h6><pre><code>package main

import (
    &quot;fmt&quot;
)

func main() {
    data := make(chan int)      //数据交换队列
    exit := make(chan bool)     //退出通知

    go func() {
        for d := range data {   //从队列迭代接收数据，直到close
            fmt.Println(d)
        }

        fmt.Println(&quot;recv over.&quot;)
        exit &lt;- true            //发送退出通知
    }()

    data &lt;- 1                   //发送数据
    data &lt;- 2
    data &lt;- 3
    close(data)                 //关闭队列

    fmt.Println(&quot;send over.&quot;)
    &lt;-exit                      //等待退出通知
}
</code></pre><h6 id="异步方式通过判断缓冲区来觉得是否阻塞，如果缓冲区已满，发送被阻塞；缓冲区为空，接收被阻塞"><a href="#异步方式通过判断缓冲区来觉得是否阻塞，如果缓冲区已满，发送被阻塞；缓冲区为空，接收被阻塞" class="headerlink" title="异步方式通过判断缓冲区来觉得是否阻塞，如果缓冲区已满，发送被阻塞；缓冲区为空，接收被阻塞"></a>异步方式通过判断缓冲区来觉得是否阻塞，如果缓冲区已满，发送被阻塞；缓冲区为空，接收被阻塞</h6><pre><code>package main

import (
    &quot;fmt&quot;
)

func main() {
    data := make(chan int, 3)
    exit := make(chan bool)
    data &lt;- 1
    data &lt;- 2
    data &lt;- 3
    go func() {
        for d := range data {
            fmt.Println(d)
        }

        exit &lt;- true
    }()

    data &lt;- 4
    data &lt;- 5
    close(data)

    &lt;- exit
}
</code></pre><h6 id="可以将channel隐士转换为单向队列，只收或只发"><a href="#可以将channel隐士转换为单向队列，只收或只发" class="headerlink" title="可以将channel隐士转换为单向队列，只收或只发"></a>可以将channel隐士转换为单向队列，只收或只发</h6><pre><code>package main

import (
)

func main() {
    c := make(chan int, 3)
    var send chan &lt;- int = c
    var recv &lt;- chan int = c
    send &lt;- 1
    //&lt;- send           //receive from send-only type chan&lt;- int
    //recv &lt;- 2         //send to receive-only type &lt;-chan int
    &lt;- recv
}
</code></pre><h6 id="如果同时处理多个channel，可使用select语句，它随机选择一个可用channel做收发操作，或执行default-case"><a href="#如果同时处理多个channel，可使用select语句，它随机选择一个可用channel做收发操作，或执行default-case" class="headerlink" title="如果同时处理多个channel，可使用select语句，它随机选择一个可用channel做收发操作，或执行default case"></a>如果同时处理多个channel，可使用select语句，它随机选择一个可用channel做收发操作，或执行default case</h6>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="引用类型channel是CSP模式的具体实现，用于多个goroutine通讯。其内部实现了同步没确保并发安全，默认为同步模式，需要]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记并发]]></title>
    <link href="http://www.cxyteam.com/2017/03/03/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%B9%B6%E5%8F%91/"/>
    <id>http://www.cxyteam.com/2017/03/03/go学习笔记并发/</id>
    <published>2017-03-03T10:47:39.000Z</published>
    <updated>2017-03-08T12:42:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="只需在函数调用语句前添加go关键字，就可创建并发执行单元"><a href="#只需在函数调用语句前添加go关键字，就可创建并发执行单元" class="headerlink" title="只需在函数调用语句前添加go关键字，就可创建并发执行单元"></a>只需在函数调用语句前添加go关键字，就可创建并发执行单元</h6><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;runtime&quot;
)

func say(s string) {
    for i := 0; i &lt; 3; i++ {
        runtime.Gosched()
        fmt.Println(s) }
    }

func main() {
    go say(&quot;world&quot;)     //开一个新的Goroutines执行
    say(&quot;hello&quot;)        //当前Goroutines执行
}
</code></pre><h6 id="Goexit-退出当前执行的goroutine，但是defer函数还会继续调用"><a href="#Goexit-退出当前执行的goroutine，但是defer函数还会继续调用" class="headerlink" title="Goexit 退出当前执行的goroutine，但是defer函数还会继续调用"></a>Goexit 退出当前执行的goroutine，但是defer函数还会继续调用</h6><h6 id="NumCPU-返回CPU核数量"><a href="#NumCPU-返回CPU核数量" class="headerlink" title="NumCPU 返回CPU核数量"></a>NumCPU 返回CPU核数量</h6><h6 id="NumGoroutine-返回正在执行和排队的任务总数"><a href="#NumGoroutine-返回正在执行和排队的任务总数" class="headerlink" title="NumGoroutine 返回正在执行和排队的任务总数"></a>NumGoroutine 返回正在执行和排队的任务总数</h6><h6 id="GOMAXPROCS-用来设置可以运行的CPU核数"><a href="#GOMAXPROCS-用来设置可以运行的CPU核数" class="headerlink" title="GOMAXPROCS 用来设置可以运行的CPU核数"></a>GOMAXPROCS 用来设置可以运行的CPU核数</h6><h6 id="sync-WaitGroup-它能够一直等到所有的goroutine执行完成，并且阻塞主线程的执行，直到所有的goroutine执行完成"><a href="#sync-WaitGroup-它能够一直等到所有的goroutine执行完成，并且阻塞主线程的执行，直到所有的goroutine执行完成" class="headerlink" title="sync.WaitGroup 它能够一直等到所有的goroutine执行完成，并且阻塞主线程的执行，直到所有的goroutine执行完成"></a>sync.WaitGroup 它能够一直等到所有的goroutine执行完成，并且阻塞主线程的执行，直到所有的goroutine执行完成</h6><h6 id="Add-添加或者减少等待goroutine的数量"><a href="#Add-添加或者减少等待goroutine的数量" class="headerlink" title="Add 添加或者减少等待goroutine的数量"></a>Add 添加或者减少等待goroutine的数量</h6><h6 id="Done-相当于Add-1"><a href="#Done-相当于Add-1" class="headerlink" title="Done 相当于Add(-1)"></a>Done 相当于Add(-1)</h6><h6 id="Wait-执行阻塞，直到所有的WaitGroup数量变成0"><a href="#Wait-执行阻塞，直到所有的WaitGroup数量变成0" class="headerlink" title="Wait 执行阻塞，直到所有的WaitGroup数量变成0"></a>Wait 执行阻塞，直到所有的WaitGroup数量变成0</h6><pre><code>package main

import (
    &quot;runtime&quot;
    &quot;sync&quot;
)

func main() {
    wg := new(sync.WaitGroup)
    wg.Add(1)

    go func() {
        defer wg.Done()
        defer println(&quot;A.defer&quot;)

        func() {
            defer println(&quot;B.defer&quot;)
            runtime.Goexit()
            println(&quot;B&quot;)
        }()

        println(&quot;A&quot;)
    }()
    wg.Wait()
}
</code></pre><h6 id="Gosched-让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行"><a href="#Gosched-让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行" class="headerlink" title="Gosched 让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行"></a>Gosched 让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行</h6><pre><code>package main

import (
    &quot;runtime&quot;
    &quot;sync&quot;
)

func main() {
    //它能够一直等到所有的goroutine执行完成，并且阻塞主线程的执行，直到所有的goroutine执行完成
    wg := new(sync.WaitGroup)
    //添加或者减少等待goroutine的数量
    wg.Add(2)

    go func() {
        //相当于Add(-1)
        defer wg.Done()

        for i := 0; i &lt; 6; i++ {
            println(i)
            if i == 3 { runtime.Gosched() }
        }
    }()

    go func() {
        defer wg.Done()
        println(&quot;hello,world!&quot;)
    }()

    //执行阻塞，直到所有的WaitGroup数量变成0
    wg.Wait()
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="只需在函数调用语句前添加go关键字，就可创建并发执行单元"><a href="#只需在函数调用语句前添加go关键字，就可创建并发执]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记接口]]></title>
    <link href="http://www.cxyteam.com/2017/03/01/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8E%A5%E5%8F%A3/"/>
    <id>http://www.cxyteam.com/2017/03/01/go学习笔记接口/</id>
    <published>2017-03-01T07:06:44.000Z</published>
    <updated>2017-03-01T12:05:45.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="接口定义一个或多个方法签名的集合，任何类型的方法集中只要拥有与之对应的全部方法就表示它’实现’了该接口，无须在该类型上显示添加接口声明"><a href="#接口定义一个或多个方法签名的集合，任何类型的方法集中只要拥有与之对应的全部方法就表示它’实现’了该接口，无须在该类型上显示添加接口声明" class="headerlink" title="接口定义一个或多个方法签名的集合，任何类型的方法集中只要拥有与之对应的全部方法就表示它’实现’了该接口，无须在该类型上显示添加接口声明"></a>接口定义一个或多个方法签名的集合，任何类型的方法集中只要拥有与之对应的全部方法就表示它’实现’了该接口，无须在该类型上显示添加接口声明</h6><h6 id="所谓接口对应方法，是指有相同名称，参数列表以及返回值。"><a href="#所谓接口对应方法，是指有相同名称，参数列表以及返回值。" class="headerlink" title="所谓接口对应方法，是指有相同名称，参数列表以及返回值。"></a>所谓接口对应方法，是指有相同名称，参数列表以及返回值。</h6><h6 id="接口命名习惯以er结尾，结构体"><a href="#接口命名习惯以er结尾，结构体" class="headerlink" title="接口命名习惯以er结尾，结构体"></a>接口命名习惯以er结尾，结构体</h6><h6 id="接口只有方法签名，没有实现"><a href="#接口只有方法签名，没有实现" class="headerlink" title="接口只有方法签名，没有实现"></a>接口只有方法签名，没有实现</h6><h6 id="接口没有数据字段"><a href="#接口没有数据字段" class="headerlink" title="接口没有数据字段"></a>接口没有数据字段</h6><h6 id="可在接口中嵌入其他接口"><a href="#可在接口中嵌入其他接口" class="headerlink" title="可在接口中嵌入其他接口"></a>可在接口中嵌入其他接口</h6><h6 id="类型可实现多个接口"><a href="#类型可实现多个接口" class="headerlink" title="类型可实现多个接口"></a>类型可实现多个接口</h6><pre><code>package main

import &quot;fmt&quot;

type Stringer interface {
    String() string         //定义了一个接口
}

type Printer interface {
    Stringer                //嵌套接口
    Print()
}

type User struct {
    id      int
    name    string
}

func (self *User) String() string {
    return fmt.Sprintf(&quot;user %d, %s&quot;, self.id, self.name)
}

func (self *User) Print() {
    fmt.Println(self.String())
}

func main() {
    var t Printer = &amp;User{1, &quot;Tom&quot;}
    t.Print()       //user 1, Tom
}
</code></pre><h6 id="空接口interface-没有任何方法签名，也就意味着任何类型都实现了空接口。"><a href="#空接口interface-没有任何方法签名，也就意味着任何类型都实现了空接口。" class="headerlink" title="空接口interface{}没有任何方法签名，也就意味着任何类型都实现了空接口。"></a>空接口interface{}没有任何方法签名，也就意味着任何类型都实现了空接口。</h6><pre><code>package main

import &quot;fmt&quot;

func Print(v interface{}) {
    fmt.Printf(&quot;%T,%v\n&quot;, v, v)
}

func main() {
    Print(1)                    //int,1
    Print(&quot;Hello, world!&quot;)      //string,Hello, world!
}
</code></pre><h6 id="匿名接口可用作变量类型或结构成员"><a href="#匿名接口可用作变量类型或结构成员" class="headerlink" title="匿名接口可用作变量类型或结构成员"></a>匿名接口可用作变量类型或结构成员</h6><pre><code>package main

import &quot;fmt&quot;

type Tester struct {
    s interface {
        String() string
    }
}

type User struct {
    id      int
    name    string
}

func (self *User) String() string {
    return fmt.Sprintf(&quot;User %d, %s&quot;, self.id, self.name)
}

func main() {
    t := Tester{&amp;User{1, &quot;Tom&quot;}}
    fmt.Println(t.s.String())
}
</code></pre><h6 id="数据指针持有的是目标对象的只读复制品，赋值完整对象或指针"><a href="#数据指针持有的是目标对象的只读复制品，赋值完整对象或指针" class="headerlink" title="数据指针持有的是目标对象的只读复制品，赋值完整对象或指针"></a>数据指针持有的是目标对象的只读复制品，赋值完整对象或指针</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id      int
    name    string
}

func main() {
    u := User{1, &quot;Tom&quot;}
    var i interface{} = u

    u.id = 2
    u.name = &quot;jack&quot;

    fmt.Printf(&quot;%v\n&quot;, u)           //{2 jack}
    fmt.Printf(&quot;%v\n&quot;, i.(User))    //{1 Tom}
}
</code></pre><h6 id="接口转型返回临时对象，只有使用指针才能修改其状态"><a href="#接口转型返回临时对象，只有使用指针才能修改其状态" class="headerlink" title="接口转型返回临时对象，只有使用指针才能修改其状态"></a>接口转型返回临时对象，只有使用指针才能修改其状态</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id      int
    name    string
}

func main() {
    u := User{1, &quot;Tom&quot;}
    var vi,pi interface{} = u, &amp;u

    //vi.(User).name = &quot;jim&quot;    //报错，不能这样修改值
    pi.(*User).name = &quot;Jack&quot;


    fmt.Printf(&quot;%v\n&quot;, vi.(User))     //{1 Tom}
    fmt.Printf(&quot;%v\n&quot;, pi.(*User))    //&amp;{1 Jack}
}
</code></pre><h6 id="利用类型推断，可判断接口对象是否某个具体的接口或类型"><a href="#利用类型推断，可判断接口对象是否某个具体的接口或类型" class="headerlink" title="利用类型推断，可判断接口对象是否某个具体的接口或类型"></a>利用类型推断，可判断接口对象是否某个具体的接口或类型</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id      int
    name    string
}

func (self *User) String() string {
    return fmt.Sprintf(&quot;%d, %s&quot;, self.id, self.name)
}

func main() {
    var o interface{} = &amp;User{1, &quot;Tom&quot;}

    if i,ok := o.(fmt.Stringer); ok {
        fmt.Println(i)      //1, Tom
    }


    u := o.(*User)
    //u := o.(User)         //报错
    fmt.Println(u)          //1, Tom
}
</code></pre><h6 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id      int
    name    string
}


func main() {
    var o interface{} = &amp;User{1, &quot;Tom&quot;}

    switch v := o.(type) {
    case nil :                  //nil类型
        fmt.Println(&quot;nil&quot;)
    case fmt.Stringer:          //interface
        fmt.Println(v)
    case func() string:         //func
        fmt.Println(v())
    case *User:
        fmt.Printf(&quot;%d, %s\n&quot;, v.id, v.name)
    default:
        fmt.Println(&quot;unknow&quot;)
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="接口定义一个或多个方法签名的集合，任何类型的方法集中只要拥有与之对应的全部方法就表示它’实现’了该接口，无须在该类型上显示添加接口]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记方法表达式]]></title>
    <link href="http://www.cxyteam.com/2017/03/01/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://www.cxyteam.com/2017/03/01/go学习笔记方法表达式/</id>
    <published>2017-03-01T03:23:27.000Z</published>
    <updated>2017-03-01T12:05:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h6 id="instance-method-args…-gt-method-value"><a href="#instance-method-args…-gt-method-value" class="headerlink" title="instance.method(args…) =&gt; method value"></a>instance.method(args…) =&gt; method value</h6><h6 id="func-instance-args-gt-method-expression"><a href="#func-instance-args-gt-method-expression" class="headerlink" title=".func(instance, args)  =&gt; method expression"></a><type>.func(instance, args)  =&gt; method expression</type></h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id      int
    name    string
}

func (self *User) Test() {
    fmt.Printf(&quot;%p, %v\n&quot;, self, self)
}

func main() {
    u := User{1, &quot;Tom&quot;}
    u.Test()        //0xc42000e1e0, &amp;{1 Tom}

    mValue := u.Test
    mValue()        //0xc42000e1e0, &amp;{1 Tom} 隐式传递receiver

    mExpression := (*User).Test
    mExpression(&amp;u) //0xc42000e1e0, &amp;{1 Tom} 显示传递receiver
}
</code></pre><h6 id="method-value会复制receiver"><a href="#method-value会复制receiver" class="headerlink" title="method value会复制receiver"></a>method value会复制receiver</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id      int
    name    string
}

func (self User) Test() {
    fmt.Println(self)
}

func main() {
    u := User{1, &quot;Tom&quot;}
    mValue := u.Test

    u.id, u.name = 2, &quot;Jack&quot;
    u.Test()        //{2 Jack}
    mValue()        //{1 Tom}
}
</code></pre><h6 id="注意receiver类型差异"><a href="#注意receiver类型差异" class="headerlink" title="注意receiver类型差异"></a>注意receiver类型差异</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id      int
    name    string
}

func (self *User) TestPointer() {
    fmt.Printf(&quot;TestPointer:%p, %v\n&quot;, self, self)
}

func (self User) TestValue() {
    fmt.Printf(&quot;TestValue:%p, %v\n&quot;, &amp;self, self)
}

func main() {
    u := User{1, &quot;Tom&quot;}
    m := User.TestValue
    m(u)        //TestValue:0xc42000e200, {1 Tom}

    a := (*User).TestPointer
    a(&amp;u)       //TestPointer:0xc42000e1e0, &amp;{1 Tom}

    b := (*User).TestValue  //*User方法集包含TestValue，前面变为func TestValue(self *User) 事迹依然是receiver value copy
    b(&amp;u)       //TestValue:0xc42000e280, {1 Tom}
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h6 id="instance-method-args…-gt-method-value"><a href="#instance-met]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记方法集]]></title>
    <link href="http://www.cxyteam.com/2017/03/01/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95%E9%9B%86/"/>
    <id>http://www.cxyteam.com/2017/03/01/go学习笔记方法集/</id>
    <published>2017-03-01T03:17:08.000Z</published>
    <updated>2017-03-01T12:06:01.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="类型T方法集包含全部receiver-T方法"><a href="#类型T方法集包含全部receiver-T方法" class="headerlink" title="类型T方法集包含全部receiver T方法"></a>类型T方法集包含全部receiver T方法</h6><h6 id="类型T方法集合包含全部receiver-T-T方法"><a href="#类型T方法集合包含全部receiver-T-T方法" class="headerlink" title="类型T方法集合包含全部receiver T+T方法"></a>类型<em>T方法集合包含全部receiver T+</em>T方法</h6><h6 id="如类型S包含匿名字段T，则S方法集包含T方法"><a href="#如类型S包含匿名字段T，则S方法集包含T方法" class="headerlink" title="如类型S包含匿名字段T，则S方法集包含T方法"></a>如类型S包含匿名字段T，则S方法集包含T方法</h6><h6 id="如类型S包含匿名字段T，则S方法集包含T-T方法"><a href="#如类型S包含匿名字段T，则S方法集包含T-T方法" class="headerlink" title="如类型S包含匿名字段T，则S方法集包含T+T方法"></a>如类型S包含匿名字段<em>T，则S方法集包含T+</em>T方法</h6><h6 id="不管嵌入T或T，S方法集总是包含T-T方法"><a href="#不管嵌入T或T，S方法集总是包含T-T方法" class="headerlink" title="不管嵌入T或T，S方法集总是包含T+*T方法"></a>不管嵌入T或<em>T，</em>S方法集总是包含T+*T方法</h6>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="类型T方法集包含全部receiver-T方法"><a href="#类型T方法集包含全部receiver-T方法" class="]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记方法定义]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记方法定义/</id>
    <published>2017-02-28T12:30:49.000Z</published>
    <updated>2017-03-01T12:05:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="方法总是绑定对象实例，并隐式将实例作为第一实参"><a href="#方法总是绑定对象实例，并隐式将实例作为第一实参" class="headerlink" title="方法总是绑定对象实例，并隐式将实例作为第一实参"></a>方法总是绑定对象实例，并隐式将实例作为第一实参</h6><h6 id="只能为当前包内命名类型定义方法"><a href="#只能为当前包内命名类型定义方法" class="headerlink" title="只能为当前包内命名类型定义方法"></a>只能为当前包内命名类型定义方法</h6><h6 id="参数receiver可任意命名。如方法中未曾使用，可省略参数名"><a href="#参数receiver可任意命名。如方法中未曾使用，可省略参数名" class="headerlink" title="参数receiver可任意命名。如方法中未曾使用，可省略参数名"></a>参数receiver可任意命名。如方法中未曾使用，可省略参数名</h6><h6 id="参数receiver类型可以使T（值复制）或-T（引用或指针复制）。基类型T不能是接口或指针"><a href="#参数receiver类型可以使T（值复制）或-T（引用或指针复制）。基类型T不能是接口或指针" class="headerlink" title="参数receiver类型可以使T（值复制）或*T（引用或指针复制）。基类型T不能是接口或指针"></a>参数receiver类型可以使T（值复制）或*T（引用或指针复制）。基类型T不能是接口或指针</h6><h6 id="不支持方法重载，receiver只是参数签名的组成部分"><a href="#不支持方法重载，receiver只是参数签名的组成部分" class="headerlink" title="不支持方法重载，receiver只是参数签名的组成部分"></a>不支持方法重载，receiver只是参数签名的组成部分</h6><h6 id="可用实例value或pointer调用全部方法，编译器自动转换"><a href="#可用实例value或pointer调用全部方法，编译器自动转换" class="headerlink" title="可用实例value或pointer调用全部方法，编译器自动转换"></a>可用实例value或pointer调用全部方法，编译器自动转换</h6><h6 id="简单工厂模式返回对象事例（然而我没看懂）"><a href="#简单工厂模式返回对象事例（然而我没看懂）" class="headerlink" title="简单工厂模式返回对象事例（然而我没看懂）"></a>简单工厂模式返回对象事例（然而我没看懂）</h6><pre><code>package main

import &quot;fmt&quot;

type Queue struct {
    elements []interface{}
}

func NewQueue() *Queue {
    return &amp;Queue{make([]interface{}, 10)}
}

func (*Queue) Push(e interface{}) error {
    panic(&quot;not implemented&quot;)
}

func (self *Queue) length() int {
    return len(self.elements)
}
</code></pre><h6 id="看看receiver-T和-T的区别"><a href="#看看receiver-T和-T的区别" class="headerlink" title="看看receiver T和*T的区别"></a>看看receiver T和*T的区别</h6><pre><code>package main

import &quot;fmt&quot;

type Data struct {
    x int
}

func (self Data) ValueTest() {
    fmt.Printf(&quot;Value:%p\n&quot;, &amp;self)
}

func (self *Data) PointerTest() {
    fmt.Printf(&quot;Pointer:%p\n&quot;, self)
}

func main() {
    d := Data{}
    p := &amp;d
    fmt.Printf(&quot;Data:%p\n&quot;, p)

    d.ValueTest()
    d.PointerTest()

    p.ValueTest()
    p.PointerTest()
}
</code></pre><h6 id="匿名字段，可以像字段成员那样访问匿名字段方法，编译器负责查找"><a href="#匿名字段，可以像字段成员那样访问匿名字段方法，编译器负责查找" class="headerlink" title="匿名字段，可以像字段成员那样访问匿名字段方法，编译器负责查找"></a>匿名字段，可以像字段成员那样访问匿名字段方法，编译器负责查找</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id      int
    name    string
}

type Manager struct {
    User
}

func (self *User) Tostring() string {   //receiver = &amp;(Manager.User)
    return fmt.Sprintf(&quot;User:%p, %v&quot;, self, self)
}

func main() {
    m := Manager{User{1, &quot;Tom&quot;}}
    fmt.Printf(&quot;Manager:%p\n&quot;, &amp;m)      //Manager:0xc42007e060
    fmt.Println(m.Tostring())           //User:0xc42000e1a0, &amp;{1 Tom}
}
</code></pre><h6 id="通过匿名字段，可获得和继承类似的复用能力。依据编译器查找次序，只需在外层定义同名方法，就可以实现”override”"><a href="#通过匿名字段，可获得和继承类似的复用能力。依据编译器查找次序，只需在外层定义同名方法，就可以实现”override”" class="headerlink" title="通过匿名字段，可获得和继承类似的复用能力。依据编译器查找次序，只需在外层定义同名方法，就可以实现”override”"></a>通过匿名字段，可获得和继承类似的复用能力。依据编译器查找次序，只需在外层定义同名方法，就可以实现”override”</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id      int
    name    string
}

type Manager struct {
    User
    title string
}

func (self *User) Tostring() string {   //receiver = &amp;(Manager.User)
    return fmt.Sprintf(&quot;User:%p, %v&quot;, self, self)
}

func (self *Manager) Tostring() string {   //receiver = &amp;(Manager.User)
    return fmt.Sprintf(&quot;Manager:%p, %v&quot;, self, self)
}

func main() {
    m := Manager{User{1, &quot;Tom&quot;}, &quot;admin&quot;}
    fmt.Println(m.Tostring())           //Manager:0xc420014120, &amp;{{1 Tom} admin}
    fmt.Println(m.User.Tostring())      //User:0xc420014120, &amp;{1 Tom}
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="方法总是绑定对象实例，并隐式将实例作为第一实参"><a href="#方法总是绑定对象实例，并隐式将实例作为第一实参" class]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记面向对象]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记面向对象/</id>
    <published>2017-02-28T12:13:38.000Z</published>
    <updated>2017-03-01T12:06:28.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="面向对象三大特征，go仅支持封装。没有class关键字，没有继承，多态等"><a href="#面向对象三大特征，go仅支持封装。没有class关键字，没有继承，多态等" class="headerlink" title="面向对象三大特征，go仅支持封装。没有class关键字，没有继承，多态等"></a>面向对象三大特征，go仅支持封装。没有class关键字，没有继承，多态等</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id int
    name string
}


type Manager struct {
    User
    title string
}

func main() {
    m := Manager{User{1, &quot;Tom&quot;}, &quot;admin&quot;}
    var u User = m.User //同类型拷贝
    //var u User = m  //这个类型不一样，无法拷贝
    fmt.Println(u)
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="面向对象三大特征，go仅支持封装。没有class关键字，没有继承，多态等"><a href="#面向对象三大特征，go仅支持封装。]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记struct]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0struct/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记struct/</id>
    <published>2017-02-28T09:07:11.000Z</published>
    <updated>2017-03-01T12:05:16.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="值类型，赋值和传参会复制全部内容。可用”-”定义补位字段，支持指向自身类型的指针成员"><a href="#值类型，赋值和传参会复制全部内容。可用”-”定义补位字段，支持指向自身类型的指针成员" class="headerlink" title="值类型，赋值和传参会复制全部内容。可用”_”定义补位字段，支持指向自身类型的指针成员"></a>值类型，赋值和传参会复制全部内容。可用”_”定义补位字段，支持指向自身类型的指针成员</h6><pre><code>package main

import &quot;fmt&quot;

type Node struct {
    _       int
    id      int
    data    *byte
    next    *Node
}

func main() {
    n1 := Node{
        id  : 1,
        data: nil,
    }

    n2 := Node{
        id  : 2,
        data: nil,
        next: &amp;n1,
    }

    fmt.Println(n1, n2)
}
</code></pre><h6 id="顺序初始化必须包含全部字段，否则会出错"><a href="#顺序初始化必须包含全部字段，否则会出错" class="headerlink" title="顺序初始化必须包含全部字段，否则会出错"></a>顺序初始化必须包含全部字段，否则会出错</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    name    string
    age     int
}

func main() {
    u1 := User{&quot;Tom&quot;, 20}
    //u2 := User{&quot;Tom&quot;}     //会报错，缺少字段
    fmt.Println(u1)
}
</code></pre><h6 id="支持匿名结构，可用作结构成员或定义变量"><a href="#支持匿名结构，可用作结构成员或定义变量" class="headerlink" title="支持匿名结构，可用作结构成员或定义变量"></a>支持匿名结构，可用作结构成员或定义变量</h6><pre><code>package main

import &quot;fmt&quot;

type File struct {
    name    string
    size     int
    attr struct {
        perm    int
        owner   int
    }
}

func main() {
    f := File{
        name : &quot;test.txt&quot;,
        size : 1024,
        //attr : {0755,1} //这样赋值会报错
    }

    f.attr.owner = 1
    f.attr.perm = 0755

    fmt.Println(f)

    d := File{
        name : &quot;a.txt&quot;,
        size : 512,
    }

    var attr = struct {
        perm int
        owner int
    }{2, 0755}

    d.attr = attr

    fmt.Println(d)
}
</code></pre><h6 id="注意m的赋值方式"><a href="#注意m的赋值方式" class="headerlink" title="注意m的赋值方式"></a>注意m的赋值方式</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id     int
    name    string
}

func main() {
    m := map[User]int{
        User{1, &quot;Tom&quot;} : 100,
    }

    fmt.Println(m)      //100
}
</code></pre><h6 id="匿名字段，其实是一种语法糖，就是一个与成员类型同名的字段，被匿名嵌入的可以使任何类型，当然也包括指针。可以像普通字段那样访问匿名字段成员，编译器从外向内逐级查找所有层次的匿名字段，知道发现目标或出错"><a href="#匿名字段，其实是一种语法糖，就是一个与成员类型同名的字段，被匿名嵌入的可以使任何类型，当然也包括指针。可以像普通字段那样访问匿名字段成员，编译器从外向内逐级查找所有层次的匿名字段，知道发现目标或出错" class="headerlink" title="匿名字段，其实是一种语法糖，就是一个与成员类型同名的字段，被匿名嵌入的可以使任何类型，当然也包括指针。可以像普通字段那样访问匿名字段成员，编译器从外向内逐级查找所有层次的匿名字段，知道发现目标或出错"></a>匿名字段，其实是一种语法糖，就是一个与成员类型同名的字段，被匿名嵌入的可以使任何类型，当然也包括指针。可以像普通字段那样访问匿名字段成员，编译器从外向内逐级查找所有层次的匿名字段，知道发现目标或出错</h6><pre><code>package main

import &quot;fmt&quot;

type Resource struct {
    id int
}


type Manager struct {
    User
    title string
}

type User struct {
    Resource    //匿名字段，相当于引用上面的Resource结构
    name string
}

func main() {
    var m Manager
    m.id = 1
    m.name = &quot;Jack&quot;
    m.title = &quot;Admin&quot;

    fmt.Println(m)      //{{{1} Jack} Admin}
}
</code></pre><h6 id="外层同名字段会遮蔽嵌入字段成员，相同层次的同名字段也会让编译器无所适从，解决方法是使用显示字段名"><a href="#外层同名字段会遮蔽嵌入字段成员，相同层次的同名字段也会让编译器无所适从，解决方法是使用显示字段名" class="headerlink" title="外层同名字段会遮蔽嵌入字段成员，相同层次的同名字段也会让编译器无所适从，解决方法是使用显示字段名"></a>外层同名字段会遮蔽嵌入字段成员，相同层次的同名字段也会让编译器无所适从，解决方法是使用显示字段名</h6><pre><code>package main

import &quot;fmt&quot;

type Resource struct {
    id int
    name string
}


type Classify struct {
    id int
}

type User struct {
    Resource
    Classify
    name string
}

func main() {
    u := User{
        Resource{1, &quot;pepple&quot;},
        Classify{100},
        &quot;Jack&quot;,
    }

    fmt.Println(u)
    fmt.Println(u.name)
    fmt.Println(u.Resource.id)
    fmt.Println(u.Classify.id)
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="值类型，赋值和传参会复制全部内容。可用”-”定义补位字段，支持指向自身类型的指针成员"><a href="#值类型，赋值和传参会复]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记map]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0map/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记map/</id>
    <published>2017-02-28T08:20:07.000Z</published>
    <updated>2017-03-01T12:05:02.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="引用类型，哈希表，键必须是支持相等运算符类型。值可以是任意类型，没有限制"><a href="#引用类型，哈希表，键必须是支持相等运算符类型。值可以是任意类型，没有限制" class="headerlink" title="引用类型，哈希表，键必须是支持相等运算符类型。值可以是任意类型，没有限制"></a>引用类型，哈希表，键必须是支持相等运算符类型。值可以是任意类型，没有限制</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    m := map[int]struct{
        name string
        age int
    }{
        1 : {&quot;user1&quot;, 10},
        2 : {&quot;user2&quot;, 20},
    }

    fmt.Println(m[1].name)
}
</code></pre><h6 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    m := map[string]int{    //判断key是否存在
        &quot;a&quot; : 1,
    }

    if v,ok := m[&quot;a&quot;];ok {
        println(v, ok)      //1 true
    }

    fmt.Println(m[&quot;c&quot;])     //0   对于不存在的key，直接返回\0,不报错
    m[&quot;b&quot;] = 2              //新增或修改
    delete(m, &quot;c&quot;)          //删除，如果key不存在，不会出错
    println(len(m))         //2    获取键值对数量。cap无效

    for k, v := range m {   //迭代，可仅返回key。随机顺序返回，每次都不相同
        println(k, v)       //b 2       a 1
    }
}
</code></pre><h6 id="从map中取回的是一个value临时复制品，对其成员的修改是没有意义的"><a href="#从map中取回的是一个value临时复制品，对其成员的修改是没有意义的" class="headerlink" title="从map中取回的是一个value临时复制品，对其成员的修改是没有意义的"></a>从map中取回的是一个value临时复制品，对其成员的修改是没有意义的</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
   type user struct{ name string }
   m := map[int]user{
        1 : {&quot;user1&quot;},
   }

   fmt.Println(m[1].name)
   //m[1].name = &quot;Tom&quot;     //这样赋值会报错
   u := m[1]
   u.name = &quot;Tom&quot;
   m[1] = u
   fmt.Println(m[1].name)

   m2 := map[int]*user{
        1 : &amp;user{&quot;user1&quot;},
   }
   m2[1].name = &quot;jack&quot;
   fmt.Println(m2[1].name)      //返回的是指针复制品，透过指针修改原对象是允许的
}
</code></pre><h6 id="可以在迭代时安全删除键值-最好不要做新增操作"><a href="#可以在迭代时安全删除键值-最好不要做新增操作" class="headerlink" title="可以在迭代时安全删除键值,最好不要做新增操作"></a>可以在迭代时安全删除键值,最好不要做新增操作</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    for i := 0; i &lt; 5;i++ {
        m := map[int]string{
            0:&quot;a&quot;, 1:&quot;a&quot;, 2:&quot;a&quot;, 3:&quot;a&quot;, 4:&quot;a&quot;,
            5:&quot;a&quot;, 6:&quot;a&quot;, 7:&quot;a&quot;, 8:&quot;a&quot;, 9:&quot;a&quot;,
        }

        for k := range m {
            m[k+k] = &quot;k&quot;
            delete(m, k)
        }

        fmt.Println(m)
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="引用类型，哈希表，键必须是支持相等运算符类型。值可以是任意类型，没有限制"><a href="#引用类型，哈希表，键必须是支持相等]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记copy]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0copy/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记copy/</id>
    <published>2017-02-28T08:09:06.000Z</published>
    <updated>2017-03-01T12:04:53.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="函数copy在两个slice间复制数据，复制长度以len小的为准，两个slice可指向同一层数组，允许元素区间重叠"><a href="#函数copy在两个slice间复制数据，复制长度以len小的为准，两个slice可指向同一层数组，允许元素区间重叠" class="headerlink" title="函数copy在两个slice间复制数据，复制长度以len小的为准，两个slice可指向同一层数组，允许元素区间重叠"></a>函数copy在两个slice间复制数据，复制长度以len小的为准，两个slice可指向同一层数组，允许元素区间重叠</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    s := data[8:]
    s2 := data[:5]
    fmt.Println(s2)         //[0 1 2 3 4]
    copy(s2, s)

    fmt.Println(s)          //[8 9]
    fmt.Println(s2)         //[8 9 2 3 4]
    fmt.Println(data)       //[8 9 2 3 4 5 6 7 8 9]
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="函数copy在两个slice间复制数据，复制长度以len小的为准，两个slice可指向同一层数组，允许元素区间重叠"><a hre]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记append]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0append/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记append/</id>
    <published>2017-02-28T07:38:23.000Z</published>
    <updated>2017-03-01T12:04:44.000Z</updated>
    <content type="html"><![CDATA[<h1 id="append"><a href="#append" class="headerlink" title="append"></a>append</h1><h6 id="向slice尾部添加数据，返回新的slice对象"><a href="#向slice尾部添加数据，返回新的slice对象" class="headerlink" title="向slice尾部添加数据，返回新的slice对象"></a>向slice尾部添加数据，返回新的slice对象</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    s := make([]int, 0, 5)
    fmt.Printf(&quot;%p\n&quot;, &amp;s)      //0xc42000e1a0

    s2 := append(s, 1)
    fmt.Printf(&quot;%p\n&quot;, &amp;s2)     //0xc42000e1c0

    fmt.Println(s, s2)          //[] [1]
}
</code></pre><h6 id="append多个值"><a href="#append多个值" class="headerlink" title="append多个值"></a>append多个值</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    s := data[:3]
    s2 := append(s, 100, 200)

    fmt.Println(data)           //[0 1 2 100 200 5 6 7 8 9]
    fmt.Println(s)              //[0 1 2]
    fmt.Println(s2)             //[0 1 2 100 200]
}
</code></pre><h6 id="一旦超出原slice-cap限制，就会重新分配底层数组，即便原数组并未填满"><a href="#一旦超出原slice-cap限制，就会重新分配底层数组，即便原数组并未填满" class="headerlink" title="一旦超出原slice.cap限制，就会重新分配底层数组，即便原数组并未填满"></a>一旦超出原slice.cap限制，就会重新分配底层数组，即便原数组并未填满</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    data := [...]int{0, 1, 2, 3, 4, 10:0}
    s := data[:2:3]
    s = append(s, 100, 200) //一次append两个值，超出s.cap限制，append后的s重新分配了底层数组，并复制数据，如果只追加一个值，则不会重新分配底层数组

    fmt.Println(s, data)    //重新分配底层数组，与原数组无关
    fmt.Println(&amp;s[0], &amp;data[0])    //比对底层数组起始指针
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="append"><a href="#append" class="headerlink" title="append"></a>append</h1><h6 id="向slice尾部添加数据，返回新的slice对象"><a href="#向slice尾部添加数据，]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记reslice]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0reslice/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记reslice/</id>
    <published>2017-02-28T06:44:03.000Z</published>
    <updated>2017-03-01T12:05:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="基于已有slice创建新slice对象，以便在cap允许范围内调整属性"><a href="#基于已有slice创建新slice对象，以便在cap允许范围内调整属性" class="headerlink" title="基于已有slice创建新slice对象，以便在cap允许范围内调整属性"></a>基于已有slice创建新slice对象，以便在cap允许范围内调整属性</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    s := []int{0, 11, 10, 31, 4, 5, 6, 7, 8, 9}
    s1 := s[2:5]            //[10 31 4]
    s2 := s1[2:6:7]         //[4 5 6 7]     注意要在新的s1上进行截取
    //s3 := s2[3:6]           //报错
    fmt.Println(s1, s2)
}
</code></pre><h6 id="新对象依旧指向原底层数组"><a href="#新对象依旧指向原底层数组" class="headerlink" title="新对象依旧指向原底层数组"></a>新对象依旧指向原底层数组</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    s := []int{0, 11, 10, 31, 4, 5, 6, 7, 8, 9}
    s1 := s[2:5]    //[10 31 4]
    fmt.Println(s1)
    s1[2] = 100
    s2 := s1[2:6]
    fmt.Println(s2) //[100 5 6 7]
    s2[3] = 200

    fmt.Println(s)  //[0 11 10 31 100 5 6 200 8 9]
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="基于已有slice创建新slice对象，以便在cap允许范围内调整属性"><a href="#基于已有slice创建新slice对]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记slice]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0slice/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记slice/</id>
    <published>2017-02-28T03:52:55.000Z</published>
    <updated>2017-03-01T12:05:10.000Z</updated>
    <content type="html"><![CDATA[<h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><h6 id="slice不是数组或数组指针，它是通过内部指针和相关属性引用数组片段，以实现边长方案"><a href="#slice不是数组或数组指针，它是通过内部指针和相关属性引用数组片段，以实现边长方案" class="headerlink" title="slice不是数组或数组指针，它是通过内部指针和相关属性引用数组片段，以实现边长方案"></a>slice不是数组或数组指针，它是通过内部指针和相关属性引用数组片段，以实现边长方案</h6><h6 id="slice引用类型，但自身是结构体，值拷贝传递"><a href="#slice引用类型，但自身是结构体，值拷贝传递" class="headerlink" title="slice引用类型，但自身是结构体，值拷贝传递"></a>slice引用类型，但自身是结构体，值拷贝传递</h6><pre><code>//在runtime.h中的源码
struct slice
{
    byte* array;
    uintgo len;     //表示可用元素数量，读写操作不能超过该限制
    uintgo cap;     //表示最大扩张容量，不能超出数组限制
}
</code></pre><h6 id="slice使用方式-a-b-c-，a表示从a位置开始，b表示到b位置结束，c表示最大位置是c，len-b-a-cap-c-a"><a href="#slice使用方式-a-b-c-，a表示从a位置开始，b表示到b位置结束，c表示最大位置是c，len-b-a-cap-c-a" class="headerlink" title="slice使用方式[a:b:c]，a表示从a位置开始，b表示到b位置结束，c表示最大位置是c，len=b-a,cap=c-a"></a>slice使用方式[a:b:c]，a表示从a位置开始，b表示到b位置结束，c表示最大位置是c，len=b-a,cap=c-a</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    data := [...]int{0, 1, 2, 3, 4, 5, 6}
    slice := data[1:4:5]
    fmt.Println(slice)      //[1 2 3]
}
</code></pre><h6 id="slice使用举例"><a href="#slice使用举例" class="headerlink" title="slice使用举例"></a>slice使用举例</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    slice := data[:6:8]
    slice1 := data[5:]
    slice2 := data[:3]
    slice3 := data[:]
    fmt.Println(slice, slice1, slice2, slice3)  //[0 1 2 3 4 5] [5 6 7 8 9] [0 1 2] [0 1 2 3 4 5 6 7 8 9]
}
</code></pre><h6 id="slice读写操作实际目标是底层数组，只需要注意索引号的差别"><a href="#slice读写操作实际目标是底层数组，只需要注意索引号的差别" class="headerlink" title="slice读写操作实际目标是底层数组，只需要注意索引号的差别"></a>slice读写操作实际目标是底层数组，只需要注意索引号的差别</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    slice := data[6:8]
    slice[0] += 100
    slice[1] += 200
    fmt.Println(slice)  //[106 207]
    fmt.Println(data)   //[0 1 2 3 4 5 106 207 8 9]
}
</code></pre><h6 id="直接创建slice对象，自动分配底层数组"><a href="#直接创建slice对象，自动分配底层数组" class="headerlink" title="直接创建slice对象，自动分配底层数组"></a>直接创建slice对象，自动分配底层数组</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    data := [...]int{0, 1, 2, 3, 8:100}
    fmt.Println(data, len(data), cap(data)) //[0 1 2 3 0 0 0 0 100] 9 9

    s2 := make([]int, 6, 8)
    fmt.Println(s2, len(s2), cap(s2))   //[0 0 0 0 0 0] 6 8 没有初始化值，直接用0填充

    s3 := make([]int, 6)
    fmt.Println(s3, len(s3), cap(s3))   //[0 0 0 0 0 0] 6 6 省略cap那么久默认cap=len
}
</code></pre><h6 id="可以用指针直接访问底层数组，退化成普通数组操作"><a href="#可以用指针直接访问底层数组，退化成普通数组操作" class="headerlink" title="可以用指针直接访问底层数组，退化成普通数组操作"></a>可以用指针直接访问底层数组，退化成普通数组操作</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    s := []int{0, 1, 2, 3, 4}
    p := &amp;s[2]      //直接使用指针修改数组底层的值
    *p += 100
    fmt.Println(s)
}
</code></pre><h6 id="依然是二维数组"><a href="#依然是二维数组" class="headerlink" title="依然是二维数组"></a>依然是二维数组</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    data := [][]int{
        []int{1, 2, 3},
        []int{100, 200},
        []int{11, 22, 33, 44},
    }

    fmt.Println(data)       //[[1 2 3] [100 200] [11 22 33 44]]
}
</code></pre><h6 id="可直接修改struct-array成员"><a href="#可直接修改struct-array成员" class="headerlink" title="可直接修改struct array成员"></a>可直接修改struct array成员</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    d := [5]struct {
        x int
    }{}

    s := d[:]   //这里是引用

    d[1].x = 10
    s[2].x = 20
    fmt.Println(d)      //[{0} {10} {20} {0} {0}]
    fmt.Printf(&quot;%p, %p\n&quot;, &amp;d, &amp;d[0])       //0xc4200720c0, 0xc4200720c0
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><h6 id="slice不是数组或数组指针，它是通过内部指针和相关属性引用数组片段，以实现边长方案"><a href="]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记array]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0array/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记array/</id>
    <published>2017-02-28T03:21:50.000Z</published>
    <updated>2017-03-01T12:04:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Array类型数据"><a href="#Array类型数据" class="headerlink" title="Array类型数据"></a>Array类型数据</h1><h6 id="数组是值类型，赋值和传参会复制整个数组，而不是指针"><a href="#数组是值类型，赋值和传参会复制整个数组，而不是指针" class="headerlink" title="数组是值类型，赋值和传参会复制整个数组，而不是指针"></a>数组是值类型，赋值和传参会复制整个数组，而不是指针</h6><h6 id="数组长度必须是常量，且是类型的组成部分。-2-int和-3-int是不同类型"><a href="#数组长度必须是常量，且是类型的组成部分。-2-int和-3-int是不同类型" class="headerlink" title="数组长度必须是常量，且是类型的组成部分。[2]int和[3]int是不同类型"></a>数组长度必须是常量，且是类型的组成部分。[2]int和[3]int是不同类型</h6><h6 id="支持”-”，”！-”操作符，因为内存总是被初始化过"><a href="#支持”-”，”！-”操作符，因为内存总是被初始化过" class="headerlink" title="支持”==”，”！=”操作符，因为内存总是被初始化过"></a>支持”==”，”！=”操作符，因为内存总是被初始化过</h6><h6 id="指针数组-n-T-数组指针-n-T"><a href="#指针数组-n-T-数组指针-n-T" class="headerlink" title="指针数组[n]T,数组指针[n]T"></a>指针数组[n]<em>T,数组指针</em>[n]T</h6><h1 id="定义数组的方式"><a href="#定义数组的方式" class="headerlink" title="定义数组的方式"></a>定义数组的方式</h1><h6 id="直接初始化"><a href="#直接初始化" class="headerlink" title="直接初始化"></a>直接初始化</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    a := [3]int{1,2}    //定义了数组有三个元素，未初始化元素值为0
    fmt.Println(a)      //[1 2 0]
}


package main

import &quot;fmt&quot;

func main() {
    a := [...]int{1, 2, 3, 4, 5}    //通过初始化值确定数组长度
    fmt.Println(a)      //[1 2 3 4 5]
}

package main

import &quot;fmt&quot;

func main() {
    a := [5]int{2:100, 4:200}   //指定了数组对应的键，索引从0开始以0的值进行补齐到指定的数组长度
    fmt.Println(a)      //[0 0 100 0 200]
}
</code></pre><h6 id="先struct方式定义数组格式，再初始化值"><a href="#先struct方式定义数组格式，再初始化值" class="headerlink" title="先struct方式定义数组格式，再初始化值"></a>先struct方式定义数组格式，再初始化值</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    a := [...]struct{
        name string
        age uint8
    }{
        {&quot;user1&quot;, 10},
        {&quot;user2&quot;, 20},  //都好不能省略
    }

    fmt.Println(a)      //[{user1 10} {user2 20}]
}
</code></pre><h6 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    a := [2][3]int{{1,2,3}, {4,5,6}}    //指定每一层的元素个数

    fmt.Println(a)      //[[1 2 3] [4 5 6]]
}


package main

import &quot;fmt&quot;

func main() {
    a := [...][3]int{{1,2,3}, {4,5,6}}  //省略第一维的元素个数，第二维不能省略

    fmt.Println(a)      //[[1 2 3] [4 5 6]]
}
</code></pre><h6 id="数组会有值拷贝行为，建议使用后slice，或数组指针"><a href="#数组会有值拷贝行为，建议使用后slice，或数组指针" class="headerlink" title="数组会有值拷贝行为，建议使用后slice，或数组指针"></a>数组会有值拷贝行为，建议使用后slice，或数组指针</h6><pre><code>package main

import &quot;fmt&quot;

func test(x [2]int) {
    fmt.Printf(&quot;x:%p&quot;, &amp;x)  //x:0xc42000a2d0    指针位置发生了改变，说明是重新复制了值
    x[1] = 1000
}

func main() {
    a := [2]int{1,2}
    fmt.Printf(&quot;a:%p&quot;, &amp;a)  //a:0xc42000a2a0
    test(a)
    fmt.Println(a)  //[1 2] 由于是值复制，因此当前的数组还是原来的值
}
</code></pre><h6 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    a := [2]int{1,2}
    fmt.Println(len(a), cap(a))  //2,2
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Array类型数据"><a href="#Array类型数据" class="headerlink" title="Array类型数据"></a>Array类型数据</h1><h6 id="数组是值类型，赋值和传参会复制整个数组，而不是指针"><a href="#]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记延迟调用]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%BB%B6%E8%BF%9F%E8%B0%83%E7%94%A8/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记延迟调用/</id>
    <published>2017-02-28T03:18:53.000Z</published>
    <updated>2017-03-01T12:05:35.000Z</updated>
    <content type="html"><![CDATA[<h1 id="延迟调用"><a href="#延迟调用" class="headerlink" title="延迟调用"></a>延迟调用</h1><h6 id="使用defer用于注册延迟调用，可以理解为类似PHP对象中的析构函数，只有在ret前才被执行，通常用于释放资源或者错误处理"><a href="#使用defer用于注册延迟调用，可以理解为类似PHP对象中的析构函数，只有在ret前才被执行，通常用于释放资源或者错误处理" class="headerlink" title="使用defer用于注册延迟调用，可以理解为类似PHP对象中的析构函数，只有在ret前才被执行，通常用于释放资源或者错误处理"></a>使用defer用于注册延迟调用，可以理解为类似PHP对象中的析构函数，只有在ret前才被执行，通常用于释放资源或者错误处理</h6><pre><code>package main

import &quot;os&quot;

func test() error {
    f, err := os.Create(&quot;test.txt&quot;) //创建一个文件

    if err != nil { return err }    //创建失败返回错误信息

    defer f.Close()     //不管是否出现错误都会关闭文件，defer会在ret之前执行
    f.WriteString(&quot;Hello,world!&quot;)   //往文件中写入内容
    return nil
}

func main() {
    test()
}
</code></pre><h6 id="多个defer注册，按FILO次序执行"><a href="#多个defer注册，按FILO次序执行" class="headerlink" title="多个defer注册，按FILO次序执行"></a>多个defer注册，按FILO次序执行</h6><pre><code>package main

func test(x int) int {
    defer println(&quot;a&quot;)
    defer println(&quot;b&quot;)

    defer func() {
        println(100 / x)
    }()

    defer println(&quot;c&quot;)

    return 1
}

func main() {
    test(20)        //输出结果为c 5 b a
}
</code></pre><h6 id="延迟调用参数在注册时求值或复制，可用指针或闭包延迟读取"><a href="#延迟调用参数在注册时求值或复制，可用指针或闭包延迟读取" class="headerlink" title="延迟调用参数在注册时求值或复制，可用指针或闭包延迟读取"></a>延迟调用参数在注册时求值或复制，可用指针或闭包延迟读取</h6><pre><code>package main

func test() {
    x, y := 10, 20

    defer func(i int) {
        println(&quot;defer:&quot;, i, y) //y闭包引用
    }(x)    //x被复制

    x += 10
    y += 100
    println(&quot;x=&quot;, x, &quot;y=&quot;, y)
}

func main() {
    test()
    //结果为:x= 20 y= 120   defer: 10 120
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="延迟调用"><a href="#延迟调用" class="headerlink" title="延迟调用"></a>延迟调用</h1><h6 id="使用defer用于注册延迟调用，可以理解为类似PHP对象中的析构函数，只有在ret前才被执行，通常用于释放资源或者]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记异常处理]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记异常处理/</id>
    <published>2017-02-28T03:17:53.000Z</published>
    <updated>2017-03-01T12:05:39.000Z</updated>
    <content type="html"><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h6 id="没有结构化异常，使用panic抛出错误，recover捕获错误"><a href="#没有结构化异常，使用panic抛出错误，recover捕获错误" class="headerlink" title="没有结构化异常，使用panic抛出错误，recover捕获错误"></a>没有结构化异常，使用panic抛出错误，recover捕获错误</h6><pre><code>package main

func test() {
    defer func() {
        if err := recover();err != nil {    //相当于php的错误异常处理的try
            println(err.(string))       //将interface转换成string类型
        }
    }()

    panic(&quot;panic error!&quot;)   //相当于php的throw
}

func main() {
    test()  //输出panic error!
}
</code></pre><h6 id="由于panic，recover参数类型为interface-，因此可抛出任何类型对象"><a href="#由于panic，recover参数类型为interface-，因此可抛出任何类型对象" class="headerlink" title="由于panic，recover参数类型为interface{}，因此可抛出任何类型对象"></a>由于panic，recover参数类型为interface{}，因此可抛出任何类型对象</h6><pre><code>func panic(v interface{})   //不太理解
func recover() interface{}
</code></pre><h6 id="延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后一个错误可被捕获"><a href="#延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后一个错误可被捕获" class="headerlink" title="延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后一个错误可被捕获"></a>延迟调用中引发的错误，可被后续延迟调用捕获，但仅最后一个错误可被捕获</h6><pre><code>package main

import &quot;fmt&quot;

func test() {
    defer func() {
        fmt.Println(recover())
    }()

    defer func() {
        panic(&quot;defer panic&quot;)
    }()

    panic(&quot;test panic&quot;)
}

func main() {
    test()  //输出结果为: defer panic
}
</code></pre><h6 id="捕获函数recover只有在延迟调用内直接调用才会终止错误，否则总会返回nil，任何未捕获的错误都会沿调用栈向外传递"><a href="#捕获函数recover只有在延迟调用内直接调用才会终止错误，否则总会返回nil，任何未捕获的错误都会沿调用栈向外传递" class="headerlink" title="捕获函数recover只有在延迟调用内直接调用才会终止错误，否则总会返回nil，任何未捕获的错误都会沿调用栈向外传递"></a>捕获函数recover只有在延迟调用内直接调用才会终止错误，否则总会返回nil，任何未捕获的错误都会沿调用栈向外传递</h6><pre><code>package main

import &quot;fmt&quot;

func test() {
    defer recover() //无效
    defer fmt.Println(recover())    //无效
    defer func() {
        //recover() //只有在此处才能捕获异常
        func() {
            println(&quot;defer inner&quot;)
            recover()   //无效
        }()
    }()

    panic(&quot;test panic&quot;)
}

func main() {
    test()
}
</code></pre><h6 id="使用error-New和fmt-Errorf函数创建error接口的错误对象"><a href="#使用error-New和fmt-Errorf函数创建error接口的错误对象" class="headerlink" title="使用error.New和fmt.Errorf函数创建error接口的错误对象"></a>使用error.New和fmt.Errorf函数创建error接口的错误对象</h6><pre><code>package main

import &quot;errors&quot;

type error interface {
    Error() string
}

var ErrDivByZero = errors.New(&quot;division by zero&quot;)   //使用error.New创建error错误对象

func div(x, y int) (int, error) {
    if y == 0 { return 0, ErrDivByZero }
    return x / y, nil       //返回结果和异常
}

func main() {
    switch z, err := div(10, 0); err {  //初始化变量，然后再匹配异常err的信息
    case nil:
        println(z)
    case ErrDivByZero:
        panic(err)
    }
}
</code></pre><h6 id="区分panic和error的两种方式，在包内部一般使用panic，对外api使用error返回值"><a href="#区分panic和error的两种方式，在包内部一般使用panic，对外api使用error返回值" class="headerlink" title="区分panic和error的两种方式，在包内部一般使用panic，对外api使用error返回值"></a>区分panic和error的两种方式，在包内部一般使用panic，对外api使用error返回值</h6>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><h6 id="没有结构化异常，使用panic抛出错误，recover捕获错误"><a href="#没有结构化异常，使用pani]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记函数]]></title>
    <link href="http://www.cxyteam.com/2017/02/24/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%87%BD%E6%95%B0/"/>
    <id>http://www.cxyteam.com/2017/02/24/go学习笔记函数/</id>
    <published>2017-02-24T09:10:31.000Z</published>
    <updated>2017-03-01T12:05:22.000Z</updated>
    <content type="html"><![CDATA[<h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><h6 id="不支持嵌套，重载和默认参数"><a href="#不支持嵌套，重载和默认参数" class="headerlink" title="不支持嵌套，重载和默认参数"></a>不支持嵌套，重载和默认参数</h6><h6 id="无需声明原型"><a href="#无需声明原型" class="headerlink" title="无需声明原型"></a>无需声明原型</h6><h6 id="支持不定长变参"><a href="#支持不定长变参" class="headerlink" title="支持不定长变参"></a>支持不定长变参</h6><h6 id="支持多返回值"><a href="#支持多返回值" class="headerlink" title="支持多返回值"></a>支持多返回值</h6><h6 id="支持命名返回参数"><a href="#支持命名返回参数" class="headerlink" title="支持命名返回参数"></a>支持命名返回参数</h6><h6 id="支持匿名函数和闭包"><a href="#支持匿名函数和闭包" class="headerlink" title="支持匿名函数和闭包"></a>支持匿名函数和闭包</h6><h6 id="使用func定义函数，左大括号依旧不能另起一行"><a href="#使用func定义函数，左大括号依旧不能另起一行" class="headerlink" title="使用func定义函数，左大括号依旧不能另起一行"></a>使用func定义函数，左大括号依旧不能另起一行</h6><pre><code>package main

func test (x, y int, s string) (int, string) {  //需要定义返回参数的类型，可以返回多个数值
    n := x + y
    return n, s
}

func main() {
    x,y := test(1, 2, &quot;a&quot;)  //接收返回的值
    println(x,y)
}
</code></pre><h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><h6 id="函数是第一类对象，可作为参数传递"><a href="#函数是第一类对象，可作为参数传递" class="headerlink" title="函数是第一类对象，可作为参数传递"></a>函数是第一类对象，可作为参数传递</h6><pre><code>package main

import &quot;fmt&quot;

func test(fn func() int) int {  //参数可以传入函数
    return fn()
}

type FormatFunc func(s string, x, y int) string //定义函数类型

func format(fn FormatFunc, s string, x, y int) string {
    return fn(s, x, y)
}

func main() {
    s1 := test(func() int { return 100 })
    s2 := format(func(s string, x, y int) string {
        return fmt.Sprintf(s, x, y)
    }, &quot;%d, %d&quot;, 10, 20)

    println(s1, s2)
}
</code></pre><h6 id="只能有一个，且必须是最后一个"><a href="#只能有一个，且必须是最后一个" class="headerlink" title="只能有一个，且必须是最后一个"></a>只能有一个，且必须是最后一个</h6><pre><code>package main

import &quot;fmt&quot;

func test(s string, n ...int) string {  //变参
    var x int
    for _, i := range n {
        x += i
    }

    return fmt.Sprintf(s, x)
}

func main() {
    println(test(&quot;sum:%d&quot;, 1, 2, 3))
}
</code></pre><h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><h6 id="只能用变量接收返回值或者-忽略返回值"><a href="#只能用变量接收返回值或者-忽略返回值" class="headerlink" title="只能用变量接收返回值或者_忽略返回值"></a>只能用变量接收返回值或者_忽略返回值</h6><pre><code>package main

func test() (int, int) {
    return 1,2
}

func main() {
    a,_ := test()
    println(a)
}
</code></pre><h6 id="多返回值可直接作为其他函数调用实参"><a href="#多返回值可直接作为其他函数调用实参" class="headerlink" title="多返回值可直接作为其他函数调用实参"></a>多返回值可直接作为其他函数调用实参</h6><pre><code>package main

func test() (int, int) {
    return 1,2
}

func add(x, y int) int {
    return x+y
}

func sum(n ...int) int {    //变参
    var x int
    for _,i := range n {    //循环，舍弃键
        x += i
    }

    return x
}

func main() {
    println(add(test()))
    println(sum(test()))
}
</code></pre><h6 id="命名返回参数可看做与形参类似的局部变量，最后由return隐式返回"><a href="#命名返回参数可看做与形参类似的局部变量，最后由return隐式返回" class="headerlink" title="命名返回参数可看做与形参类似的局部变量，最后由return隐式返回"></a>命名返回参数可看做与形参类似的局部变量，最后由return隐式返回</h6><pre><code>package main

func add(x, y int) (z int) {
    z = x + y
    return  //虽然没返回z，但是函数定义了返回的值是z而且是int类型
}

func main() {
    println(add(1, 2))
}
</code></pre><h6 id="命名返回的参数可被同名局部变量遮蔽，需要显示返回"><a href="#命名返回的参数可被同名局部变量遮蔽，需要显示返回" class="headerlink" title="命名返回的参数可被同名局部变量遮蔽，需要显示返回"></a>命名返回的参数可被同名局部变量遮蔽，需要显示返回</h6><pre><code>package main

func add(x, y int) (z int) {
    {   //不能在一个级别定义z，否则会报错
        var z = x + y
        return z    //必须要显示返回
    }
}

func main() {
    println(add(1, 2))
}

//命名返回参数允许defer延迟调用通过闭包读取和修改
package main

func add(x, y int) (z int) {
    defer func() {
        println(z)  //输出3
        z += 100
    }()
    z = x + y
    return
}

func main() {
    println(add(1, 2))  //输出103
}
</code></pre><h6 id="显式return返回前，会先修改命名返回参数"><a href="#显式return返回前，会先修改命名返回参数" class="headerlink" title="显式return返回前，会先修改命名返回参数"></a>显式return返回前，会先修改命名返回参数</h6><pre><code>package main

func add(x, y int) (z int) {
    defer func() {
        println(z)//输出结果为203
    }()
    z = x + y
    println(z)//输出结果为3
    return z + 200  //执行顺序:z = x + y =&gt; z + 200 =&gt; call defer =&gt; return
}

func main() {
    println(add(1, 2))
}
</code></pre><h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><h6 id="匿名函数-做为变量"><a href="#匿名函数-做为变量" class="headerlink" title="匿名函数,做为变量"></a>匿名函数,做为变量</h6><pre><code>package main

func main() {
    fn := func() { println(&quot;hello world&quot;)}
    fn()
}
</code></pre><h6 id="匿名函数，做为collection"><a href="#匿名函数，做为collection" class="headerlink" title="匿名函数，做为collection"></a>匿名函数，做为collection</h6><pre><code>package main

func main() {
    fns := [](func(x int) int) {
        func(x int) int { return x + 1 },
        func(x int) int { return x + 2 },
    }

    println(fns[0](100))
}
</code></pre><h6 id="匿名函数，做为字段"><a href="#匿名函数，做为字段" class="headerlink" title="匿名函数，做为字段"></a>匿名函数，做为字段</h6><pre><code>package main

func main() {
    d := struct {
        fn func() string
    }{
        fn: func() string { return &quot;hello,world!&quot; },
    }

    println(d.fn())
}
</code></pre><h6 id="匿名函数，做为channel"><a href="#匿名函数，做为channel" class="headerlink" title="匿名函数，做为channel"></a>匿名函数，做为channel</h6><pre><code>package main

func main() {
    fc := make(chan func() string, 2)//声明一个chan，定义一个函数
    fc &lt;- func() string { return &quot;Hello,World!&quot; }   //把函数的值发送给fc
    println((&lt;-fc)())
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h1><h6 id="不支持嵌套，重载和默认参数"><a href="#不支持嵌套，重载和默认参数" class="headerlink]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记表达式]]></title>
    <link href="http://www.cxyteam.com/2017/02/22/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://www.cxyteam.com/2017/02/22/go学习笔记表达式/</id>
    <published>2017-02-22T02:54:47.000Z</published>
    <updated>2017-03-01T12:06:24.000Z</updated>
    <content type="html"><![CDATA[<h1 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h1><h6 id="在程序中不可以使用的名字"><a href="#在程序中不可以使用的名字" class="headerlink" title="在程序中不可以使用的名字"></a>在程序中不可以使用的名字</h6><pre><code>break,deafault,func,interface,select,case,defer,go,map,struct,chan,else,goto,
package,switch,const,fallthrough,if,range,type,continue,for,import,return,var
</code></pre><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><pre><code>+       &amp;        +=       &amp;=        &amp;&amp;       ==       !=       (       )
-       |        -=       |=        ||       &lt;        &lt;=       [       ]
*       ^        *=       ^=        &lt;-       &gt;        &gt;=       {       }
/       &lt;&lt;       /=       &lt;&lt;=       ++       =        :=       ,       ;
%       &gt;&gt;       %=       &gt;&gt;=       --       !        ...      .       :
&amp;^      &amp;^=
</code></pre><h1 id="简单位运算符"><a href="#简单位运算符" class="headerlink" title="简单位运算符"></a>简单位运算符</h1><pre><code>0110 &amp;  1011 = 0010     //AND 都为1
0110 |  1011 = 1111     //OR 至少一个为1
0110 ^  1011 = 1101     //XOR 只能一个为1
0110 &amp;^ 1011 = 0100     //AND NOT 清楚标志位 m &amp;^ n 下面的数字是n的二进制是1值为0，二进制是0值为m中对应的值
</code></pre><h1 id="标志位操作"><a href="#标志位操作" class="headerlink" title="标志位操作"></a>标志位操作</h1><pre><code>a := 0
a |= 1 &lt;&lt; 2             //&lt;&lt;左移运算符 比如：1&lt;&lt;2 则表示：1的二进制表示为：000...0001(这里1前面0的个数和int的位数有关,32位机器,gcc里有31个0)，那么像左移动两位则是000...000100
a |= 1 &lt;&lt; 6             //a|=b表示的意思就是a=a|b（注意OR运算是需要先转换成二进制的）
a = a &amp;^ (1 &lt;&lt; 6)
</code></pre><h1 id="不支持运算符重载"><a href="#不支持运算符重载" class="headerlink" title="不支持运算符重载"></a>不支持运算符重载</h1><pre><code>package main

import (
    &quot;fmt&quot;
)

func main() {
    n := 0
    p := &amp;n
    //b := n++          //报错
    //if n++ == 1 {}    //报错
    //++n               //报错
    n++
    *p++

    fmt.Println(n, p)
}
</code></pre><h1 id="没有’-’，取反运算也用’-’"><a href="#没有’-’，取反运算也用’-’" class="headerlink" title="没有’~’，取反运算也用’^’"></a>没有’~’，取反运算也用’^’</h1><pre><code>package main

import (
    &quot;fmt&quot;
)

func main() {
    x := 1
    x = ^x

    fmt.Println(x)
}
</code></pre><h1 id="初始化符合对象，必须使用类型标签，且左大括号必须在类型尾部"><a href="#初始化符合对象，必须使用类型标签，且左大括号必须在类型尾部" class="headerlink" title="初始化符合对象，必须使用类型标签，且左大括号必须在类型尾部"></a>初始化符合对象，必须使用类型标签，且左大括号必须在类型尾部</h1><pre><code>package main

import (
    &quot;fmt&quot;
)

func main() {
    //var a struct{ x int } = { 100 }     //报错
    //var b []int = { 1, 2, 3 }           //报错
    //c := struct { x int; y string }     //报错
    //{
    //}
    var a = struct { x int } { 100 }
    var b = []int{  //可以分行
                    1,
                    2,
                    3,  //分开的话，最后一行要一个&apos;,&apos;
    }

    var c = []int{  //可以分行
                        1,
                        2,
                        3}  //分开的话，最后一行要一个&apos;}&apos;

    fmt.Println(a, b, c)
}
</code></pre><h1 id="IF语句"><a href="#IF语句" class="headerlink" title="IF语句"></a>IF语句</h1><h6 id="可省略条件表达式括号"><a href="#可省略条件表达式括号" class="headerlink" title="可省略条件表达式括号"></a>可省略条件表达式括号</h6><h6 id="支持初始化语句，可定义代码块局部变量"><a href="#支持初始化语句，可定义代码块局部变量" class="headerlink" title="支持初始化语句，可定义代码块局部变量"></a>支持初始化语句，可定义代码块局部变量</h6><h6 id="代码块左大括号必须在条件表达式尾部"><a href="#代码块左大括号必须在条件表达式尾部" class="headerlink" title="代码块左大括号必须在条件表达式尾部"></a>代码块左大括号必须在条件表达式尾部</h6><pre><code>package main

import (
    &quot;fmt&quot;
)

func main() {
    x := 0

    if n := &quot;abc&quot;; x&gt;10 {
       fmt.Println(n[1])
    } else if x &lt;0 {
        fmt.Println(n[2])
    } else {
        println(n[0])
    }
}
</code></pre><h1 id="不支持三元运算符"><a href="#不支持三元运算符" class="headerlink" title="不支持三元运算符"></a>不支持三元运算符</h1><pre><code>package main

func main() {
    a := 0
    b := 1

    c := a &gt; b ? a : b      //报错
    println(c)
}
</code></pre><h1 id="For（循环语句）"><a href="#For（循环语句）" class="headerlink" title="For（循环语句）"></a>For（循环语句）</h1><pre><code>package main

func main() {
    s := &quot;abc&quot;
    //常见的for循环方式
    for i,n :=0, len(s); i &lt; n; i++ {
        println(i)
    }

    //while的for循环方式
    n := len(s)
    for n &gt; 0 {
        println(n)
        n--
    }

    //while(true) {} 死循环
    for {
        println(s)
    }
}
</code></pre><h1 id="Range-类似迭代器操作，返回键值"><a href="#Range-类似迭代器操作，返回键值" class="headerlink" title="Range(类似迭代器操作，返回键值)"></a>Range(类似迭代器操作，返回键值)</h1><pre><code>package main

func main() {
    s := &quot;abc&quot;

    for i := range s {      //默认忽略值，只把键赋值给了i变量
        println(i, s[i])
    }

    for _, c := range s {   //默认丢弃了键，把值赋给了c变量
        println(c)
    }

    var d = 0
    for range s {           //抛弃键值，只循环
        d++
    }

    println(d)

    m := map[string]int{&quot;a&quot;:1, &quot;b&quot;:2}
    for k,v := range m {        //遍历出键值
        println(k,v)
    }
}
</code></pre><h1 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h1><pre><code>package main

func main() {
    x := []int{1, 2, 3}
    i := 3
    switch i {
        case x[1]:
            println(&quot;a&quot;)
        case x[2], 1:
            println(&quot;b&quot;)
        default:
            println(&quot;c&quot;)
    }
}


package main

func main() {
    x := 10
    switch x {
        case 10:
            println(&quot;a&quot;)
            fallthrough //需要继续下一分支，使用fallthrough
        case 0:
            println(&quot;c&quot;)
    }
}

package main

func main() {
    x := []int{1, 2, 3}
    switch {
        case x[1] &gt; 0:      //当做if else使用 
            println(&quot;a&quot;)
        case x[1] &lt; 0:
            println(&quot;b&quot;)
        default:
            println(&quot;c&quot;)
    }
}

package main

func main() {
    x := []int{1, 2, 3}
    switch i := x[2]; { //带初始值
        case i &gt; 0:
            println(&quot;a&quot;)
        case i &lt; 0:
            println(&quot;b&quot;)
        default:
            println(&quot;c&quot;)
    }
}
</code></pre><h1 id="goto语句"><a href="#goto语句" class="headerlink" title="goto语句"></a>goto语句</h1><pre><code>package main

func main() {
    var i int
    for {
        println(i)
        i++
        if i &gt; 2 {
            goto TEST
        }
    }

    TEST:
        println(&quot;break&quot;)
}
</code></pre><h1 id="break和continue"><a href="#break和continue" class="headerlink" title="break和continue"></a>break和continue</h1><pre><code>package main

func main() {
    L1:
        for x := 0;x &lt; 3; x++ {
    L2:
            for y := 0;y &lt; 5;y++ {
                if y &gt; 2 {
                    continue L2
                }

                if x &gt; 1 {
                    break L1        //break可用于for,switch,select而continue只能用于for循环
                }

                print(x, &quot;:&quot;, y, &quot; &quot;)
            }

            println()
        }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h1><h6 id="在程序中不可以使用的名字"><a href="#在程序中不可以使用的名字" class="headerlink" titl]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记类型]]></title>
    <link href="http://www.cxyteam.com/2017/02/20/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%B1%BB%E5%9E%8B/"/>
    <id>http://www.cxyteam.com/2017/02/20/go学习笔记类型/</id>
    <published>2017-02-20T11:33:27.000Z</published>
    <updated>2017-03-01T12:06:18.000Z</updated>
    <content type="html"><![CDATA[<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><pre><code>package main

func main() {
    var b byte = 100
    var n int = b // //隐式转换不支持，会报错
    //var n int = int(b)//显示转换
    println(n)
}
</code></pre><h1 id="其他值不能当作bool值使用"><a href="#其他值不能当作bool值使用" class="headerlink" title="其他值不能当作bool值使用"></a>其他值不能当作bool值使用</h1><pre><code>package main

func main() {
    a := 100
    if a {
        printf(&quot;aaa&quot;)
    }
}
</code></pre><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h6 id="字符串是不可变值类型，内部用指针指向UTF-8字节数组"><a href="#字符串是不可变值类型，内部用指针指向UTF-8字节数组" class="headerlink" title="字符串是不可变值类型，内部用指针指向UTF-8字节数组"></a>字符串是不可变值类型，内部用指针指向UTF-8字节数组</h6><h6 id="默认值是控制符串””"><a href="#默认值是控制符串””" class="headerlink" title="默认值是控制符串””"></a>默认值是控制符串””</h6><h6 id="用索引号访问某字节，如s-i"><a href="#用索引号访问某字节，如s-i" class="headerlink" title="用索引号访问某字节，如s[i]"></a>用索引号访问某字节，如s[i]</h6><h6 id="不能用序号获取字节元素指针。-amp-s-i-非法"><a href="#不能用序号获取字节元素指针。-amp-s-i-非法" class="headerlink" title="不能用序号获取字节元素指针。&amp;s[i]非法"></a>不能用序号获取字节元素指针。&amp;s[i]非法</h6><h6 id="不可变类型，无法修改字节数组"><a href="#不可变类型，无法修改字节数组" class="headerlink" title="不可变类型，无法修改字节数组"></a>不可变类型，无法修改字节数组</h6><h6 id="字节数组尾部不包含NULL"><a href="#字节数组尾部不包含NULL" class="headerlink" title="字节数组尾部不包含NULL"></a>字节数组尾部不包含NULL</h6><h6 id="使用反引号定义不做转义处理的原始字符串，支持跨行"><a href="#使用反引号定义不做转义处理的原始字符串，支持跨行" class="headerlink" title="使用反引号定义不做转义处理的原始字符串，支持跨行"></a>使用反引号定义不做转义处理的原始字符串，支持跨行</h6><pre><code>package main

func main() {
    s := `abc
    asdfa
    c
    `
    println(s)  //结果就是字符串
}
</code></pre><h6 id="连接跨行字符串时，”-”必须在上一行末尾，否则导致编译错误"><a href="#连接跨行字符串时，”-”必须在上一行末尾，否则导致编译错误" class="headerlink" title="连接跨行字符串时，”+”必须在上一行末尾，否则导致编译错误"></a>连接跨行字符串时，”+”必须在上一行末尾，否则导致编译错误</h6><pre><code>package main

func main() {
    s := &quot;hello！&quot; +
        &quot;world!&quot;

    println(s)  //输出结果为hello！world!
}
</code></pre><h6 id="支持用两个索引号返回子串"><a href="#支持用两个索引号返回子串" class="headerlink" title="支持用两个索引号返回子串"></a>支持用两个索引号返回子串</h6><pre><code>package main

func main() {
    s := &quot;hello,&quot; +
        &quot;world!&quot;

    s1 := s[:5]
    s2 := s[7:]
    s3 := s[1:7]
    println(s1, s2, s3) //hello orld! ello,w
}
</code></pre><h6 id="单引号字符创常量表示Unicode-Code-Point-支持-uFFFF-U7FFFFFFF-xFF格式"><a href="#单引号字符创常量表示Unicode-Code-Point-支持-uFFFF-U7FFFFFFF-xFF格式" class="headerlink" title="单引号字符创常量表示Unicode Code Point,支持\uFFFF,\U7FFFFFFF,\xFF格式"></a>单引号字符创常量表示Unicode Code Point,支持\uFFFF,\U7FFFFFFF,\xFF格式</h6><pre><code>package main

func main() {
    println(&quot;%T\n&quot;, &apos;a&apos;)
    var c1, c2 rune = &apos;\u6211&apos;, &apos; &apos;
    println(c1 == &apos; &apos;, string(c2) == &quot;\xe4\xbb\xac&quot;)
}
</code></pre><h6 id="要修改字符串，必须先将其转换成-rune或-byte-完成后再转换为string，这两种方式都会重新分配内存，并复制字节数组"><a href="#要修改字符串，必须先将其转换成-rune或-byte-完成后再转换为string，这两种方式都会重新分配内存，并复制字节数组" class="headerlink" title="要修改字符串，必须先将其转换成[]rune或[]byte,完成后再转换为string，这两种方式都会重新分配内存，并复制字节数组"></a>要修改字符串，必须先将其转换成[]rune或[]byte,完成后再转换为string，这两种方式都会重新分配内存，并复制字节数组</h6><pre><code>package main

func main() {
    s := &quot;abcd&quot;
    bs := []byte(s)
    bs[1] = &apos;B&apos;
    println(string(bs)) //aBcd

    u := &quot;电脑&quot;
    us := []rune(u)
    us[1] = &apos;话&apos;
    println(string(us)) //电话
}
</code></pre><h6 id="用for循环遍历字符串时，也有byte和rune两种方式"><a href="#用for循环遍历字符串时，也有byte和rune两种方式" class="headerlink" title="用for循环遍历字符串时，也有byte和rune两种方式"></a>用for循环遍历字符串时，也有byte和rune两种方式</h6><pre><code>package main
import &quot;fmt&quot;

func main() {
    s := &quot;abcd语言&quot;
    for i := 0; i&lt;len(s); i++ {
        fmt.Printf(&quot;%c&quot;, s[i])  //abcdè¯­è¨    byte方式
    }

    for _, r := range s {
        fmt.Printf(&quot;%c&quot;, r)     //abcd语言    rune方式
    }
}
</code></pre><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h6 id="默认值为nil，没有NULL常量"><a href="#默认值为nil，没有NULL常量" class="headerlink" title="默认值为nil，没有NULL常量"></a>默认值为nil，没有NULL常量</h6><h6 id="操作符”-amp-”取变量地址，”-”透过指针访问目标对象"><a href="#操作符”-amp-”取变量地址，”-”透过指针访问目标对象" class="headerlink" title="操作符”&amp;”取变量地址，”*”透过指针访问目标对象"></a>操作符”&amp;”取变量地址，”*”透过指针访问目标对象</h6><h6 id="不支持指针运算，不支持”-gt-”运算符，直接用”-”访问目标成员"><a href="#不支持指针运算，不支持”-gt-”运算符，直接用”-”访问目标成员" class="headerlink" title="不支持指针运算，不支持”-&gt;”运算符，直接用”.”访问目标成员"></a>不支持指针运算，不支持”-&gt;”运算符，直接用”.”访问目标成员</h6><pre><code>package main
import &quot;fmt&quot;

func main() {
    type data struct{   //申明一个data的数据结构
        a int
    }

    var d = data{1234}  //赋值d的初始值为data类型

    var p *data //申明p的类型
    p = &amp;d

    fmt.Printf(&quot;%p, %v\n&quot;, p, p.a)  //0xc42000a2a0, 1234
}
</code></pre><h6 id="不能用指针做加减法运算"><a href="#不能用指针做加减法运算" class="headerlink" title="不能用指针做加减法运算"></a>不能用指针做加减法运算</h6><pre><code>package main

func main() {
    x := 1234
    p := &amp;x
    p++ //报错
}
</code></pre><h6 id="可以在unsafe-Pointer和任意类型指针间进行转换"><a href="#可以在unsafe-Pointer和任意类型指针间进行转换" class="headerlink" title="可以在unsafe.Pointer和任意类型指针间进行转换"></a>可以在unsafe.Pointer和任意类型指针间进行转换</h6><pre><code>package main
import (
    &quot;fmt&quot;
    &quot;unsafe&quot;
)

func main() {
    x := 0x12345678
    p := unsafe.Pointer(&amp;x)
    n := (*[4]byte)(p)
    for i := 0; i &lt; len(n); i++ {
        fmt.Printf(&quot;%X &quot;, n[i]) //78 56 34 12
    }
}
</code></pre><h6 id="返回局部变量的指针是安全的，编译器会根据需要将其分配在GC-Heap上"><a href="#返回局部变量的指针是安全的，编译器会根据需要将其分配在GC-Heap上" class="headerlink" title="返回局部变量的指针是安全的，编译器会根据需要将其分配在GC Heap上"></a>返回局部变量的指针是安全的，编译器会根据需要将其分配在GC Heap上</h6><pre><code>package main

func main() {
    println(test())
}

func test() *int {
    x := 100
    return &amp;x
}
</code></pre><h6 id="将Pointer转换成uintptr，可变相进行指针运算"><a href="#将Pointer转换成uintptr，可变相进行指针运算" class="headerlink" title="将Pointer转换成uintptr，可变相进行指针运算"></a>将Pointer转换成uintptr，可变相进行指针运算</h6><pre><code>package main

import (
        &quot;fmt&quot;
        &quot;unsafe&quot;
)

func main() {
    d := struct {
        s string
        x int
    }{&quot;abc&quot;, 100}

    //uintptr是goland的内置类型，是存储指针的整型，用于指针运算的；unsafe.Pointer是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算
    p := uintptr(unsafe.Pointer(&amp;d))
    //获取x的偏移量
    p += unsafe.Offsetof(d.x)
    //unsafe.Pointer指向一个Int类型的地址
    p2 := unsafe.Pointer(p)
    px := (*int)(p2)
    *px = 200

    fmt.Printf(&quot;%#v\n&quot;, d)  //struct { s string; x int }{s:&quot;abc&quot;, x:200}
}
</code></pre><h1 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h1><h6 id="可将类型分为命名和未命名两大类，命名类型包括bool，int，string等，而array，slice，map等和具体元素类型，长度等有关，属于未命名类型，具有相同声明的未命名类型被视为同一类型"><a href="#可将类型分为命名和未命名两大类，命名类型包括bool，int，string等，而array，slice，map等和具体元素类型，长度等有关，属于未命名类型，具有相同声明的未命名类型被视为同一类型" class="headerlink" title="可将类型分为命名和未命名两大类，命名类型包括bool，int，string等，而array，slice，map等和具体元素类型，长度等有关，属于未命名类型，具有相同声明的未命名类型被视为同一类型"></a>可将类型分为命名和未命名两大类，命名类型包括bool，int，string等，而array，slice，map等和具体元素类型，长度等有关，属于未命名类型，具有相同声明的未命名类型被视为同一类型</h6><h6 id="具有相同基类型的指针"><a href="#具有相同基类型的指针" class="headerlink" title="具有相同基类型的指针"></a>具有相同基类型的指针</h6><h6 id="具有相同元素类型和长度的array"><a href="#具有相同元素类型和长度的array" class="headerlink" title="具有相同元素类型和长度的array"></a>具有相同元素类型和长度的array</h6><h6 id="具有相同元素类型的slice"><a href="#具有相同元素类型的slice" class="headerlink" title="具有相同元素类型的slice"></a>具有相同元素类型的slice</h6><h6 id="具有相同键值类型的map"><a href="#具有相同键值类型的map" class="headerlink" title="具有相同键值类型的map"></a>具有相同键值类型的map</h6><h6 id="具有相同元素类型和传送方向的channel"><a href="#具有相同元素类型和传送方向的channel" class="headerlink" title="具有相同元素类型和传送方向的channel"></a>具有相同元素类型和传送方向的channel</h6><h6 id="具有相同字段序列（字段名，类型，标签，顺序）的匿名struct"><a href="#具有相同字段序列（字段名，类型，标签，顺序）的匿名struct" class="headerlink" title="具有相同字段序列（字段名，类型，标签，顺序）的匿名struct"></a>具有相同字段序列（字段名，类型，标签，顺序）的匿名struct</h6><h6 id="签名相同（参数和返回值，不包括参数名称）的function"><a href="#签名相同（参数和返回值，不包括参数名称）的function" class="headerlink" title="签名相同（参数和返回值，不包括参数名称）的function"></a>签名相同（参数和返回值，不包括参数名称）的function</h6><h6 id="方法集相同（方法名，方法签名相同和次序无关）的interface"><a href="#方法集相同（方法名，方法签名相同和次序无关）的interface" class="headerlink" title="方法集相同（方法名，方法签名相同和次序无关）的interface"></a>方法集相同（方法名，方法签名相同和次序无关）的interface</h6><h6 id="可用type在全局或函数内定义新类型"><a href="#可用type在全局或函数内定义新类型" class="headerlink" title="可用type在全局或函数内定义新类型"></a>可用type在全局或函数内定义新类型</h6><pre><code>package main

func main() {
    type bigint int64
    var x bigint = 100
    println(x)
}
</code></pre><h6 id="新类型不是原类型的别名，除拥有相同数据存储结构外，他们之间没有任何关系，不会持有原类型任何信息，除非目标类型是未命名类型，否则必须显示转换"><a href="#新类型不是原类型的别名，除拥有相同数据存储结构外，他们之间没有任何关系，不会持有原类型任何信息，除非目标类型是未命名类型，否则必须显示转换" class="headerlink" title="新类型不是原类型的别名，除拥有相同数据存储结构外，他们之间没有任何关系，不会持有原类型任何信息，除非目标类型是未命名类型，否则必须显示转换"></a>新类型不是原类型的别名，除拥有相同数据存储结构外，他们之间没有任何关系，不会持有原类型任何信息，除非目标类型是未命名类型，否则必须显示转换</h6><pre><code>package main

import (
    &quot;fmt&quot;
)

func main() {
    type bigint int64
    x := 1234
    var b bigint = bigint(x)
    var b2 int64 = int64(b)

    fmt.Println(b,b2)
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><pre><code>package main

func main() {
    var b byte = 100
    v]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记枚举]]></title>
    <link href="http://www.cxyteam.com/2017/02/20/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%9E%9A%E4%B8%BE/"/>
    <id>http://www.cxyteam.com/2017/02/20/go学习笔记枚举/</id>
    <published>2017-02-20T11:32:10.000Z</published>
    <updated>2017-03-01T12:06:07.000Z</updated>
    <content type="html"><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h6 id="关键字iota定义常量数组中从0开始安航基数的自增枚举值"><a href="#关键字iota定义常量数组中从0开始安航基数的自增枚举值" class="headerlink" title="关键字iota定义常量数组中从0开始安航基数的自增枚举值"></a>关键字iota定义常量数组中从0开始安航基数的自增枚举值</h6><pre><code>package main

func main() {
    const (
        a = iota
        b
        c
        d
    )

    println(a,b,c,d)    //0 1 2 3
}
</code></pre><h6 id="同一个常量组中可以提供多个iota，它们各自增长"><a href="#同一个常量组中可以提供多个iota，它们各自增长" class="headerlink" title="同一个常量组中可以提供多个iota，它们各自增长"></a>同一个常量组中可以提供多个iota，它们各自增长</h6><pre><code>package main

func main() {
    const (
        a,b = iota, iota
        c,d
        e,f
    )

    println(c,d)    //1 1
}
</code></pre><h6 id="如果iota自增被打断，须显示恢复"><a href="#如果iota自增被打断，须显示恢复" class="headerlink" title="如果iota自增被打断，须显示恢复"></a>如果iota自增被打断，须显示恢复</h6><pre><code>package main

func main() {
    const (
        a = iota
        b = &quot;a&quot;
        c = 100
        d = iota
        e
    )

    println(d, e)   //3 4 常量值d进行了显示恢复iota的值，计算的时候算上了b,c两行
}
</code></pre><h6 id="可通过自定义类型来限制枚举类型限制"><a href="#可通过自定义类型来限制枚举类型限制" class="headerlink" title="可通过自定义类型来限制枚举类型限制"></a>可通过自定义类型来限制枚举类型限制</h6><pre><code>package main

type test int   //声明一个自定义类型

const (
    black test = iota   //注意black需要制定一个test类型
    red
    blue
)

func demo(c test) {}    //函数指定传入test类型

func main() {
    x := red
    demo(x)
    x := 1
    demo(x)         //报错，此处的x类型已经变成了int类型
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h6 id="关键字iota定义常量数组中从0开始安航基数的自增枚举值"><a href="#关键字iota定义常量数组中从0开始安航基数的自增]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
</feed>