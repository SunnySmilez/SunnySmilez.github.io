<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[狂奔的菜鸟]]></title>
  <subtitle><![CDATA[当你的实力支撑不起你的野心的时候，静下心来好好学习吧！]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.cxyteam.com/"/>
  <updated>2017-05-08T12:53:28.000Z</updated>
  <id>http://www.cxyteam.com/</id>
  
  <author>
    <name><![CDATA[狂奔的菜鸟]]></name>
    <email><![CDATA[phpchengxuyuan@sina.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[编译reids的sds文件]]></title>
    <link href="http://www.cxyteam.com/2017/05/08/%E7%BC%96%E8%AF%91reids%E7%9A%84sds%E6%96%87%E4%BB%B6/"/>
    <id>http://www.cxyteam.com/2017/05/08/编译reids的sds文件/</id>
    <published>2017-05-08T12:30:02.000Z</published>
    <updated>2017-05-08T12:53:28.000Z</updated>
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h6 id="在学习redis源码的时候，只能傻傻的看代码，运行结果全靠猜，实在是忍受不了，就想着我能否像写php一样，不懂的直接运行起来"><a href="#在学习redis源码的时候，只能傻傻的看代码，运行结果全靠猜，实在是忍受不了，就想着我能否像写php一样，不懂的直接运行起来" class="headerlink" title="在学习redis源码的时候，只能傻傻的看代码，运行结果全靠猜，实在是忍受不了，就想着我能否像写php一样，不懂的直接运行起来"></a>在学习redis源码的时候，只能傻傻的看代码，运行结果全靠猜，实在是忍受不了，就想着我能否像写php一样，不懂的直接运行起来</h6><h1 id="初试"><a href="#初试" class="headerlink" title="初试"></a>初试</h1><h6 id="想当然的，sds-c的文件嘛，直接使用如下命令"><a href="#想当然的，sds-c的文件嘛，直接使用如下命令" class="headerlink" title="想当然的，sds.c的文件嘛，直接使用如下命令"></a>想当然的，sds.c的文件嘛，直接使用如下命令</h6><pre><code>gcc sds.c -o sds.o
</code></pre><h6 id="结果也很想当然的报错"><a href="#结果也很想当然的报错" class="headerlink" title="结果也很想当然的报错"></a>结果也很想当然的报错</h6><p><img src="/img/redis/sds_gcc_error.png" alt="Alt text" title="写出代码"></p>
<h5 id="本能的去指定头文件-依旧报错"><a href="#本能的去指定头文件-依旧报错" class="headerlink" title="本能的去指定头文件,依旧报错"></a>本能的去指定头文件,依旧报错</h5><pre><code>gcc -I sds.h zmalloc.h sds.c -o sds.o
</code></pre><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><h6 id="google后得知，是动态链接库没指定好"><a href="#google后得知，是动态链接库没指定好" class="headerlink" title="google后得知，是动态链接库没指定好"></a>google后得知，是动态链接库没指定好</h6><h6 id="首先删除’-ifdef-SDS-TEST-MAIN’以及’-endif’，虽然我不太能看懂，猜测就是只有在’SDS-TEST-MAIN’这个存在的时候，才去定义main函数，由于我不知道SDS-TEST-MAIN他是在哪个文件中定义的，所以干脆直接删除，反正我也只是为了看运行结果"><a href="#首先删除’-ifdef-SDS-TEST-MAIN’以及’-endif’，虽然我不太能看懂，猜测就是只有在’SDS-TEST-MAIN’这个存在的时候，才去定义main函数，由于我不知道SDS-TEST-MAIN他是在哪个文件中定义的，所以干脆直接删除，反正我也只是为了看运行结果" class="headerlink" title="首先删除’#ifdef SDS_TEST_MAIN’以及’#endif’，虽然我不太能看懂，猜测就是只有在’SDS_TEST_MAIN’这个存在的时候，才去定义main函数，由于我不知道SDS_TEST_MAIN他是在哪个文件中定义的，所以干脆直接删除，反正我也只是为了看运行结果"></a>首先删除’#ifdef SDS_TEST_MAIN’以及’#endif’，虽然我不太能看懂，猜测就是只有在’SDS_TEST_MAIN’这个存在的时候，才去定义main函数，由于我不知道SDS_TEST_MAIN他是在哪个文件中定义的，所以干脆直接删除，反正我也只是为了看运行结果</h6><h6 id="编译动态链接库"><a href="#编译动态链接库" class="headerlink" title="编译动态链接库"></a>编译动态链接库</h6><pre><code>gcc zmalloc.c -fPIC -shared -o libzmalloc.so
命名的格式需要注意一下，lib+文件名+&apos;.so&apos;
</code></pre><h6 id="指定动态链接库，编译sds-c"><a href="#指定动态链接库，编译sds-c" class="headerlink" title="指定动态链接库，编译sds.c"></a>指定动态链接库，编译sds.c</h6><pre><code>gcc sds.c -L. -l zmalloc -o sds.o
-L：添加库文件的搜索路径
-l：指定需要链接的库，该名字就是lib***.so中的名称
</code></pre><h6 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h6><pre><code>./sds.o
</code></pre><h6 id="非常开心，感觉在看redis源码的路上又走了一大步，准备看源码好久了，为了看源码还学了c，之前断断续续看了一段时间，昨天把sds-c看懂了今天运行起来了，不错！"><a href="#非常开心，感觉在看redis源码的路上又走了一大步，准备看源码好久了，为了看源码还学了c，之前断断续续看了一段时间，昨天把sds-c看懂了今天运行起来了，不错！" class="headerlink" title="非常开心，感觉在看redis源码的路上又走了一大步，准备看源码好久了，为了看源码还学了c，之前断断续续看了一段时间，昨天把sds.c看懂了今天运行起来了，不错！"></a>非常开心，感觉在看redis源码的路上又走了一大步，准备看源码好久了，为了看源码还学了c，之前断断续续看了一段时间，昨天把sds.c看懂了今天运行起来了，不错！</h6><p><img src="/img/redis/sds_gcc_succ.png" alt="Alt text" title="写出代码"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h6 id="在学习redis源码的时候，只能傻傻的看代码，运行结果全靠猜，实在是忍受不了，就想着我能否像写php一样，不懂的直接运行起来"><]]>
    </summary>
    
      <category term="Redis" scheme="http://www.cxyteam.com/tags/Redis/"/>
    
      <category term="Redis" scheme="http://www.cxyteam.com/categories/Redis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一个产品的诞生]]></title>
    <link href="http://www.cxyteam.com/2017/04/26/%E4%B8%80%E4%B8%AA%E4%BA%A7%E5%93%81%E7%9A%84%E8%AF%9E%E7%94%9F/"/>
    <id>http://www.cxyteam.com/2017/04/26/一个产品的诞生/</id>
    <published>2017-04-26T09:11:55.000Z</published>
    <updated>2017-04-27T04:01:57.000Z</updated>
    <content type="html"><![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><h5 id="此文介绍的是一个产品从需求调研到上线的整个流程，整个产品历经3周，参与人数4人，经历了下图三个阶段：找出痛点，缕清需求，写出代码"><a href="#此文介绍的是一个产品从需求调研到上线的整个流程，整个产品历经3周，参与人数4人，经历了下图三个阶段：找出痛点，缕清需求，写出代码" class="headerlink" title="此文介绍的是一个产品从需求调研到上线的整个流程，整个产品历经3周，参与人数4人，经历了下图三个阶段：找出痛点，缕清需求，写出代码"></a>此文介绍的是一个产品从需求调研到上线的整个流程，整个产品历经3周，参与人数4人，经历了下图三个阶段：找出痛点，缕清需求，写出代码</h5><p><img src="/img/zfeasyloan/jieduan.png" alt="Alt text" title="历经阶段"></p>
<h1 id="项目起源"><a href="#项目起源" class="headerlink" title="项目起源"></a>项目起源</h1><h5 id="在和流量战场的一次会议中，卡卡西老师对于业务的预测，未来一个月后，我们将会有大量的订单进入，为了提高目前我们对未来订单的应对能力，我们需要一个跟单系统，至于需要什么信息，有什么功能，做成什么样子，这些内容一概不知"><a href="#在和流量战场的一次会议中，卡卡西老师对于业务的预测，未来一个月后，我们将会有大量的订单进入，为了提高目前我们对未来订单的应对能力，我们需要一个跟单系统，至于需要什么信息，有什么功能，做成什么样子，这些内容一概不知" class="headerlink" title="在和流量战场的一次会议中，卡卡西老师对于业务的预测，未来一个月后，我们将会有大量的订单进入，为了提高目前我们对未来订单的应对能力，我们需要一个跟单系统，至于需要什么信息，有什么功能，做成什么样子，这些内容一概不知"></a>在和流量战场的一次会议中，卡卡西老师对于业务的预测，未来一个月后，我们将会有大量的订单进入，为了提高目前我们对未来订单的应对能力，我们需要一个跟单系统，至于需要什么信息，有什么功能，做成什么样子，这些内容一概不知</h5><h1 id="找出痛点"><a href="#找出痛点" class="headerlink" title="找出痛点"></a>找出痛点</h1><h5 id="这是我们进入的第一个阶段，我们需要知道：我们的服务用户是谁，我们的用户需要什么样的东西，我们的产品需要解决什么问题，为了解答这几个问题，我们做了如下事情："><a href="#这是我们进入的第一个阶段，我们需要知道：我们的服务用户是谁，我们的用户需要什么样的东西，我们的产品需要解决什么问题，为了解答这几个问题，我们做了如下事情：" class="headerlink" title="这是我们进入的第一个阶段，我们需要知道：我们的服务用户是谁，我们的用户需要什么样的东西，我们的产品需要解决什么问题，为了解答这几个问题，我们做了如下事情："></a>这是我们进入的第一个阶段，我们需要知道：我们的服务用户是谁，我们的用户需要什么样的东西，我们的产品需要解决什么问题，为了解答这几个问题，我们做了如下事情：</h5><p><img src="/img/zfeasyloan/tongdian.png" alt="Alt text" title="找出痛点的阶段"></p>
<h3 id="贴近用户"><a href="#贴近用户" class="headerlink" title="贴近用户"></a>贴近用户</h3><ol>
<li><p>向前线索要情报</p>
<ul>
<li>夜一提供助贷流程图</li>
<li>索隆提供培训资料<br><img src="/img/zfeasyloan/process1.png" alt="Alt text" title="助贷流程">    </li>
</ul>
</li>
<li><p>参与战斗</p>
<ul>
<li>跟商务线下跑触点，谈合作</li>
<li>和运营去和用户面聊，参与整个跟单（由于调研期间没有订单，所以更多的是询问有跟单经验的小伙伴）</li>
</ul>
</li>
</ol>
<h3 id="访谈用户"><a href="#访谈用户" class="headerlink" title="访谈用户"></a>访谈用户</h3><ol>
<li><p>制作MRD</p>
<ul>
<li>进行市场调研，参加商务的早晚效率（由于团队成员中阿葵亚对运营很了解，所以重心点放在商务）</li>
<li>驻扎前线，反馈信息（阿葵亚驻扎深圳战场），最终出具MRD文档，用户画像，行业报告<br><img src="/img/zfeasyloan/youli.png" alt="Alt text" title="MRD文档要点-尤里，空波提供">   </li>
</ul>
</li>
<li><p>准备调查问卷</p>
<ul>
<li>获取到的信息的疑惑点，想要了解的信息以问卷的方式进行调查（这一步最终没做）</li>
<li>问题需要具备非开放式，尽量设置成是或者否的方式</li>
<li>问问题方式不具备引导性</li>
</ul>
</li>
<li><p>进行竞品分析</p>
<ul>
<li>快鸽</li>
<li>按揭帮</li>
<li>数据项，数据名称，数据排版的理由</li>
<li>理解对方的业务流程</li>
<li>思考为什么会有这个功能点</li>
<li>服务的对象，产品的定位</li>
</ul>
</li>
</ol>
<h3 id="成为用户"><a href="#成为用户" class="headerlink" title="成为用户"></a>成为用户</h3><ol>
<li>把自己当做自己的用户实际的去思考，我在工作的时候什么状态是不满的</li>
<li>以下是我在当时状态下了解到各个角色的工作内容以后，把自己当做该角色提出的疑惑点<br><img src="/img/zfeasyloan/shangwu.png" alt="Alt text" title="我是商务"><br><img src="/img/zfeasyloan/chudian.png" alt="Alt text" title="我是触点"><br><img src="/img/zfeasyloan/yunying.png" alt="Alt text" title="我是运营"> </li>
</ol>
<h3 id="这一阶段的产出，了解到需要解决的痛点"><a href="#这一阶段的产出，了解到需要解决的痛点" class="headerlink" title="这一阶段的产出，了解到需要解决的痛点"></a>这一阶段的产出，了解到需要解决的痛点</h3><ol>
<li>内部：商务和运营同步信息</li>
<li>外部：用户和触点及时看到信息</li>
</ol>
<h1 id="缕清需求"><a href="#缕清需求" class="headerlink" title="缕清需求"></a>缕清需求</h1><h5 id="在找出痛点阶段，对于我们的触点，商务，运营的工作内容及触点的工作内容及痛点都具备了一定的理解，每个人都自己的一些想法，我们小组成员需要把自己的想法画出来，进行交叉认证，然后达到一致，再往后续的落地走，保证大家方向无偏差，大概过程如下："><a href="#在找出痛点阶段，对于我们的触点，商务，运营的工作内容及触点的工作内容及痛点都具备了一定的理解，每个人都自己的一些想法，我们小组成员需要把自己的想法画出来，进行交叉认证，然后达到一致，再往后续的落地走，保证大家方向无偏差，大概过程如下：" class="headerlink" title="在找出痛点阶段，对于我们的触点，商务，运营的工作内容及触点的工作内容及痛点都具备了一定的理解，每个人都自己的一些想法，我们小组成员需要把自己的想法画出来，进行交叉认证，然后达到一致，再往后续的落地走，保证大家方向无偏差，大概过程如下："></a>在找出痛点阶段，对于我们的触点，商务，运营的工作内容及触点的工作内容及痛点都具备了一定的理解，每个人都自己的一些想法，我们小组成员需要把自己的想法画出来，进行交叉认证，然后达到一致，再往后续的落地走，保证大家方向无偏差，大概过程如下：</h5><p><img src="/img/zfeasyloan/xuqiu.png" alt="Alt text" title="缕清阶段"></p>
<h3 id="制定use-case"><a href="#制定use-case" class="headerlink" title="制定use case"></a>制定use case</h3><ol>
<li>找出报单到最后反润中的整个流程的场景，分离出来</li>
</ol>
<ul>
<li>反思：在这个过程，没有进行场景划分，导致我把很多调研的小块小块的需求堆积在一起，没有主次之分，也没办法串联各个小块的需求<br>初期我的原型图是这样的(看目录就能看出来很乱)：<br><img src="/img/zfeasyloan/chuqi.png" alt="Alt text" title="混乱的原型"></li>
</ul>
<ol>
<li>按实际的use case为路径，串联参与的角色需要做的事，梳理出整个系统应具备的功能</li>
</ol>
<ul>
<li>反思：在这个过程中，我是按照各个角色去梳理他们需要参与的事情，导致会缺少部分功能</li>
</ul>
<ol>
<li>永远只给用户一种方案做一件事情，当你自己都拿不准方案的时候，用户一定比你更懵</li>
</ol>
<ul>
<li>反思：在触点注册的时候，由于对需求的把握不准，提供了两种方案：一种是商务注册，一种是触点注册</li>
</ul>
<h3 id="美化PRD"><a href="#美化PRD" class="headerlink" title="美化PRD"></a>美化PRD</h3><ol>
<li>如何使用Axure（找无所不能的产品经理教你吧，或许下次会有简单的教程）</li>
<li>判断整个保留下来的use case是否保证闭环了，比如说你有商务在进行操作，但是商务的角色在哪产生都没去想，这就是明显的错误了</li>
<li>按照use case画出各个参与方的整体流程图</li>
</ol>
<ul>
<li>反思：在做这个的时候，我是直接在各个页面之间加了点击事件，企图模拟出整个流程，你可以想象一下，当我给大家在将我的流程的时候，我不断的在页面间切换来切换去，别人不断问你这个是谁的页面的时候的想死的心情，废话不多说，贴出整体的页面流程图：<br><img src="/img/zfeasyloan/process_all_1.png" alt="Alt text" title="整体的页面切换原型"><br><img src="/img/zfeasyloan/process_all_2.png" alt="Alt text" title="整体的流程"></li>
</ul>
<ol>
<li>细化每个小页面的图</li>
<li>参考竞品，按最优的方式展示，包括页面元素，最重要的是字段展示顺序</li>
<li>注重小细节，用户操作习惯，比如说如果是订单显示，这个时候，用户有疑问，能否在页尾就找到负责人电话</li>
</ol>
<ul>
<li>反思：对于这几个点个人建议还是交给专业的人，让我们万能的产品来做吧，毕竟这些东西不是一蹴而就的，当然如果你够强，那我也不拦你</li>
<li>没有对比就没有伤害，看看下面两幅图<br><img src="/img/zfeasyloan/bad_face.png" alt="Alt text" title="我做的"><br><img src="/img/zfeasyloan/good_face.png" alt="Alt text" title="不知道谁做的"></li>
</ul>
<h3 id="出UI图"><a href="#出UI图" class="headerlink" title="出UI图"></a>出UI图</h3><ol>
<li>可以提前做一些颜色基调的设计，基础元素的设计，比如按钮，导航等</li>
<li>有类似logo之类的设计，可以并行做</li>
<li>尽快把PRD敲定</li>
</ol>
<ul>
<li>反思：由于对设计师工作的不太了解，没能提前的让设计参与进来，尤其是logo图，到了临了才发现原来还有logo没做</li>
</ul>
<h1 id="写出代码"><a href="#写出代码" class="headerlink" title="写出代码"></a>写出代码</h1><h5 id="作为技术，这是我们最熟悉的一个战场，任务虽然圆满完成了，然而还是有很多不足，大概过程如下："><a href="#作为技术，这是我们最熟悉的一个战场，任务虽然圆满完成了，然而还是有很多不足，大概过程如下：" class="headerlink" title="作为技术，这是我们最熟悉的一个战场，任务虽然圆满完成了，然而还是有很多不足，大概过程如下："></a>作为技术，这是我们最熟悉的一个战场，任务虽然圆满完成了，然而还是有很多不足，大概过程如下：</h5><p><img src="/img/zfeasyloan/code.png" alt="Alt text" title="写出代码"></p>
<h3 id="做出计划"><a href="#做出计划" class="headerlink" title="做出计划"></a>做出计划</h3><ol>
<li>按照倒推的方式进行时间规划（deadline摆在那）</li>
</ol>
<ul>
<li>从后往前推，上线需要多长时间部署，测试需要多长时间，联调需要多长时间，那么剩下的就是开发时间了，不够？那就从别的地方挤时间吧</li>
</ul>
<ol>
<li>划分出所有能够并行的任务</li>
</ol>
<ul>
<li>比如微信公众号认证，模板消息申请，域名，线上环境部署，前后端分离开发…</li>
</ul>
<ol>
<li>制定好时间节点后，同步让大家知道，留下邮件</li>
</ol>
<ul>
<li>定好没个时间节点应出的东西，然后小组达成一致，最后再邮件通知大家</li>
<li>反思：在这个过程中，定好了时间节点，在实施的时候，有的东西未能到位，比如说：10号截止需求的变更，理论上是需要在10号的时候，所有的东西都定下来，然后再12号才拿到设计好的ui图；最终没能邮件通知到大家，只是过了一个会，这个相当于是一个承诺式的工作方式，过会后，需要把结论发送邮件给大家，避免大家忘记各个时间节点或者有部分突然的变更</li>
</ul>
<ol>
<li>反馈进度</li>
</ol>
<ul>
<li>这个当然不用说，实时的反馈进度，让整个小组，关心这个项目的人员清楚，现在我们在哪一个阶段，需要什么帮助，有什么风险点</li>
<li>反思：在这个阶段是做的最不好的，项目进入开发的时候，就相当于进入黑盒了，知道最后上完线，大家才恍然大悟，原来上线了；给自己找几个小借口，项目时间太紧了，可能反馈进度，需要花费时间，所以偷懒了；其次，项目功能不太多，没法进行阶段性反馈（其实都是借口，哪怕花一分钟的时间，大概说下做完哪些了，大家心里也有数）</li>
</ul>
<h3 id="并行开发"><a href="#并行开发" class="headerlink" title="并行开发"></a>并行开发</h3><ol>
<li>并行并不是说各自开发各自的，到联调的时候再进行沟通，需要时刻保持沟通</li>
</ol>
<ul>
<li>比如说在开发的时候，遇到多种角色如何传递角色id的情况，页面判断如何做，及时的沟通，达到一致后，再开始干活</li>
<li>这块做的其实还不错，鼓励下自己，可能是前端是合作的老伙伴了，得心应手</li>
</ul>
<ol>
<li>规范好接口，写好接口文档，能够减少很多沟通成本</li>
</ol>
<ul>
<li>接口做好规范，命名，数据返回格式（看着设计图来，尽量把格式都转换好），避免前端关键字，比如分页时候的length，返回的时候读返回json数组，一会对象一会数组，还是很容易抓狂的，该get就get该post就post（get，post区别不知道？google去吧）</li>
<li>必要的接口文档，至少得说明：接口地址是什么，上送值是什么，返回数据的含义</li>
<li>这块也做的不错，接口文档，返回数据格式各方面能想到的还是去做好了，虽然最后接口字段可能不断地在变，这也不可避免</li>
</ul>
<h3 id="测试上线"><a href="#测试上线" class="headerlink" title="测试上线"></a>测试上线</h3><ol>
<li>执行use case</li>
</ol>
<ul>
<li>这个比较简单，直接按照PRD走正常流程就行，一般都没问题，开发就是按照这个流程做的</li>
</ul>
<ol>
<li>执行异常逻辑</li>
</ol>
<ul>
<li>特殊的场景，比如注册了，没完善信息报单会如何，注册了，商务未登录过消息怎么发送</li>
<li>这块没有去专门的列所有的场景然后进行测试，而是发动了群众的力量进行测试（测试完之后内心还是忐忑的）</li>
</ul>
<h1 id="最初的计划"><a href="#最初的计划" class="headerlink" title="最初的计划"></a>最初的计划</h1><h3 id="最后晒一个设想的开发计划，自己感受下"><a href="#最后晒一个设想的开发计划，自己感受下" class="headerlink" title="最后晒一个设想的开发计划，自己感受下"></a>最后晒一个设想的开发计划，自己感受下</h3><h6 id="友情提示，记得和第一张图对比着看，理想和现实的差距"><a href="#友情提示，记得和第一张图对比着看，理想和现实的差距" class="headerlink" title="友情提示，记得和第一张图对比着看，理想和现实的差距"></a>友情提示，记得和第一张图对比着看，理想和现实的差距</h6><p><img src="/img/zfeasyloan/plan.png" alt="Alt text" title="初期计划"></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h1><h5 id="此文介绍的是一个产品从需求调研到上线的整个流程，整个产品历经3周，参与人数4人，经历了下图三个阶段：找出痛点，缕清]]>
    </summary>
    
      <category term="Other" scheme="http://www.cxyteam.com/tags/Other/"/>
    
      <category term="Other" scheme="http://www.cxyteam.com/categories/Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go命令]]></title>
    <link href="http://www.cxyteam.com/2017/04/18/go%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.cxyteam.com/2017/04/18/go命令/</id>
    <published>2017-04-17T16:45:19.000Z</published>
    <updated>2017-04-17T16:45:19.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go项目的运行]]></title>
    <link href="http://www.cxyteam.com/2017/04/18/go%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%BF%90%E8%A1%8C/"/>
    <id>http://www.cxyteam.com/2017/04/18/go项目的运行/</id>
    <published>2017-04-17T16:40:15.000Z</published>
    <updated>2017-04-17T16:40:15.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[redis安全]]></title>
    <link href="http://www.cxyteam.com/2017/04/16/redis%E5%AE%89%E5%85%A8/"/>
    <id>http://www.cxyteam.com/2017/04/16/redis安全/</id>
    <published>2017-04-16T11:27:37.000Z</published>
    <updated>2017-04-17T12:00:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h6 id="场景一：在应用访问数不多，单机能撑起的情况下，应用和redis服务可以搭建在一台机器上，设置redis只允许本机访问，这种方式是最安全的"><a href="#场景一：在应用访问数不多，单机能撑起的情况下，应用和redis服务可以搭建在一台机器上，设置redis只允许本机访问，这种方式是最安全的" class="headerlink" title="场景一：在应用访问数不多，单机能撑起的情况下，应用和redis服务可以搭建在一台机器上，设置redis只允许本机访问，这种方式是最安全的"></a>场景一：在应用访问数不多，单机能撑起的情况下，应用和redis服务可以搭建在一台机器上，设置redis只允许本机访问，这种方式是最安全的</h6><h6 id="场景二：当应用访问数增多的时候，单机难以支撑的情况时，会有两种办法解决"><a href="#场景二：当应用访问数增多的时候，单机难以支撑的情况时，会有两种办法解决" class="headerlink" title="场景二：当应用访问数增多的时候，单机难以支撑的情况时，会有两种办法解决"></a>场景二：当应用访问数增多的时候，单机难以支撑的情况时，会有两种办法解决</h6><pre><code>1，应用部署在多台机器上，使用负载均衡进行访问，redis部署在一台应用机器上
2，应用部署在多台机器上，使用负载均衡进行访问，redis部署在独立的机器上
</code></pre><h6 id="这两种访问都不能再进行局域网访问，那么redis的安全就是一个问题"><a href="#这两种访问都不能再进行局域网访问，那么redis的安全就是一个问题" class="headerlink" title="这两种访问都不能再进行局域网访问，那么redis的安全就是一个问题"></a>这两种访问都不能再进行局域网访问，那么redis的安全就是一个问题</h6><h6 id="举个栗子，目前就有很多脚本在对公网的6379端口，进行扫描，然后获取到ip，进行连接"><a href="#举个栗子，目前就有很多脚本在对公网的6379端口，进行扫描，然后获取到ip，进行连接" class="headerlink" title="举个栗子，目前就有很多脚本在对公网的6379端口，进行扫描，然后获取到ip，进行连接"></a>举个栗子，目前就有很多脚本在对公网的6379端口，进行扫描，然后获取到ip，进行连接</h6><h3 id="解决办法（设置redis密码）"><a href="#解决办法（设置redis密码）" class="headerlink" title="解决办法（设置redis密码）"></a>解决办法（设置redis密码）</h3><h6 id="打开redis公网访问，编辑redis配置文件，注释bind-127-0-0-1这行"><a href="#打开redis公网访问，编辑redis配置文件，注释bind-127-0-0-1这行" class="headerlink" title="打开redis公网访问，编辑redis配置文件，注释bind 127.0.0.1这行"></a>打开redis公网访问，编辑redis配置文件，注释bind 127.0.0.1这行</h6><p><img src="/img/redis-pwd/redis-net-work.png" alt="Alt text" title="打开redis公网访问"></p>
<h6 id="设置redis访问密码，编辑redis配置文件，设置requirepass，后面就是密码"><a href="#设置redis访问密码，编辑redis配置文件，设置requirepass，后面就是密码" class="headerlink" title="设置redis访问密码，编辑redis配置文件，设置requirepass，后面就是密码"></a>设置redis访问密码，编辑redis配置文件，设置requirepass，后面就是密码</h6><p><img src="/img/redis-pwd/redis-pwd.png" alt="Alt text" title="设置redis访问密码"></p>
<h6 id="使用auth进行连接，使用auth进行连接，redis提供了auth接口"><a href="#使用auth进行连接，使用auth进行连接，redis提供了auth接口" class="headerlink" title="使用auth进行连接，使用auth进行连接，redis提供了auth接口"></a>使用auth进行连接，使用auth进行连接，redis提供了auth接口</h6><p><img src="/img/redis-pwd/auth.png" alt="Alt text" title="auth连接"></p>
<h3 id="延伸两点"><a href="#延伸两点" class="headerlink" title="延伸两点"></a>延伸两点</h3><h6 id="危险命令重命名"><a href="#危险命令重命名" class="headerlink" title="危险命令重命名"></a>危险命令重命名</h6><pre><code>编辑配置文件，添加如下行：
    rename-command FLUSHALL &quot;&quot;
</code></pre><h6 id="使用linux的nobody用户启动redis服务（因为nobody用户是无法登录的）"><a href="#使用linux的nobody用户启动redis服务（因为nobody用户是无法登录的）" class="headerlink" title="使用linux的nobody用户启动redis服务（因为nobody用户是无法登录的）"></a>使用linux的nobody用户启动redis服务（因为nobody用户是无法登录的）</h6>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><h6 id="场景一：在应用访问数不多，单机能撑起的情况下，应用和redis服务可以搭建在一台机器上，设置redis只允许本机访]]>
    </summary>
    
      <category term="Redis" scheme="http://www.cxyteam.com/tags/Redis/"/>
    
      <category term="Redis" scheme="http://www.cxyteam.com/categories/Redis/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[微信开发配置]]></title>
    <link href="http://www.cxyteam.com/2017/04/06/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E9%85%8D%E7%BD%AE/"/>
    <id>http://www.cxyteam.com/2017/04/06/微信开发配置/</id>
    <published>2017-04-06T08:29:56.000Z</published>
    <updated>2017-04-14T03:11:49.000Z</updated>
    <content type="html"><![CDATA[<h1 id="公众号设置"><a href="#公众号设置" class="headerlink" title="公众号设置"></a>公众号设置</h1><h3 id="配置业务域名（公众号设置-gt-功能设置）"><a href="#配置业务域名（公众号设置-gt-功能设置）" class="headerlink" title="配置业务域名（公众号设置-&gt;功能设置）"></a>配置业务域名（公众号设置-&gt;功能设置）</h3><h6 id=""><a href="#" class="headerlink" title=""></a><img src="/img/wechat/domain.png" alt="Alt text" title="配置业务域名"></h6><h6 id="注意不需要输入http或者https"><a href="#注意不需要输入http或者https" class="headerlink" title="注意不需要输入http或者https"></a>注意不需要输入http或者https</h6><h6 id="如果是二级域名，需要一起填入"><a href="#如果是二级域名，需要一起填入" class="headerlink" title="如果是二级域名，需要一起填入"></a>如果是二级域名，需要一起填入</h6><h3 id="js接口安全域名，网页授权域名同理"><a href="#js接口安全域名，网页授权域名同理" class="headerlink" title="js接口安全域名，网页授权域名同理"></a>js接口安全域名，网页授权域名同理</h3><h1 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h1><h3 id="同意成为开发者"><a href="#同意成为开发者" class="headerlink" title="同意成为开发者"></a>同意成为开发者</h3><p><img src="/img/wechat/dev.png" alt="Alt text" title="成为开发者"></p>
<h3 id="生成appsecret"><a href="#生成appsecret" class="headerlink" title="生成appsecret"></a>生成appsecret</h3><p><img src="/img/wechat/appsecret.png" alt="Alt text" title="生成appsecret"></p>
<h3 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h3><p><img src="/img/wechat/config.png" alt="Alt text" title="服务器配置"></p>
<h6 id="需要注意的是url需要输入http-https-在域名的最后需要添加’-‘"><a href="#需要注意的是url需要输入http-https-在域名的最后需要添加’-‘" class="headerlink" title="需要注意的是url需要输入http/https 在域名的最后需要添加’/‘"></a>需要注意的是url需要输入http/https 在域名的最后需要添加’/‘</h6><p><img src="/img/wechat/dev_conf.png" alt="Alt text" title="服务器配置样例"></p>
<h3 id="token验证失败"><a href="#token验证失败" class="headerlink" title="token验证失败"></a>token验证失败</h3><h5 id="验证token的过程，是微信验证你填写的url地址是否能按照它的要求来，一般会向你填写的url发送一个get请求，对应的url需要进行一次解密，然后输出一个串（具体看文档）"><a href="#验证token的过程，是微信验证你填写的url地址是否能按照它的要求来，一般会向你填写的url发送一个get请求，对应的url需要进行一次解密，然后输出一个串（具体看文档）" class="headerlink" title="验证token的过程，是微信验证你填写的url地址是否能按照它的要求来，一般会向你填写的url发送一个get请求，对应的url需要进行一次解密，然后输出一个串（具体看文档）"></a>验证token的过程，是微信验证你填写的url地址是否能按照它的要求来，一般会向你填写的url发送一个get请求，对应的url需要进行一次解密，然后输出一个串（具体看文档）</h5><h6 id="首先去nginx中抓取请求"><a href="#首先去nginx中抓取请求" class="headerlink" title="首先去nginx中抓取请求"></a>首先去nginx中抓取请求</h6><h6 id="自己再本地测试看解密代码是否正常执行"><a href="#自己再本地测试看解密代码是否正常执行" class="headerlink" title="自己再本地测试看解密代码是否正常执行"></a>自己再本地测试看解密代码是否正常执行</h6><p><img src="/img/wechat/request.png" alt="Alt text" title="微信请求信息"></p>
<h5 id="确认公众号信息全部完善"><a href="#确认公众号信息全部完善" class="headerlink" title="确认公众号信息全部完善"></a>确认公众号信息全部完善</h5><p><img src="/img/wechat/info.png" alt="Alt text" title="完善信息"></p>
<h6 id="最后一定要启用服务器配置，千万不能忘记开启模板消息，选择正确的行业"><a href="#最后一定要启用服务器配置，千万不能忘记开启模板消息，选择正确的行业" class="headerlink" title="最后一定要启用服务器配置，千万不能忘记开启模板消息，选择正确的行业"></a>最后一定要启用服务器配置，千万不能忘记开启模板消息，选择正确的行业</h6><h1 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h1><h3 id="获取access-token，jsapi-ticket"><a href="#获取access-token，jsapi-ticket" class="headerlink" title="获取access_token，jsapi_ticket"></a>获取access_token，jsapi_ticket</h3><h6 id="建议单独写一个脚本逻辑，每30分钟更新一次access-token，jsapi-ticket，所有接口统一去redis取"><a href="#建议单独写一个脚本逻辑，每30分钟更新一次access-token，jsapi-ticket，所有接口统一去redis取" class="headerlink" title="建议单独写一个脚本逻辑，每30分钟更新一次access_token，jsapi_ticket，所有接口统一去redis取"></a>建议单独写一个脚本逻辑，每30分钟更新一次access_token，jsapi_ticket，所有接口统一去redis取</h6><h1 id="redirect-uri参数错误"><a href="#redirect-uri参数错误" class="headerlink" title="redirect_uri参数错误"></a>redirect_uri参数错误</h1><h6 id="首先可能是你的appid等参数不正确，这个先排除"><a href="#首先可能是你的appid等参数不正确，这个先排除" class="headerlink" title="首先可能是你的appid等参数不正确，这个先排除"></a>首先可能是你的appid等参数不正确，这个先排除</h6><h6 id="其次可能是你的开发-gt-接口权限-gt-网页授权接口没填写；要确认填入的uri和你请求微信传入的uri是一致的"><a href="#其次可能是你的开发-gt-接口权限-gt-网页授权接口没填写；要确认填入的uri和你请求微信传入的uri是一致的" class="headerlink" title="其次可能是你的开发-&gt;接口权限-&gt;网页授权接口没填写；要确认填入的uri和你请求微信传入的uri是一致的"></a>其次可能是你的开发-&gt;接口权限-&gt;网页授权接口没填写；要确认填入的uri和你请求微信传入的uri是一致的</h6><h1 id="access-denied的坑"><a href="#access-denied的坑" class="headerlink" title="access denied的坑"></a>access denied的坑</h1><h6 id="在设置token的时候，微信服务器会去test-com-MP-verify-Rj9V6BBuQjlS0myN-txt拿串，进行通讯验证，在设置nginx配置的时候，需要注意txt文件的权限"><a href="#在设置token的时候，微信服务器会去test-com-MP-verify-Rj9V6BBuQjlS0myN-txt拿串，进行通讯验证，在设置nginx配置的时候，需要注意txt文件的权限" class="headerlink" title="在设置token的时候，微信服务器会去test.com/MP_verify_Rj9V6BBuQjlS0myN.txt拿串，进行通讯验证，在设置nginx配置的时候，需要注意txt文件的权限"></a>在设置token的时候，微信服务器会去test.com/MP_verify_Rj9V6BBuQjlS0myN.txt拿串，进行通讯验证，在设置nginx配置的时候，需要注意txt文件的权限</h6><pre><code>location = /MP_verify_Rj9V6BBuQjlS0myN.txt {
        allow all;
}
</code></pre><h1 id="其余开发详情，后续再写"><a href="#其余开发详情，后续再写" class="headerlink" title="其余开发详情，后续再写"></a>其余开发详情，后续再写</h1>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="公众号设置"><a href="#公众号设置" class="headerlink" title="公众号设置"></a>公众号设置</h1><h3 id="配置业务域名（公众号设置-gt-功能设置）"><a href="#配置业务域名（公众号设置-gt-功能设置]]>
    </summary>
    
      <category term="Other" scheme="http://www.cxyteam.com/tags/Other/"/>
    
      <category term="Other" scheme="http://www.cxyteam.com/categories/Other/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记并发-channel]]></title>
    <link href="http://www.cxyteam.com/2017/03/08/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%B9%B6%E5%8F%91-channel/"/>
    <id>http://www.cxyteam.com/2017/03/08/go学习笔记并发-channel/</id>
    <published>2017-03-08T12:43:15.000Z</published>
    <updated>2017-03-12T08:46:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="引用类型channel是CSP模式的具体实现，用于多个goroutine通讯。其内部实现了同步没确保并发安全，默认为同步模式，需要发送和接收配对。否则会被阻塞，直到另一方准备好被唤醒"><a href="#引用类型channel是CSP模式的具体实现，用于多个goroutine通讯。其内部实现了同步没确保并发安全，默认为同步模式，需要发送和接收配对。否则会被阻塞，直到另一方准备好被唤醒" class="headerlink" title="引用类型channel是CSP模式的具体实现，用于多个goroutine通讯。其内部实现了同步没确保并发安全，默认为同步模式，需要发送和接收配对。否则会被阻塞，直到另一方准备好被唤醒"></a>引用类型channel是CSP模式的具体实现，用于多个goroutine通讯。其内部实现了同步没确保并发安全，默认为同步模式，需要发送和接收配对。否则会被阻塞，直到另一方准备好被唤醒</h6><pre><code>package main

import (
    &quot;fmt&quot;
)

func main() {
    data := make(chan int)      //数据交换队列
    exit := make(chan bool)     //退出通知

    go func() {
        for d := range data {   //从队列迭代接收数据，直到close
            fmt.Println(d)
        }

        fmt.Println(&quot;recv over.&quot;)
        exit &lt;- true            //发送退出通知
    }()

    data &lt;- 1                   //发送数据
    data &lt;- 2
    data &lt;- 3
    close(data)                 //关闭队列

    fmt.Println(&quot;send over.&quot;)
    &lt;-exit                      //等待退出通知
}
</code></pre><h6 id="异步方式通过判断缓冲区来觉得是否阻塞，如果缓冲区已满，发送被阻塞；缓冲区为空，接收被阻塞"><a href="#异步方式通过判断缓冲区来觉得是否阻塞，如果缓冲区已满，发送被阻塞；缓冲区为空，接收被阻塞" class="headerlink" title="异步方式通过判断缓冲区来觉得是否阻塞，如果缓冲区已满，发送被阻塞；缓冲区为空，接收被阻塞"></a>异步方式通过判断缓冲区来觉得是否阻塞，如果缓冲区已满，发送被阻塞；缓冲区为空，接收被阻塞</h6><pre><code>package main

import (
    &quot;fmt&quot;
)

func main() {
    data := make(chan int, 3)
    exit := make(chan bool)
    data &lt;- 1
    data &lt;- 2
    data &lt;- 3
    go func() {
        for d := range data {
            fmt.Println(d)
        }

        exit &lt;- true
    }()

    data &lt;- 4
    data &lt;- 5
    close(data)

    &lt;- exit
}
</code></pre><h6 id="可以将channel隐士转换为单向队列，只收或只发"><a href="#可以将channel隐士转换为单向队列，只收或只发" class="headerlink" title="可以将channel隐士转换为单向队列，只收或只发"></a>可以将channel隐士转换为单向队列，只收或只发</h6><pre><code>package main

import (
)

func main() {
    c := make(chan int, 3)
    var send chan &lt;- int = c
    var recv &lt;- chan int = c
    send &lt;- 1
    //&lt;- send           //receive from send-only type chan&lt;- int
    //recv &lt;- 2         //send to receive-only type &lt;-chan int
    &lt;- recv
}
</code></pre><h6 id="如果同时处理多个channel，可使用select语句，它随机选择一个可用channel做收发操作，或执行default-case"><a href="#如果同时处理多个channel，可使用select语句，它随机选择一个可用channel做收发操作，或执行default-case" class="headerlink" title="如果同时处理多个channel，可使用select语句，它随机选择一个可用channel做收发操作，或执行default case"></a>如果同时处理多个channel，可使用select语句，它随机选择一个可用channel做收发操作，或执行default case</h6>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="引用类型channel是CSP模式的具体实现，用于多个goroutine通讯。其内部实现了同步没确保并发安全，默认为同步模式，需要]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记并发]]></title>
    <link href="http://www.cxyteam.com/2017/03/03/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%B9%B6%E5%8F%91/"/>
    <id>http://www.cxyteam.com/2017/03/03/go学习笔记并发/</id>
    <published>2017-03-03T10:47:39.000Z</published>
    <updated>2017-03-08T12:42:03.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="只需在函数调用语句前添加go关键字，就可创建并发执行单元"><a href="#只需在函数调用语句前添加go关键字，就可创建并发执行单元" class="headerlink" title="只需在函数调用语句前添加go关键字，就可创建并发执行单元"></a>只需在函数调用语句前添加go关键字，就可创建并发执行单元</h6><pre><code>package main

import (
    &quot;fmt&quot;
    &quot;runtime&quot;
)

func say(s string) {
    for i := 0; i &lt; 3; i++ {
        runtime.Gosched()
        fmt.Println(s) }
    }

func main() {
    go say(&quot;world&quot;)     //开一个新的Goroutines执行
    say(&quot;hello&quot;)        //当前Goroutines执行
}
</code></pre><h6 id="Goexit-退出当前执行的goroutine，但是defer函数还会继续调用"><a href="#Goexit-退出当前执行的goroutine，但是defer函数还会继续调用" class="headerlink" title="Goexit 退出当前执行的goroutine，但是defer函数还会继续调用"></a>Goexit 退出当前执行的goroutine，但是defer函数还会继续调用</h6><h6 id="NumCPU-返回CPU核数量"><a href="#NumCPU-返回CPU核数量" class="headerlink" title="NumCPU 返回CPU核数量"></a>NumCPU 返回CPU核数量</h6><h6 id="NumGoroutine-返回正在执行和排队的任务总数"><a href="#NumGoroutine-返回正在执行和排队的任务总数" class="headerlink" title="NumGoroutine 返回正在执行和排队的任务总数"></a>NumGoroutine 返回正在执行和排队的任务总数</h6><h6 id="GOMAXPROCS-用来设置可以运行的CPU核数"><a href="#GOMAXPROCS-用来设置可以运行的CPU核数" class="headerlink" title="GOMAXPROCS 用来设置可以运行的CPU核数"></a>GOMAXPROCS 用来设置可以运行的CPU核数</h6><h6 id="sync-WaitGroup-它能够一直等到所有的goroutine执行完成，并且阻塞主线程的执行，直到所有的goroutine执行完成"><a href="#sync-WaitGroup-它能够一直等到所有的goroutine执行完成，并且阻塞主线程的执行，直到所有的goroutine执行完成" class="headerlink" title="sync.WaitGroup 它能够一直等到所有的goroutine执行完成，并且阻塞主线程的执行，直到所有的goroutine执行完成"></a>sync.WaitGroup 它能够一直等到所有的goroutine执行完成，并且阻塞主线程的执行，直到所有的goroutine执行完成</h6><h6 id="Add-添加或者减少等待goroutine的数量"><a href="#Add-添加或者减少等待goroutine的数量" class="headerlink" title="Add 添加或者减少等待goroutine的数量"></a>Add 添加或者减少等待goroutine的数量</h6><h6 id="Done-相当于Add-1"><a href="#Done-相当于Add-1" class="headerlink" title="Done 相当于Add(-1)"></a>Done 相当于Add(-1)</h6><h6 id="Wait-执行阻塞，直到所有的WaitGroup数量变成0"><a href="#Wait-执行阻塞，直到所有的WaitGroup数量变成0" class="headerlink" title="Wait 执行阻塞，直到所有的WaitGroup数量变成0"></a>Wait 执行阻塞，直到所有的WaitGroup数量变成0</h6><pre><code>package main

import (
    &quot;runtime&quot;
    &quot;sync&quot;
)

func main() {
    wg := new(sync.WaitGroup)
    wg.Add(1)

    go func() {
        defer wg.Done()
        defer println(&quot;A.defer&quot;)

        func() {
            defer println(&quot;B.defer&quot;)
            runtime.Goexit()
            println(&quot;B&quot;)
        }()

        println(&quot;A&quot;)
    }()
    wg.Wait()
}
</code></pre><h6 id="Gosched-让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行"><a href="#Gosched-让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行" class="headerlink" title="Gosched 让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行"></a>Gosched 让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行</h6><pre><code>package main

import (
    &quot;runtime&quot;
    &quot;sync&quot;
)

func main() {
    //它能够一直等到所有的goroutine执行完成，并且阻塞主线程的执行，直到所有的goroutine执行完成
    wg := new(sync.WaitGroup)
    //添加或者减少等待goroutine的数量
    wg.Add(2)

    go func() {
        //相当于Add(-1)
        defer wg.Done()

        for i := 0; i &lt; 6; i++ {
            println(i)
            if i == 3 { runtime.Gosched() }
        }
    }()

    go func() {
        defer wg.Done()
        println(&quot;hello,world!&quot;)
    }()

    //执行阻塞，直到所有的WaitGroup数量变成0
    wg.Wait()
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="只需在函数调用语句前添加go关键字，就可创建并发执行单元"><a href="#只需在函数调用语句前添加go关键字，就可创建并发执]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记接口]]></title>
    <link href="http://www.cxyteam.com/2017/03/01/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%8E%A5%E5%8F%A3/"/>
    <id>http://www.cxyteam.com/2017/03/01/go学习笔记接口/</id>
    <published>2017-03-01T07:06:44.000Z</published>
    <updated>2017-03-01T12:05:45.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="接口定义一个或多个方法签名的集合，任何类型的方法集中只要拥有与之对应的全部方法就表示它’实现’了该接口，无须在该类型上显示添加接口声明"><a href="#接口定义一个或多个方法签名的集合，任何类型的方法集中只要拥有与之对应的全部方法就表示它’实现’了该接口，无须在该类型上显示添加接口声明" class="headerlink" title="接口定义一个或多个方法签名的集合，任何类型的方法集中只要拥有与之对应的全部方法就表示它’实现’了该接口，无须在该类型上显示添加接口声明"></a>接口定义一个或多个方法签名的集合，任何类型的方法集中只要拥有与之对应的全部方法就表示它’实现’了该接口，无须在该类型上显示添加接口声明</h6><h6 id="所谓接口对应方法，是指有相同名称，参数列表以及返回值。"><a href="#所谓接口对应方法，是指有相同名称，参数列表以及返回值。" class="headerlink" title="所谓接口对应方法，是指有相同名称，参数列表以及返回值。"></a>所谓接口对应方法，是指有相同名称，参数列表以及返回值。</h6><h6 id="接口命名习惯以er结尾，结构体"><a href="#接口命名习惯以er结尾，结构体" class="headerlink" title="接口命名习惯以er结尾，结构体"></a>接口命名习惯以er结尾，结构体</h6><h6 id="接口只有方法签名，没有实现"><a href="#接口只有方法签名，没有实现" class="headerlink" title="接口只有方法签名，没有实现"></a>接口只有方法签名，没有实现</h6><h6 id="接口没有数据字段"><a href="#接口没有数据字段" class="headerlink" title="接口没有数据字段"></a>接口没有数据字段</h6><h6 id="可在接口中嵌入其他接口"><a href="#可在接口中嵌入其他接口" class="headerlink" title="可在接口中嵌入其他接口"></a>可在接口中嵌入其他接口</h6><h6 id="类型可实现多个接口"><a href="#类型可实现多个接口" class="headerlink" title="类型可实现多个接口"></a>类型可实现多个接口</h6><pre><code>package main

import &quot;fmt&quot;

type Stringer interface {
    String() string         //定义了一个接口
}

type Printer interface {
    Stringer                //嵌套接口
    Print()
}

type User struct {
    id      int
    name    string
}

func (self *User) String() string {
    return fmt.Sprintf(&quot;user %d, %s&quot;, self.id, self.name)
}

func (self *User) Print() {
    fmt.Println(self.String())
}

func main() {
    var t Printer = &amp;User{1, &quot;Tom&quot;}
    t.Print()       //user 1, Tom
}
</code></pre><h6 id="空接口interface-没有任何方法签名，也就意味着任何类型都实现了空接口。"><a href="#空接口interface-没有任何方法签名，也就意味着任何类型都实现了空接口。" class="headerlink" title="空接口interface{}没有任何方法签名，也就意味着任何类型都实现了空接口。"></a>空接口interface{}没有任何方法签名，也就意味着任何类型都实现了空接口。</h6><pre><code>package main

import &quot;fmt&quot;

func Print(v interface{}) {
    fmt.Printf(&quot;%T,%v\n&quot;, v, v)
}

func main() {
    Print(1)                    //int,1
    Print(&quot;Hello, world!&quot;)      //string,Hello, world!
}
</code></pre><h6 id="匿名接口可用作变量类型或结构成员"><a href="#匿名接口可用作变量类型或结构成员" class="headerlink" title="匿名接口可用作变量类型或结构成员"></a>匿名接口可用作变量类型或结构成员</h6><pre><code>package main

import &quot;fmt&quot;

type Tester struct {
    s interface {
        String() string
    }
}

type User struct {
    id      int
    name    string
}

func (self *User) String() string {
    return fmt.Sprintf(&quot;User %d, %s&quot;, self.id, self.name)
}

func main() {
    t := Tester{&amp;User{1, &quot;Tom&quot;}}
    fmt.Println(t.s.String())
}
</code></pre><h6 id="数据指针持有的是目标对象的只读复制品，赋值完整对象或指针"><a href="#数据指针持有的是目标对象的只读复制品，赋值完整对象或指针" class="headerlink" title="数据指针持有的是目标对象的只读复制品，赋值完整对象或指针"></a>数据指针持有的是目标对象的只读复制品，赋值完整对象或指针</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id      int
    name    string
}

func main() {
    u := User{1, &quot;Tom&quot;}
    var i interface{} = u

    u.id = 2
    u.name = &quot;jack&quot;

    fmt.Printf(&quot;%v\n&quot;, u)           //{2 jack}
    fmt.Printf(&quot;%v\n&quot;, i.(User))    //{1 Tom}
}
</code></pre><h6 id="接口转型返回临时对象，只有使用指针才能修改其状态"><a href="#接口转型返回临时对象，只有使用指针才能修改其状态" class="headerlink" title="接口转型返回临时对象，只有使用指针才能修改其状态"></a>接口转型返回临时对象，只有使用指针才能修改其状态</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id      int
    name    string
}

func main() {
    u := User{1, &quot;Tom&quot;}
    var vi,pi interface{} = u, &amp;u

    //vi.(User).name = &quot;jim&quot;    //报错，不能这样修改值
    pi.(*User).name = &quot;Jack&quot;


    fmt.Printf(&quot;%v\n&quot;, vi.(User))     //{1 Tom}
    fmt.Printf(&quot;%v\n&quot;, pi.(*User))    //&amp;{1 Jack}
}
</code></pre><h6 id="利用类型推断，可判断接口对象是否某个具体的接口或类型"><a href="#利用类型推断，可判断接口对象是否某个具体的接口或类型" class="headerlink" title="利用类型推断，可判断接口对象是否某个具体的接口或类型"></a>利用类型推断，可判断接口对象是否某个具体的接口或类型</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id      int
    name    string
}

func (self *User) String() string {
    return fmt.Sprintf(&quot;%d, %s&quot;, self.id, self.name)
}

func main() {
    var o interface{} = &amp;User{1, &quot;Tom&quot;}

    if i,ok := o.(fmt.Stringer); ok {
        fmt.Println(i)      //1, Tom
    }


    u := o.(*User)
    //u := o.(User)         //报错
    fmt.Println(u)          //1, Tom
}
</code></pre><h6 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id      int
    name    string
}


func main() {
    var o interface{} = &amp;User{1, &quot;Tom&quot;}

    switch v := o.(type) {
    case nil :                  //nil类型
        fmt.Println(&quot;nil&quot;)
    case fmt.Stringer:          //interface
        fmt.Println(v)
    case func() string:         //func
        fmt.Println(v())
    case *User:
        fmt.Printf(&quot;%d, %s\n&quot;, v.id, v.name)
    default:
        fmt.Println(&quot;unknow&quot;)
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="接口定义一个或多个方法签名的集合，任何类型的方法集中只要拥有与之对应的全部方法就表示它’实现’了该接口，无须在该类型上显示添加接口]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记方法表达式]]></title>
    <link href="http://www.cxyteam.com/2017/03/01/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://www.cxyteam.com/2017/03/01/go学习笔记方法表达式/</id>
    <published>2017-03-01T03:23:27.000Z</published>
    <updated>2017-03-01T12:05:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h6 id="instance-method-args…-gt-method-value"><a href="#instance-method-args…-gt-method-value" class="headerlink" title="instance.method(args…) =&gt; method value"></a>instance.method(args…) =&gt; method value</h6><h6 id="func-instance-args-gt-method-expression"><a href="#func-instance-args-gt-method-expression" class="headerlink" title=".func(instance, args)  =&gt; method expression"></a><type>.func(instance, args)  =&gt; method expression</type></h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id      int
    name    string
}

func (self *User) Test() {
    fmt.Printf(&quot;%p, %v\n&quot;, self, self)
}

func main() {
    u := User{1, &quot;Tom&quot;}
    u.Test()        //0xc42000e1e0, &amp;{1 Tom}

    mValue := u.Test
    mValue()        //0xc42000e1e0, &amp;{1 Tom} 隐式传递receiver

    mExpression := (*User).Test
    mExpression(&amp;u) //0xc42000e1e0, &amp;{1 Tom} 显示传递receiver
}
</code></pre><h6 id="method-value会复制receiver"><a href="#method-value会复制receiver" class="headerlink" title="method value会复制receiver"></a>method value会复制receiver</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id      int
    name    string
}

func (self User) Test() {
    fmt.Println(self)
}

func main() {
    u := User{1, &quot;Tom&quot;}
    mValue := u.Test

    u.id, u.name = 2, &quot;Jack&quot;
    u.Test()        //{2 Jack}
    mValue()        //{1 Tom}
}
</code></pre><h6 id="注意receiver类型差异"><a href="#注意receiver类型差异" class="headerlink" title="注意receiver类型差异"></a>注意receiver类型差异</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id      int
    name    string
}

func (self *User) TestPointer() {
    fmt.Printf(&quot;TestPointer:%p, %v\n&quot;, self, self)
}

func (self User) TestValue() {
    fmt.Printf(&quot;TestValue:%p, %v\n&quot;, &amp;self, self)
}

func main() {
    u := User{1, &quot;Tom&quot;}
    m := User.TestValue
    m(u)        //TestValue:0xc42000e200, {1 Tom}

    a := (*User).TestPointer
    a(&amp;u)       //TestPointer:0xc42000e1e0, &amp;{1 Tom}

    b := (*User).TestValue  //*User方法集包含TestValue，前面变为func TestValue(self *User) 事迹依然是receiver value copy
    b(&amp;u)       //TestValue:0xc42000e280, {1 Tom}
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><h6 id="instance-method-args…-gt-method-value"><a href="#instance-met]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记方法集]]></title>
    <link href="http://www.cxyteam.com/2017/03/01/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95%E9%9B%86/"/>
    <id>http://www.cxyteam.com/2017/03/01/go学习笔记方法集/</id>
    <published>2017-03-01T03:17:08.000Z</published>
    <updated>2017-03-01T12:06:01.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="类型T方法集包含全部receiver-T方法"><a href="#类型T方法集包含全部receiver-T方法" class="headerlink" title="类型T方法集包含全部receiver T方法"></a>类型T方法集包含全部receiver T方法</h6><h6 id="类型T方法集合包含全部receiver-T-T方法"><a href="#类型T方法集合包含全部receiver-T-T方法" class="headerlink" title="类型T方法集合包含全部receiver T+T方法"></a>类型<em>T方法集合包含全部receiver T+</em>T方法</h6><h6 id="如类型S包含匿名字段T，则S方法集包含T方法"><a href="#如类型S包含匿名字段T，则S方法集包含T方法" class="headerlink" title="如类型S包含匿名字段T，则S方法集包含T方法"></a>如类型S包含匿名字段T，则S方法集包含T方法</h6><h6 id="如类型S包含匿名字段T，则S方法集包含T-T方法"><a href="#如类型S包含匿名字段T，则S方法集包含T-T方法" class="headerlink" title="如类型S包含匿名字段T，则S方法集包含T+T方法"></a>如类型S包含匿名字段<em>T，则S方法集包含T+</em>T方法</h6><h6 id="不管嵌入T或T，S方法集总是包含T-T方法"><a href="#不管嵌入T或T，S方法集总是包含T-T方法" class="headerlink" title="不管嵌入T或T，S方法集总是包含T+*T方法"></a>不管嵌入T或<em>T，</em>S方法集总是包含T+*T方法</h6>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="类型T方法集包含全部receiver-T方法"><a href="#类型T方法集包含全部receiver-T方法" class="]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记方法定义]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记方法定义/</id>
    <published>2017-02-28T12:30:49.000Z</published>
    <updated>2017-03-01T12:05:51.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="方法总是绑定对象实例，并隐式将实例作为第一实参"><a href="#方法总是绑定对象实例，并隐式将实例作为第一实参" class="headerlink" title="方法总是绑定对象实例，并隐式将实例作为第一实参"></a>方法总是绑定对象实例，并隐式将实例作为第一实参</h6><h6 id="只能为当前包内命名类型定义方法"><a href="#只能为当前包内命名类型定义方法" class="headerlink" title="只能为当前包内命名类型定义方法"></a>只能为当前包内命名类型定义方法</h6><h6 id="参数receiver可任意命名。如方法中未曾使用，可省略参数名"><a href="#参数receiver可任意命名。如方法中未曾使用，可省略参数名" class="headerlink" title="参数receiver可任意命名。如方法中未曾使用，可省略参数名"></a>参数receiver可任意命名。如方法中未曾使用，可省略参数名</h6><h6 id="参数receiver类型可以使T（值复制）或-T（引用或指针复制）。基类型T不能是接口或指针"><a href="#参数receiver类型可以使T（值复制）或-T（引用或指针复制）。基类型T不能是接口或指针" class="headerlink" title="参数receiver类型可以使T（值复制）或*T（引用或指针复制）。基类型T不能是接口或指针"></a>参数receiver类型可以使T（值复制）或*T（引用或指针复制）。基类型T不能是接口或指针</h6><h6 id="不支持方法重载，receiver只是参数签名的组成部分"><a href="#不支持方法重载，receiver只是参数签名的组成部分" class="headerlink" title="不支持方法重载，receiver只是参数签名的组成部分"></a>不支持方法重载，receiver只是参数签名的组成部分</h6><h6 id="可用实例value或pointer调用全部方法，编译器自动转换"><a href="#可用实例value或pointer调用全部方法，编译器自动转换" class="headerlink" title="可用实例value或pointer调用全部方法，编译器自动转换"></a>可用实例value或pointer调用全部方法，编译器自动转换</h6><h6 id="简单工厂模式返回对象事例（然而我没看懂）"><a href="#简单工厂模式返回对象事例（然而我没看懂）" class="headerlink" title="简单工厂模式返回对象事例（然而我没看懂）"></a>简单工厂模式返回对象事例（然而我没看懂）</h6><pre><code>package main

import &quot;fmt&quot;

type Queue struct {
    elements []interface{}
}

func NewQueue() *Queue {
    return &amp;Queue{make([]interface{}, 10)}
}

func (*Queue) Push(e interface{}) error {
    panic(&quot;not implemented&quot;)
}

func (self *Queue) length() int {
    return len(self.elements)
}
</code></pre><h6 id="看看receiver-T和-T的区别"><a href="#看看receiver-T和-T的区别" class="headerlink" title="看看receiver T和*T的区别"></a>看看receiver T和*T的区别</h6><pre><code>package main

import &quot;fmt&quot;

type Data struct {
    x int
}

func (self Data) ValueTest() {
    fmt.Printf(&quot;Value:%p\n&quot;, &amp;self)
}

func (self *Data) PointerTest() {
    fmt.Printf(&quot;Pointer:%p\n&quot;, self)
}

func main() {
    d := Data{}
    p := &amp;d
    fmt.Printf(&quot;Data:%p\n&quot;, p)

    d.ValueTest()
    d.PointerTest()

    p.ValueTest()
    p.PointerTest()
}
</code></pre><h6 id="匿名字段，可以像字段成员那样访问匿名字段方法，编译器负责查找"><a href="#匿名字段，可以像字段成员那样访问匿名字段方法，编译器负责查找" class="headerlink" title="匿名字段，可以像字段成员那样访问匿名字段方法，编译器负责查找"></a>匿名字段，可以像字段成员那样访问匿名字段方法，编译器负责查找</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id      int
    name    string
}

type Manager struct {
    User
}

func (self *User) Tostring() string {   //receiver = &amp;(Manager.User)
    return fmt.Sprintf(&quot;User:%p, %v&quot;, self, self)
}

func main() {
    m := Manager{User{1, &quot;Tom&quot;}}
    fmt.Printf(&quot;Manager:%p\n&quot;, &amp;m)      //Manager:0xc42007e060
    fmt.Println(m.Tostring())           //User:0xc42000e1a0, &amp;{1 Tom}
}
</code></pre><h6 id="通过匿名字段，可获得和继承类似的复用能力。依据编译器查找次序，只需在外层定义同名方法，就可以实现”override”"><a href="#通过匿名字段，可获得和继承类似的复用能力。依据编译器查找次序，只需在外层定义同名方法，就可以实现”override”" class="headerlink" title="通过匿名字段，可获得和继承类似的复用能力。依据编译器查找次序，只需在外层定义同名方法，就可以实现”override”"></a>通过匿名字段，可获得和继承类似的复用能力。依据编译器查找次序，只需在外层定义同名方法，就可以实现”override”</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id      int
    name    string
}

type Manager struct {
    User
    title string
}

func (self *User) Tostring() string {   //receiver = &amp;(Manager.User)
    return fmt.Sprintf(&quot;User:%p, %v&quot;, self, self)
}

func (self *Manager) Tostring() string {   //receiver = &amp;(Manager.User)
    return fmt.Sprintf(&quot;Manager:%p, %v&quot;, self, self)
}

func main() {
    m := Manager{User{1, &quot;Tom&quot;}, &quot;admin&quot;}
    fmt.Println(m.Tostring())           //Manager:0xc420014120, &amp;{{1 Tom} admin}
    fmt.Println(m.User.Tostring())      //User:0xc420014120, &amp;{1 Tom}
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="方法总是绑定对象实例，并隐式将实例作为第一实参"><a href="#方法总是绑定对象实例，并隐式将实例作为第一实参" class]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记面向对象]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记面向对象/</id>
    <published>2017-02-28T12:13:38.000Z</published>
    <updated>2017-03-01T12:06:28.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="面向对象三大特征，go仅支持封装。没有class关键字，没有继承，多态等"><a href="#面向对象三大特征，go仅支持封装。没有class关键字，没有继承，多态等" class="headerlink" title="面向对象三大特征，go仅支持封装。没有class关键字，没有继承，多态等"></a>面向对象三大特征，go仅支持封装。没有class关键字，没有继承，多态等</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id int
    name string
}


type Manager struct {
    User
    title string
}

func main() {
    m := Manager{User{1, &quot;Tom&quot;}, &quot;admin&quot;}
    var u User = m.User //同类型拷贝
    //var u User = m  //这个类型不一样，无法拷贝
    fmt.Println(u)
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="面向对象三大特征，go仅支持封装。没有class关键字，没有继承，多态等"><a href="#面向对象三大特征，go仅支持封装。]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记struct]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0struct/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记struct/</id>
    <published>2017-02-28T09:07:11.000Z</published>
    <updated>2017-03-01T12:05:16.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="值类型，赋值和传参会复制全部内容。可用”-”定义补位字段，支持指向自身类型的指针成员"><a href="#值类型，赋值和传参会复制全部内容。可用”-”定义补位字段，支持指向自身类型的指针成员" class="headerlink" title="值类型，赋值和传参会复制全部内容。可用”_”定义补位字段，支持指向自身类型的指针成员"></a>值类型，赋值和传参会复制全部内容。可用”_”定义补位字段，支持指向自身类型的指针成员</h6><pre><code>package main

import &quot;fmt&quot;

type Node struct {
    _       int
    id      int
    data    *byte
    next    *Node
}

func main() {
    n1 := Node{
        id  : 1,
        data: nil,
    }

    n2 := Node{
        id  : 2,
        data: nil,
        next: &amp;n1,
    }

    fmt.Println(n1, n2)
}
</code></pre><h6 id="顺序初始化必须包含全部字段，否则会出错"><a href="#顺序初始化必须包含全部字段，否则会出错" class="headerlink" title="顺序初始化必须包含全部字段，否则会出错"></a>顺序初始化必须包含全部字段，否则会出错</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    name    string
    age     int
}

func main() {
    u1 := User{&quot;Tom&quot;, 20}
    //u2 := User{&quot;Tom&quot;}     //会报错，缺少字段
    fmt.Println(u1)
}
</code></pre><h6 id="支持匿名结构，可用作结构成员或定义变量"><a href="#支持匿名结构，可用作结构成员或定义变量" class="headerlink" title="支持匿名结构，可用作结构成员或定义变量"></a>支持匿名结构，可用作结构成员或定义变量</h6><pre><code>package main

import &quot;fmt&quot;

type File struct {
    name    string
    size     int
    attr struct {
        perm    int
        owner   int
    }
}

func main() {
    f := File{
        name : &quot;test.txt&quot;,
        size : 1024,
        //attr : {0755,1} //这样赋值会报错
    }

    f.attr.owner = 1
    f.attr.perm = 0755

    fmt.Println(f)

    d := File{
        name : &quot;a.txt&quot;,
        size : 512,
    }

    var attr = struct {
        perm int
        owner int
    }{2, 0755}

    d.attr = attr

    fmt.Println(d)
}
</code></pre><h6 id="注意m的赋值方式"><a href="#注意m的赋值方式" class="headerlink" title="注意m的赋值方式"></a>注意m的赋值方式</h6><pre><code>package main

import &quot;fmt&quot;

type User struct {
    id     int
    name    string
}

func main() {
    m := map[User]int{
        User{1, &quot;Tom&quot;} : 100,
    }

    fmt.Println(m)      //100
}
</code></pre><h6 id="匿名字段，其实是一种语法糖，就是一个与成员类型同名的字段，被匿名嵌入的可以使任何类型，当然也包括指针。可以像普通字段那样访问匿名字段成员，编译器从外向内逐级查找所有层次的匿名字段，知道发现目标或出错"><a href="#匿名字段，其实是一种语法糖，就是一个与成员类型同名的字段，被匿名嵌入的可以使任何类型，当然也包括指针。可以像普通字段那样访问匿名字段成员，编译器从外向内逐级查找所有层次的匿名字段，知道发现目标或出错" class="headerlink" title="匿名字段，其实是一种语法糖，就是一个与成员类型同名的字段，被匿名嵌入的可以使任何类型，当然也包括指针。可以像普通字段那样访问匿名字段成员，编译器从外向内逐级查找所有层次的匿名字段，知道发现目标或出错"></a>匿名字段，其实是一种语法糖，就是一个与成员类型同名的字段，被匿名嵌入的可以使任何类型，当然也包括指针。可以像普通字段那样访问匿名字段成员，编译器从外向内逐级查找所有层次的匿名字段，知道发现目标或出错</h6><pre><code>package main

import &quot;fmt&quot;

type Resource struct {
    id int
}


type Manager struct {
    User
    title string
}

type User struct {
    Resource    //匿名字段，相当于引用上面的Resource结构
    name string
}

func main() {
    var m Manager
    m.id = 1
    m.name = &quot;Jack&quot;
    m.title = &quot;Admin&quot;

    fmt.Println(m)      //{{{1} Jack} Admin}
}
</code></pre><h6 id="外层同名字段会遮蔽嵌入字段成员，相同层次的同名字段也会让编译器无所适从，解决方法是使用显示字段名"><a href="#外层同名字段会遮蔽嵌入字段成员，相同层次的同名字段也会让编译器无所适从，解决方法是使用显示字段名" class="headerlink" title="外层同名字段会遮蔽嵌入字段成员，相同层次的同名字段也会让编译器无所适从，解决方法是使用显示字段名"></a>外层同名字段会遮蔽嵌入字段成员，相同层次的同名字段也会让编译器无所适从，解决方法是使用显示字段名</h6><pre><code>package main

import &quot;fmt&quot;

type Resource struct {
    id int
    name string
}


type Classify struct {
    id int
}

type User struct {
    Resource
    Classify
    name string
}

func main() {
    u := User{
        Resource{1, &quot;pepple&quot;},
        Classify{100},
        &quot;Jack&quot;,
    }

    fmt.Println(u)
    fmt.Println(u.name)
    fmt.Println(u.Resource.id)
    fmt.Println(u.Classify.id)
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="值类型，赋值和传参会复制全部内容。可用”-”定义补位字段，支持指向自身类型的指针成员"><a href="#值类型，赋值和传参会复]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记map]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0map/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记map/</id>
    <published>2017-02-28T08:20:07.000Z</published>
    <updated>2017-03-01T12:05:02.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="引用类型，哈希表，键必须是支持相等运算符类型。值可以是任意类型，没有限制"><a href="#引用类型，哈希表，键必须是支持相等运算符类型。值可以是任意类型，没有限制" class="headerlink" title="引用类型，哈希表，键必须是支持相等运算符类型。值可以是任意类型，没有限制"></a>引用类型，哈希表，键必须是支持相等运算符类型。值可以是任意类型，没有限制</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    m := map[int]struct{
        name string
        age int
    }{
        1 : {&quot;user1&quot;, 10},
        2 : {&quot;user2&quot;, 20},
    }

    fmt.Println(m[1].name)
}
</code></pre><h6 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    m := map[string]int{    //判断key是否存在
        &quot;a&quot; : 1,
    }

    if v,ok := m[&quot;a&quot;];ok {
        println(v, ok)      //1 true
    }

    fmt.Println(m[&quot;c&quot;])     //0   对于不存在的key，直接返回\0,不报错
    m[&quot;b&quot;] = 2              //新增或修改
    delete(m, &quot;c&quot;)          //删除，如果key不存在，不会出错
    println(len(m))         //2    获取键值对数量。cap无效

    for k, v := range m {   //迭代，可仅返回key。随机顺序返回，每次都不相同
        println(k, v)       //b 2       a 1
    }
}
</code></pre><h6 id="从map中取回的是一个value临时复制品，对其成员的修改是没有意义的"><a href="#从map中取回的是一个value临时复制品，对其成员的修改是没有意义的" class="headerlink" title="从map中取回的是一个value临时复制品，对其成员的修改是没有意义的"></a>从map中取回的是一个value临时复制品，对其成员的修改是没有意义的</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
   type user struct{ name string }
   m := map[int]user{
        1 : {&quot;user1&quot;},
   }

   fmt.Println(m[1].name)
   //m[1].name = &quot;Tom&quot;     //这样赋值会报错
   u := m[1]
   u.name = &quot;Tom&quot;
   m[1] = u
   fmt.Println(m[1].name)

   m2 := map[int]*user{
        1 : &amp;user{&quot;user1&quot;},
   }
   m2[1].name = &quot;jack&quot;
   fmt.Println(m2[1].name)      //返回的是指针复制品，透过指针修改原对象是允许的
}
</code></pre><h6 id="可以在迭代时安全删除键值-最好不要做新增操作"><a href="#可以在迭代时安全删除键值-最好不要做新增操作" class="headerlink" title="可以在迭代时安全删除键值,最好不要做新增操作"></a>可以在迭代时安全删除键值,最好不要做新增操作</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    for i := 0; i &lt; 5;i++ {
        m := map[int]string{
            0:&quot;a&quot;, 1:&quot;a&quot;, 2:&quot;a&quot;, 3:&quot;a&quot;, 4:&quot;a&quot;,
            5:&quot;a&quot;, 6:&quot;a&quot;, 7:&quot;a&quot;, 8:&quot;a&quot;, 9:&quot;a&quot;,
        }

        for k := range m {
            m[k+k] = &quot;k&quot;
            delete(m, k)
        }

        fmt.Println(m)
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="引用类型，哈希表，键必须是支持相等运算符类型。值可以是任意类型，没有限制"><a href="#引用类型，哈希表，键必须是支持相等]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记copy]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0copy/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记copy/</id>
    <published>2017-02-28T08:09:06.000Z</published>
    <updated>2017-03-01T12:04:53.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="函数copy在两个slice间复制数据，复制长度以len小的为准，两个slice可指向同一层数组，允许元素区间重叠"><a href="#函数copy在两个slice间复制数据，复制长度以len小的为准，两个slice可指向同一层数组，允许元素区间重叠" class="headerlink" title="函数copy在两个slice间复制数据，复制长度以len小的为准，两个slice可指向同一层数组，允许元素区间重叠"></a>函数copy在两个slice间复制数据，复制长度以len小的为准，两个slice可指向同一层数组，允许元素区间重叠</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    s := data[8:]
    s2 := data[:5]
    fmt.Println(s2)         //[0 1 2 3 4]
    copy(s2, s)

    fmt.Println(s)          //[8 9]
    fmt.Println(s2)         //[8 9 2 3 4]
    fmt.Println(data)       //[8 9 2 3 4 5 6 7 8 9]
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="函数copy在两个slice间复制数据，复制长度以len小的为准，两个slice可指向同一层数组，允许元素区间重叠"><a hre]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记append]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0append/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记append/</id>
    <published>2017-02-28T07:38:23.000Z</published>
    <updated>2017-03-01T12:04:44.000Z</updated>
    <content type="html"><![CDATA[<h1 id="append"><a href="#append" class="headerlink" title="append"></a>append</h1><h6 id="向slice尾部添加数据，返回新的slice对象"><a href="#向slice尾部添加数据，返回新的slice对象" class="headerlink" title="向slice尾部添加数据，返回新的slice对象"></a>向slice尾部添加数据，返回新的slice对象</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    s := make([]int, 0, 5)
    fmt.Printf(&quot;%p\n&quot;, &amp;s)      //0xc42000e1a0

    s2 := append(s, 1)
    fmt.Printf(&quot;%p\n&quot;, &amp;s2)     //0xc42000e1c0

    fmt.Println(s, s2)          //[] [1]
}
</code></pre><h6 id="append多个值"><a href="#append多个值" class="headerlink" title="append多个值"></a>append多个值</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    s := data[:3]
    s2 := append(s, 100, 200)

    fmt.Println(data)           //[0 1 2 100 200 5 6 7 8 9]
    fmt.Println(s)              //[0 1 2]
    fmt.Println(s2)             //[0 1 2 100 200]
}
</code></pre><h6 id="一旦超出原slice-cap限制，就会重新分配底层数组，即便原数组并未填满"><a href="#一旦超出原slice-cap限制，就会重新分配底层数组，即便原数组并未填满" class="headerlink" title="一旦超出原slice.cap限制，就会重新分配底层数组，即便原数组并未填满"></a>一旦超出原slice.cap限制，就会重新分配底层数组，即便原数组并未填满</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    data := [...]int{0, 1, 2, 3, 4, 10:0}
    s := data[:2:3]
    s = append(s, 100, 200) //一次append两个值，超出s.cap限制，append后的s重新分配了底层数组，并复制数据，如果只追加一个值，则不会重新分配底层数组

    fmt.Println(s, data)    //重新分配底层数组，与原数组无关
    fmt.Println(&amp;s[0], &amp;data[0])    //比对底层数组起始指针
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="append"><a href="#append" class="headerlink" title="append"></a>append</h1><h6 id="向slice尾部添加数据，返回新的slice对象"><a href="#向slice尾部添加数据，]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记reslice]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0reslice/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记reslice/</id>
    <published>2017-02-28T06:44:03.000Z</published>
    <updated>2017-03-01T12:05:05.000Z</updated>
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="基于已有slice创建新slice对象，以便在cap允许范围内调整属性"><a href="#基于已有slice创建新slice对象，以便在cap允许范围内调整属性" class="headerlink" title="基于已有slice创建新slice对象，以便在cap允许范围内调整属性"></a>基于已有slice创建新slice对象，以便在cap允许范围内调整属性</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    s := []int{0, 11, 10, 31, 4, 5, 6, 7, 8, 9}
    s1 := s[2:5]            //[10 31 4]
    s2 := s1[2:6:7]         //[4 5 6 7]     注意要在新的s1上进行截取
    //s3 := s2[3:6]           //报错
    fmt.Println(s1, s2)
}
</code></pre><h6 id="新对象依旧指向原底层数组"><a href="#新对象依旧指向原底层数组" class="headerlink" title="新对象依旧指向原底层数组"></a>新对象依旧指向原底层数组</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    s := []int{0, 11, 10, 31, 4, 5, 6, 7, 8, 9}
    s1 := s[2:5]    //[10 31 4]
    fmt.Println(s1)
    s1[2] = 100
    s2 := s1[2:6]
    fmt.Println(s2) //[100 5 6 7]
    s2[3] = 200

    fmt.Println(s)  //[0 11 10 31 100 5 6 200 8 9]
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><h6 id="基于已有slice创建新slice对象，以便在cap允许范围内调整属性"><a href="#基于已有slice创建新slice对]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记slice]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0slice/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记slice/</id>
    <published>2017-02-28T03:52:55.000Z</published>
    <updated>2017-03-01T12:05:10.000Z</updated>
    <content type="html"><![CDATA[<h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><h6 id="slice不是数组或数组指针，它是通过内部指针和相关属性引用数组片段，以实现边长方案"><a href="#slice不是数组或数组指针，它是通过内部指针和相关属性引用数组片段，以实现边长方案" class="headerlink" title="slice不是数组或数组指针，它是通过内部指针和相关属性引用数组片段，以实现边长方案"></a>slice不是数组或数组指针，它是通过内部指针和相关属性引用数组片段，以实现边长方案</h6><h6 id="slice引用类型，但自身是结构体，值拷贝传递"><a href="#slice引用类型，但自身是结构体，值拷贝传递" class="headerlink" title="slice引用类型，但自身是结构体，值拷贝传递"></a>slice引用类型，但自身是结构体，值拷贝传递</h6><pre><code>//在runtime.h中的源码
struct slice
{
    byte* array;
    uintgo len;     //表示可用元素数量，读写操作不能超过该限制
    uintgo cap;     //表示最大扩张容量，不能超出数组限制
}
</code></pre><h6 id="slice使用方式-a-b-c-，a表示从a位置开始，b表示到b位置结束，c表示最大位置是c，len-b-a-cap-c-a"><a href="#slice使用方式-a-b-c-，a表示从a位置开始，b表示到b位置结束，c表示最大位置是c，len-b-a-cap-c-a" class="headerlink" title="slice使用方式[a:b:c]，a表示从a位置开始，b表示到b位置结束，c表示最大位置是c，len=b-a,cap=c-a"></a>slice使用方式[a:b:c]，a表示从a位置开始，b表示到b位置结束，c表示最大位置是c，len=b-a,cap=c-a</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    data := [...]int{0, 1, 2, 3, 4, 5, 6}
    slice := data[1:4:5]
    fmt.Println(slice)      //[1 2 3]
}
</code></pre><h6 id="slice使用举例"><a href="#slice使用举例" class="headerlink" title="slice使用举例"></a>slice使用举例</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    slice := data[:6:8]
    slice1 := data[5:]
    slice2 := data[:3]
    slice3 := data[:]
    fmt.Println(slice, slice1, slice2, slice3)  //[0 1 2 3 4 5] [5 6 7 8 9] [0 1 2] [0 1 2 3 4 5 6 7 8 9]
}
</code></pre><h6 id="slice读写操作实际目标是底层数组，只需要注意索引号的差别"><a href="#slice读写操作实际目标是底层数组，只需要注意索引号的差别" class="headerlink" title="slice读写操作实际目标是底层数组，只需要注意索引号的差别"></a>slice读写操作实际目标是底层数组，只需要注意索引号的差别</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    slice := data[6:8]
    slice[0] += 100
    slice[1] += 200
    fmt.Println(slice)  //[106 207]
    fmt.Println(data)   //[0 1 2 3 4 5 106 207 8 9]
}
</code></pre><h6 id="直接创建slice对象，自动分配底层数组"><a href="#直接创建slice对象，自动分配底层数组" class="headerlink" title="直接创建slice对象，自动分配底层数组"></a>直接创建slice对象，自动分配底层数组</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    data := [...]int{0, 1, 2, 3, 8:100}
    fmt.Println(data, len(data), cap(data)) //[0 1 2 3 0 0 0 0 100] 9 9

    s2 := make([]int, 6, 8)
    fmt.Println(s2, len(s2), cap(s2))   //[0 0 0 0 0 0] 6 8 没有初始化值，直接用0填充

    s3 := make([]int, 6)
    fmt.Println(s3, len(s3), cap(s3))   //[0 0 0 0 0 0] 6 6 省略cap那么久默认cap=len
}
</code></pre><h6 id="可以用指针直接访问底层数组，退化成普通数组操作"><a href="#可以用指针直接访问底层数组，退化成普通数组操作" class="headerlink" title="可以用指针直接访问底层数组，退化成普通数组操作"></a>可以用指针直接访问底层数组，退化成普通数组操作</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    s := []int{0, 1, 2, 3, 4}
    p := &amp;s[2]      //直接使用指针修改数组底层的值
    *p += 100
    fmt.Println(s)
}
</code></pre><h6 id="依然是二维数组"><a href="#依然是二维数组" class="headerlink" title="依然是二维数组"></a>依然是二维数组</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    data := [][]int{
        []int{1, 2, 3},
        []int{100, 200},
        []int{11, 22, 33, 44},
    }

    fmt.Println(data)       //[[1 2 3] [100 200] [11 22 33 44]]
}
</code></pre><h6 id="可直接修改struct-array成员"><a href="#可直接修改struct-array成员" class="headerlink" title="可直接修改struct array成员"></a>可直接修改struct array成员</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    d := [5]struct {
        x int
    }{}

    s := d[:]   //这里是引用

    d[1].x = 10
    s[2].x = 20
    fmt.Println(d)      //[{0} {10} {20} {0} {0}]
    fmt.Printf(&quot;%p, %p\n&quot;, &amp;d, &amp;d[0])       //0xc4200720c0, 0xc4200720c0
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><h6 id="slice不是数组或数组指针，它是通过内部指针和相关属性引用数组片段，以实现边长方案"><a href="]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[go学习笔记array]]></title>
    <link href="http://www.cxyteam.com/2017/02/28/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0array/"/>
    <id>http://www.cxyteam.com/2017/02/28/go学习笔记array/</id>
    <published>2017-02-28T03:21:50.000Z</published>
    <updated>2017-03-01T12:04:48.000Z</updated>
    <content type="html"><![CDATA[<h1 id="Array类型数据"><a href="#Array类型数据" class="headerlink" title="Array类型数据"></a>Array类型数据</h1><h6 id="数组是值类型，赋值和传参会复制整个数组，而不是指针"><a href="#数组是值类型，赋值和传参会复制整个数组，而不是指针" class="headerlink" title="数组是值类型，赋值和传参会复制整个数组，而不是指针"></a>数组是值类型，赋值和传参会复制整个数组，而不是指针</h6><h6 id="数组长度必须是常量，且是类型的组成部分。-2-int和-3-int是不同类型"><a href="#数组长度必须是常量，且是类型的组成部分。-2-int和-3-int是不同类型" class="headerlink" title="数组长度必须是常量，且是类型的组成部分。[2]int和[3]int是不同类型"></a>数组长度必须是常量，且是类型的组成部分。[2]int和[3]int是不同类型</h6><h6 id="支持”-”，”！-”操作符，因为内存总是被初始化过"><a href="#支持”-”，”！-”操作符，因为内存总是被初始化过" class="headerlink" title="支持”==”，”！=”操作符，因为内存总是被初始化过"></a>支持”==”，”！=”操作符，因为内存总是被初始化过</h6><h6 id="指针数组-n-T-数组指针-n-T"><a href="#指针数组-n-T-数组指针-n-T" class="headerlink" title="指针数组[n]T,数组指针[n]T"></a>指针数组[n]<em>T,数组指针</em>[n]T</h6><h1 id="定义数组的方式"><a href="#定义数组的方式" class="headerlink" title="定义数组的方式"></a>定义数组的方式</h1><h6 id="直接初始化"><a href="#直接初始化" class="headerlink" title="直接初始化"></a>直接初始化</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    a := [3]int{1,2}    //定义了数组有三个元素，未初始化元素值为0
    fmt.Println(a)      //[1 2 0]
}


package main

import &quot;fmt&quot;

func main() {
    a := [...]int{1, 2, 3, 4, 5}    //通过初始化值确定数组长度
    fmt.Println(a)      //[1 2 3 4 5]
}

package main

import &quot;fmt&quot;

func main() {
    a := [5]int{2:100, 4:200}   //指定了数组对应的键，索引从0开始以0的值进行补齐到指定的数组长度
    fmt.Println(a)      //[0 0 100 0 200]
}
</code></pre><h6 id="先struct方式定义数组格式，再初始化值"><a href="#先struct方式定义数组格式，再初始化值" class="headerlink" title="先struct方式定义数组格式，再初始化值"></a>先struct方式定义数组格式，再初始化值</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    a := [...]struct{
        name string
        age uint8
    }{
        {&quot;user1&quot;, 10},
        {&quot;user2&quot;, 20},  //都好不能省略
    }

    fmt.Println(a)      //[{user1 10} {user2 20}]
}
</code></pre><h6 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    a := [2][3]int{{1,2,3}, {4,5,6}}    //指定每一层的元素个数

    fmt.Println(a)      //[[1 2 3] [4 5 6]]
}


package main

import &quot;fmt&quot;

func main() {
    a := [...][3]int{{1,2,3}, {4,5,6}}  //省略第一维的元素个数，第二维不能省略

    fmt.Println(a)      //[[1 2 3] [4 5 6]]
}
</code></pre><h6 id="数组会有值拷贝行为，建议使用后slice，或数组指针"><a href="#数组会有值拷贝行为，建议使用后slice，或数组指针" class="headerlink" title="数组会有值拷贝行为，建议使用后slice，或数组指针"></a>数组会有值拷贝行为，建议使用后slice，或数组指针</h6><pre><code>package main

import &quot;fmt&quot;

func test(x [2]int) {
    fmt.Printf(&quot;x:%p&quot;, &amp;x)  //x:0xc42000a2d0    指针位置发生了改变，说明是重新复制了值
    x[1] = 1000
}

func main() {
    a := [2]int{1,2}
    fmt.Printf(&quot;a:%p&quot;, &amp;a)  //a:0xc42000a2a0
    test(a)
    fmt.Println(a)  //[1 2] 由于是值复制，因此当前的数组还是原来的值
}
</code></pre><h6 id="数组长度"><a href="#数组长度" class="headerlink" title="数组长度"></a>数组长度</h6><pre><code>package main

import &quot;fmt&quot;

func main() {
    a := [2]int{1,2}
    fmt.Println(len(a), cap(a))  //2,2
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Array类型数据"><a href="#Array类型数据" class="headerlink" title="Array类型数据"></a>Array类型数据</h1><h6 id="数组是值类型，赋值和传参会复制整个数组，而不是指针"><a href="#]]>
    </summary>
    
      <category term="GO" scheme="http://www.cxyteam.com/tags/GO/"/>
    
      <category term="GO" scheme="http://www.cxyteam.com/categories/GO/"/>
    
  </entry>
  
</feed>