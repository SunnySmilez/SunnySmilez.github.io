<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="狂奔的菜鸟" type="application/atom+xml" />






<meta name="description" content="狂奔的菜鸟">
<meta property="og:type" content="website">
<meta property="og:title" content="狂奔的菜鸟">
<meta property="og:url" content="http://www.cxyteam.com/page/15/index.html">
<meta property="og:site_name" content="狂奔的菜鸟">
<meta property="og:description" content="狂奔的菜鸟">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="狂奔的菜鸟">
<meta name="twitter:description" content="狂奔的菜鸟">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.cxyteam.com/page/15/"/>





  <title>狂奔的菜鸟</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">狂奔的菜鸟</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">当你的实力支撑不起你的野心的时候，静下心来好好学习吧！</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.cxyteam.com/2016/08/10/C语言动态存储/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="狂奔的菜鸟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="狂奔的菜鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/10/C语言动态存储/" itemprop="url">C语言动态存储</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-10T08:12:39+08:00">
                2016-08-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="动态数据存储的位置"><a href="#动态数据存储的位置" class="headerlink" title="动态数据存储的位置"></a>动态数据存储的位置</h1><pre><code>堆,它是程序中用来保存长期使用数据的地方
</code></pre><h1 id="获取空间"><a href="#获取空间" class="headerlink" title="获取空间"></a>获取空间</h1><pre><code>使用malloc()函数进行申请
</code></pre><h1 id="如何释放"><a href="#如何释放" class="headerlink" title="如何释放"></a>如何释放</h1><pre><code>使用free()函数进行释放
</code></pre><h1 id="使用malloc"><a href="#使用malloc" class="headerlink" title="使用malloc"></a>使用malloc</h1><pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

//结构定义函数体的外面多个函数才能共享
typedef struct island {
    char *name;
    char *open;
    char *close;
    struct island *next;
} island;
void display(island *start);
void release(island *start);
island* create();

int main()
{
    char name[80];
    fgets(name, 80, stdin);
    island *i = create(name);

    fgets(name, 80, stdin);
    island *i1 = create(name);
    i-&gt;next = i1;
    display(i);
    release(i);
}

island* create (char *name)
{
    island *i = malloc(sizeof(island));
    //注意在此处一定用用strdup在堆上存储,如果都是在栈上存储,函数结束后会释放内存空间,每次都只能保存最后传入的name指针指向的值
    i-&gt;name = strdup(name);
    i-&gt;open = &quot;09:00&quot;;
    i-&gt;close = &quot;17:00&quot;;
    i-&gt;next = NULL;

    return i;
}


void display(island *start) {
    island *i = start;
    for (;i!=NULL;i=i-&gt;next) {
        printf(&quot;name:%s,open:%s-%s\n&quot;,i-&gt;name, i-&gt;open, i-&gt;close);
    }
}

void release(island *start) {
    island *i = NULL;
    island *next = NULL;

    for(;i!=NULL;i=next) {
        next = i-&gt;next;
        free(i-&gt;name);
        free(i);
    }
}
</code></pre><h1 id="为什么island在堆上申请了内存-name还需要在堆上申请内存"><a href="#为什么island在堆上申请了内存-name还需要在堆上申请内存" class="headerlink" title="为什么island在堆上申请了内存,name还需要在堆上申请内存?"></a>为什么island在堆上申请了内存,name还需要在堆上申请内存?</h1><pre><code>因为结构只是把不同类型的数据写在一起,封装成一个大的数据类型,它不是创建了一个类型把所有数据都存储在它里面
</code></pre><h1 id="使用release的时候需要释放那些堆上的内存"><a href="#使用release的时候需要释放那些堆上的内存" class="headerlink" title="使用release的时候需要释放那些堆上的内存?"></a>使用release的时候需要释放那些堆上的内存?</h1><pre><code>因为name,和island在堆上申请了内存,所以只要释放他们的内存就好了,但是需要注意的是先释放name的内存,不然先释放了island就找不到name了
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.cxyteam.com/2016/08/09/C语言链表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="狂奔的菜鸟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="狂奔的菜鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/09/C语言链表/" itemprop="url">C语言链表</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-09T07:57:33+08:00">
                2016-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><pre><code>是一种抽象的数据结构
</code></pre><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><pre><code>为了保存可变数量的数据,需要一样比数组更灵活的东西
</code></pre><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><pre><code>保存了一条数据和链向另一条数据的链接
</code></pre><h1 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h1><pre><code>#include &lt;stdio.h&gt;
//注意要先定义函数在main函数的外部
void display();
//结构定义函数体的外面多个函数才能共享
typedef struct island {
    char *name;
    char *open;
    char *close;
    struct island *next;
} island;

int main()
{
    island amity = {&quot;Amity&quot;, &quot;9:00&quot;, &quot;17:00&quot;, NULL};
    island craggy = {&quot;craggy&quot;, &quot;9:00&quot;, &quot;17:00&quot;, NULL};
    island shutter = {&quot;shutter&quot;, &quot;9:00&quot;, &quot;17:00&quot;, NULL};

    amity.next = &amp;craggy;
    craggy.next = &amp;shutter;

    display(&amp;amity);
    return 0;
}

void display(island *start) {
    island *i = start;
    for (;i!=NULL;i=i-&gt;next) {
        printf(&quot;name:%s,open:%s-%s\n&quot;,i-&gt;name, i-&gt;open, i-&gt;close);
    }
}
</code></pre><h1 id="递归结构"><a href="#递归结构" class="headerlink" title="递归结构"></a>递归结构</h1><pre><code>如果一个结构中包含一个链向同种结构的链接,那么这个结构就被称为递归结构
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.cxyteam.com/2016/07/27/C语言联合/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="狂奔的菜鸟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="狂奔的菜鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/27/C语言联合/" itemprop="url">C语言联合</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-27T07:42:29+08:00">
                2016-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="联合"><a href="#联合" class="headerlink" title="联合"></a>联合</h1><pre><code>用union关键字定义的一个叫&quot;量&quot;的数据类型
typedef union {
    short count;
    float volume;
    float weight;
} quantity;
</code></pre><h1 id="联合的特点"><a href="#联合的特点" class="headerlink" title="联合的特点"></a>联合的特点</h1><pre><code>1.可以有效的使用存储器空间
    当定义联合的时候,计算机只为其中一个最大的字段分配空间,然后由你决定里面保存什么值(上面例子的name,age,weight都会存储在一个位置)
</code></pre><h1 id="如何使用联合"><a href="#如何使用联合" class="headerlink" title="如何使用联合"></a>如何使用联合</h1><pre><code>1.c89方式:只能设置联合的第一个字段也就是上述中的name字段
    例子:quantity a = {1};

2.指定初始化器:按名设置联合字段的值
    quantity b = {.volume = 4.6};

3.点表示法:先创建变量,在设置字段的值
    quantity c;
    c.weight = 3.7;

注意:无论哪种方法设置联合的值,都只会保存一条数据。联合只是提供了一种让你创建支持不同数据类型的变量的方法
实例:
    #include &lt;stdio.h&gt;

    int main()
    {
        typedef union {
            short count;
            float volume;
            float weight;
        } quantity;

        quantity a = {1};

        quantity b = {.volume = 4.6};

        quantity c;
        c.weight = 3.7;
        printf(&quot;%i,%f,%f&quot;, a.count, b.volume, c.weight);
        return 0;
    }
</code></pre><h1 id="结构和联合一起使用"><a href="#结构和联合一起使用" class="headerlink" title="结构和联合一起使用"></a>结构和联合一起使用</h1><pre><code>#include &lt;stdio.h&gt;

typedef union {
    short count;
    float volume;
    float weight;
} quantity;

typedef struct {
    const char *name;
    const char *country;
    quantity amount;
} fruit_order;

int main()
{
    /*
        此处的.amount表示fruit_order中的amount字段,.count表示quantity中的字段
    */
    fruit_order apples = {&quot;apple&quot;, &quot;china&quot;, .amount.count = 20};
    printf(&quot;%s,%s,%i&quot;, apples.name, apples.country, apples.amount.count);

    return 0;
}
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.cxyteam.com/2016/07/26/C语言结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="狂奔的菜鸟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="狂奔的菜鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/26/C语言结构/" itemprop="url">C语言结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-26T08:14:25+08:00">
                2016-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><pre><code>把不同的数据类型写在一起,封装成一个大数据类型;结构的大小固定;结构中的数据都有名字
例如:
    定义新结构
    /*
        注意fish只是结构的名字
    */
    struct fish {
        /*
            const char * 是用来保存不想修改的字符串,也就是字符串的字面值
        */
        const char *name;
        const char *species;
        int teeth;
        int age;
    };

    创建数据
    struct fish snappy = {&quot;snappy&quot;, &quot;piranha&quot;, 69, 4}

    复制结构内容
    struct fish snappy1 = snappy;
</code></pre><h1 id="读取结构内容"><a href="#读取结构内容" class="headerlink" title="读取结构内容"></a>读取结构内容</h1><pre><code>尽管结构可以向数组那样在结构中保存字段,但读取时只能按名访问;可以使用&quot;.&quot;运算符访问结构字段
fish.c的文件:
#include &lt;stdio.h&gt;

int main()
{
    struct fish {
        /*
            const char * 是用来保存不想修改的字符串,也就是字符串的字面值
        */
        const char *name;
        const char *species;
        int teeth;
        int age;
    };

    struct fish snappy = {
        /*
            注意依然不能使用单引号
        */
        &quot;snappy&quot;,
        &quot;piranha&quot;,
        69,
        4
    };

    /*
        获取的时候是定义的结构数据的名字,而不是结构本身的名字(是snappy而不是fish)
    */
    printf(&quot;%s,%s,%i,%i&quot;, snappy.name, snappy.species, snappy.teeth, snappy.age);

    return 0;
}

使用make编译:make fish &amp;&amp; ./fish
</code></pre><h1 id="存储器中的结构"><a href="#存储器中的结构" class="headerlink" title="存储器中的结构"></a>存储器中的结构</h1><pre><code>在定义结构时,并没有让计算机在存储器中创建任何东西,只是给了计算机一个模板,告诉它你希望新的数据类型长什么样子
当定义新变量时,计算机则需要在存储器中为结构的实例创建空间,这块空间必须足够大,以装下结构中的所有字段
把一个结构变量赋给另一个结构变量时,计算机会创建一个全新的结构副本,也就是说,计算机需要再分配一块存储器空间,大小和原来相同,然后把每个字段都复制过去
</code></pre><h1 id="结构的嵌套"><a href="#结构的嵌套" class="headerlink" title="结构的嵌套"></a>结构的嵌套</h1><pre><code>#include &lt;stdio.h&gt;

int main()
{
    /*
        注意结束的分号不要忘记打,这个不是数组
    */
    struct preferences {
        /*
            此处结尾是分号,不是逗号
        */
        const char *food;
        float exercise_hours;
    };

    struct fish {
        const char *name;
        const char *species;
        int teeth;
        int age;
        /*
            结构的嵌套:在结构中定义结构
            此处定义的不是一个结构体,而是一个结构创建后的数据(是struct preferences care而不是struct preferences)
        */
        struct preferences care;
    };

    struct fish snappy = {
        &quot;snappy&quot;,
        &quot;piranha&quot;,
        69,
        4,
        {
            &quot;fish&quot;,
            4.00
        }
    };

    /*
        获取嵌套的结构中的数据注意care是嵌套的结构的名字
    */
    printf(&quot;%s,%f&quot;, snappy.care.food, snappy.care.exercise_hours);
}
</code></pre><h1 id="创建别名"><a href="#创建别名" class="headerlink" title="创建别名"></a>创建别名</h1><pre><code>使用typedef将struct name重命名rename,在后续创建结构数据的时候,可以直接使用rename
其实struct name是结构名,rename是类型名
typedef struct name {} rename;

例子:
#include &lt;stdio.h&gt;

int main()
{
    typedef struct big_fish {
        /*
            const char * 是用来保存不想修改的字符串,也就是字符串的字面值
        */
        const char *name;
        const char *species;
        int teeth;
        int age;
    } fish;

    fish snappy = {
        /*
            注意依然不能使用单引号
        */
        &quot;snappy&quot;,
        &quot;piranha&quot;,
        69,
        4
    };

    printf(&quot;%s,%s,%i,%i&quot;, snappy.name, snappy.species, snappy.teeth, snappy.age);
    return 0;
}
</code></pre><h1 id="匿名结构"><a href="#匿名结构" class="headerlink" title="匿名结构"></a>匿名结构</h1><pre><code>typeof struct {} rename
不存在name(结构名)只存在rename(类型名)
</code></pre><h1 id="更新结构"><a href="#更新结构" class="headerlink" title="更新结构"></a>更新结构</h1><pre><code>#include &lt;stdio.h&gt;

typedef struct {
    const char *name;
    const char *species;
    int age;
} turtle;

void happy_birthday(turtle t)
{
    /*
        关键在此处更新结构
    */
    t.age = t.age + 1;
    printf(&quot;happy birthday %s,you are %i years old!\n&quot;, t.name, t.age);
}

int main()
{
    turtle myrtle = {&quot;Myrtle&quot;, &quot;Leatherback sea turtle&quot;, 99};
    happy_birthday(myrtle);
    printf(&quot;%s&apos;s age is now %i\n&quot;, myrtle.name, myrtle.age);

    return 0;
}

为什么最终输出来的值是:
    happy birthday Myrtle,you are 100 years old!
    Myrtle&apos;s age is now 99

为什么传给函数happy_birthday的时候age递增1变成100,调用完之后再次查看age的值结果是99?
因为你传入的是结构的值,不是结构的指针,所以他会对结构的值进行复制
</code></pre><h1 id="指针更新结构"><a href="#指针更新结构" class="headerlink" title="指针更新结构"></a>指针更新结构</h1><pre><code>#include &lt;stdio.h&gt;

typedef struct {
    const char *name;
    const char *species;
    int age;
} turtle;

void happy_birthday(turtle *t)
{
    /*
        (*t)表示myrtle指针指向的值,一定要打括号,表示一个整体
        (*t).age表示的是t指向的结构的指针,最后得到的是年龄
        *t.age表示的是t.age这个存储器单元中的内容
    */
    (*t).age = (*t).age + 1;
    printf(&quot;happy birthday %s,you are %i years old!\n&quot;, (*t).name, (*t).age);
}

int main()
{
    turtle myrtle = {&quot;Myrtle&quot;, &quot;Leatherback sea turtle&quot;, 99};
    /*
        注意此处传入的是结构的指针,使用&apos;&amp;&apos;获取指针
    */
    happy_birthday((&amp;myrtle));
    printf(&quot;%s&apos;s age is now %i\n&quot;, myrtle.name, myrtle.age);

    return 0;
}
</code></pre><h1 id="易读的表达方式"><a href="#易读的表达方式" class="headerlink" title="易读的表达方式"></a>易读的表达方式</h1><pre><code>#include &lt;stdio.h&gt;

typedef struct {
    const char *name;
    const char *species;
    int age;
} turtle;

void happy_birthday(turtle *t)
{
    /*
        (*t).age == t-&gt;age
    */
    t-&gt;age = t-&gt;age + 1;
    printf(&quot;happy birthday %s,you are %i years old!\n&quot;, (*t).name, (*t).age);
}

int main()
{
    turtle myrtle = {&quot;Myrtle&quot;, &quot;Leatherback sea turtle&quot;, 99};
    happy_birthday((&amp;myrtle));
    printf(&quot;%s&apos;s age is now %i\n&quot;, myrtle.name, myrtle.age);

    return 0;
}6
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.cxyteam.com/2016/07/24/C语言使用多个源文件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="狂奔的菜鸟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="狂奔的菜鸟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/07/24/C语言使用多个源文件/" itemprop="url">C语言声明与定义分离</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-07-24T17:56:26+08:00">
                2016-07-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="为什么要使用声明与定义分离-它解决了什么问题"><a href="#为什么要使用声明与定义分离-它解决了什么问题" class="headerlink" title="为什么要使用声明与定义分离,它解决了什么问题"></a>为什么要使用声明与定义分离,它解决了什么问题</h1><pre><code>1.代码顺序的问题
    #include &lt;stdio.h&gt;
        /*
            由于函数定义顺序产生的一个编译的错误
        */
        int main()
        {
            demo();

            return 0;
        }

        float demo()
        {
            return 1.00;
        }

2.解决了代码的互相依赖的问题,在a方法中调用了b方法,在b方法中又调用了b方法
    #include &lt;stdio.h&gt;
    int demo()
    {
        test();
    }

    int test()
    {
        demo();
    }

    int main()
    {
        demo();
        return 0;
    }
</code></pre><h1 id="如下代码为什么会报错"><a href="#如下代码为什么会报错" class="headerlink" title="如下代码为什么会报错"></a>如下代码为什么会报错</h1><pre><code>#include &lt;stdio.h&gt;
/*
    由于函数定义顺序产生的一个编译的错误
*/
int main()
{
    demo();

    return 0;
}

float demo()
{
    return 1.00;
}

1.编译器看到不认识的函数调用(函数未定义),认为它会在之后的源文件中找到这个函数的详细信息。它会先记录下来,随后在文件中查找
2.编译器需要知道函数的返回类型,由于函数未定义,所以不知道它的返回类型,所以只好假设它返回int
3.等编译器看到实际的函数,返回&quot;conflicting types for &apos;demo&apos;&quot;的错误,因为编译器认为有两个同名的函数,一个是文件中的函数,一个是编译器假设返回int的那个
</code></pre><h1 id="什么是声明与定义分离"><a href="#什么是声明与定义分离" class="headerlink" title="什么是声明与定义分离"></a>什么是声明与定义分离</h1><pre><code>如果在第二步函数就知道返回类型了,就不需要再找了,所以为了防止编译器假设函数的返回类型,可以显示的告诉他,告诉编译器函数会返回什么类型的语句就叫函数声明;一旦声明了,编译器就不需要假设了,完全可以先调用函数,再定义函数
声明只是一个函数签名:一条包含函数名,形参类型与返回类型的记录
</code></pre><h1 id="如何让声明与定义分离"><a href="#如何让声明与定义分离" class="headerlink" title="如何让声明与定义分离"></a>如何让声明与定义分离</h1><pre><code>例如:
    #include &lt;stdio.h&gt;

    /*
        此处声明了函数
    */
    int demo();

    int main()
    {
        demo();
        puts(&quot;this is main function&quot;);

        return 0;
    }

    /*
        此处定义了函数
    */
    int demo()
    {
        puts(&quot;this is demo function&quot;);
        return 0;
    }
</code></pre><h1 id="创建完全和函数体分离的头文件"><a href="#创建完全和函数体分离的头文件" class="headerlink" title="创建完全和函数体分离的头文件"></a>创建完全和函数体分离的头文件</h1><pre><code>demo.h文件内容:
    int demo();

函数体中的内容:
    #include &lt;stdio.h&gt;
    /*
        注意这里是双引号,且没有分号,文件在当前目录下,是相对路径,里面之定义了头信息(就是函数的返回值以及类型)
    */
    #include &quot;demo.h&quot;

    int main()
    {
        /*
            调用未定义的函数,不报错(因为上面加载了函数头信息)
        */
        demo();
        puts(&quot;this is main function&quot;);

        return 0;
    }

    int demo()
    {
        puts(&quot;this is demo function&quot;);
        return 0;
    }
</code></pre><h1 id="什么是预处理"><a href="#什么是预处理" class="headerlink" title="什么是预处理"></a>什么是预处理</h1><pre><code>预处理是把c源码转化成可执行文件的第一个阶段,预处理会在编译开始之前修改代码,创建一个新的源文件(为了提高效率,编译器通常会用管道在两个阶段之间发送数据)
</code></pre><h1 id="include-lt-gt-和include-“”有什么区别"><a href="#include-lt-gt-和include-“”有什么区别" class="headerlink" title="include &lt;&gt; 和include “”有什么区别"></a>include &lt;&gt; 和include “”有什么区别</h1><pre><code>引号表示使用以相对路径查找头文件,如果不加目录名,只包含一个文件名,编译器就会在当前目录下查找头文件;如果遇到尖括号,会到标准库代码所在目录查找头文件
</code></pre><h1 id="gcc一般会去哪些位置寻找头文件"><a href="#gcc一般会去哪些位置寻找头文件" class="headerlink" title="gcc一般会去哪些位置寻找头文件"></a>gcc一般会去哪些位置寻找头文件</h1><pre><code>gcc知道标准库的头文件被保存的位置,头文件一般保存在/usr/local/include,/usr/include这些地方
</code></pre><h1 id="编译器是如何工作的"><a href="#编译器是如何工作的" class="headerlink" title="编译器是如何工作的"></a>编译器是如何工作的</h1><pre><code>1.预处理:修改代码
    用include指令添加相关头文件;跳过程序中的某些代码;补充一些代码

2.编译:转换成汇编代码
    计算机只理解底层的机器代码指令,在这一步,会把语句或函数调用转化成一串汇编语言指令

3.汇编:生成目标代码
    编译器将符号代码汇编成机器代码或目标代码,也就是CPU内部电路执行的二进制代码

4.链接:放在一起
    一旦有了目标代码,就需要将它们拼在一起,构成可执行程序,当某个代码调用另外一个目标代码的函数时,编译器会把它们连接在一起。同时,链接还会确保程序能够调用库代码。最后程序会写到一个可执行程序文件中,文件格式视操作系统而定,操作系统根据文件格式把程序加载到存储器中运行
</code></pre><h1 id="如何进行代码共享"><a href="#如何进行代码共享" class="headerlink" title="如何进行代码共享"></a>如何进行代码共享</h1><pre><code>例如在将数据写入到数据库中需要进行加密,在将数据写入到缓存中中也要进行加密,他们的加密方法是一致的,不需要在两个文件中都写一份加密的代码
1.创建自己的头文件
    encrypt.h文件
        void encrypt(char *message);

2.引用头文件
    encrypt.c文件
    #include &quot;encrypt.h&quot;

    void encrypt(char *message)
    {
        char c;
        while(*message) {
            *message = *message ^ 31;
            message++;
        }
    }

    db.c文件
    #include &lt;stdio.h&gt;
    #include &quot;encrypt.h&quot;

    int main()
    {
        char msg[80];
        while(fgets(msg, 80, stdin)) {
            encrypt(msg);
            printf(&quot;%s\n&quot;, msg);
        }
    }

3.执行命令(将多个文件编译成一个可执行文件)
    gcc db.c encrypt.c -o db &amp;&amp; ./db
</code></pre><h1 id="如果源文件很多-每次编译都需要耗费很长的时间-如何做到只重新编译改了的文件"><a href="#如果源文件很多-每次编译都需要耗费很长的时间-如何做到只重新编译改了的文件" class="headerlink" title="如果源文件很多,每次编译都需要耗费很长的时间,如何做到只重新编译改了的文件"></a>如果源文件很多,每次编译都需要耗费很长的时间,如何做到只重新编译改了的文件</h1><pre><code>回顾下编译器的工作原理,如果源文件没有进行变化的话,那么只有最后一步需要重新做(也就是链接);如果文件修改了毫无疑问需要重新编译
</code></pre><h1 id="如何做能让gcc把目标代码保存在文件中-然后让编译器把目标文件链接起来"><a href="#如何做能让gcc把目标代码保存在文件中-然后让编译器把目标文件链接起来" class="headerlink" title="如何做能让gcc把目标代码保存在文件中?然后让编译器把目标文件链接起来?"></a>如何做能让gcc把目标代码保存在文件中?然后让编译器把目标文件链接起来?</h1><pre><code>1.首先把源代码编译为目标文件
    gcc -c *.c

2.把目标文件链接起来
    gcc *.o -o demo
</code></pre><h1 id="修改代码的编译流程变成了这样"><a href="#修改代码的编译流程变成了这样" class="headerlink" title="修改代码的编译流程变成了这样"></a>修改代码的编译流程变成了这样</h1><pre><code>1.首次编译
    gcc *.c -o demo

2.修改了test.c文件

3.再次编译
    gcc -c test.c

4.再次链接
    gcc *.o -o demo
</code></pre><h1 id="如果我修改了很多文件-记录下来修改哪些文件也很麻烦"><a href="#如果我修改了很多文件-记录下来修改哪些文件也很麻烦" class="headerlink" title="如果我修改了很多文件,记录下来修改哪些文件也很麻烦"></a>如果我修改了很多文件,记录下来修改哪些文件也很麻烦</h1><pre><code>使用make工具自动化构建
</code></pre><h1 id="make"><a href="#make" class="headerlink" title="make"></a>make</h1><pre><code>make是一个可以运行编译命令的工具。make会检查源文件和目标文件的时间戳,如果目标文件过期,make就会重新编译它
</code></pre><h1 id="需要提供给make的条件"><a href="#需要提供给make的条件" class="headerlink" title="需要提供给make的条件"></a>需要提供给make的条件</h1><pre><code>1.依赖项;生成目标需要用哪些文件
2.生成方法;生成该文件时要用哪些指令
例如
    将demo.c编译成demo.o,依赖项和生成方法分别是什么?
    demo.o就是目标,因为需要生成这个文件,demo.c就是依赖项,因为编译器创建demo.o的时候需要它
    生成方法就是将demo.c转化成demo.o的命令也就是gcc -c demo.c
</code></pre><h1 id="怎样把依赖项和生成方法告诉make"><a href="#怎样把依赖项和生成方法告诉make" class="headerlink" title="怎样把依赖项和生成方法告诉make"></a>怎样把依赖项和生成方法告诉make</h1><pre><code>所有目标,依赖项和生成方法的细节信息需要保存在一个叫makefile或Makefile的文件中
拿加密的例子说:
最终的加密程序db由encrypt.o和db.o文件链接组成,这两个文件是由C文件和头文件编译而成,db.o依赖encrypt.h文件,因为db.o需要调用encrypt.c中的函数
db.o: db.c encrypt.c encrypt.h
    gcc -c db.c

encrypt.o: encrypt.c encrypt.h
    gcc -c encrypt.c

db: db.o encrypt.o
    gcc db.o encrypt.o -o db
</code></pre><h1 id="创建makefile很麻烦"><a href="#创建makefile很麻烦" class="headerlink" title="创建makefile很麻烦"></a>创建makefile很麻烦</h1><pre><code>使用autoconf来自动生成makefile
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">狂奔的菜鸟</p>
              <p class="site-description motion-element" itemprop="description">狂奔的菜鸟</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">153</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/SunnySmilez" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:phpchengxuyuan@sina.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.taichirain.cn/" title="taichirain" target="_blank">taichirain</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.chenjie.info/" title="陈捷的博客" target="_blank">陈捷的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://52dachu.com/" title="大神-0x0886" target="_blank">大神-0x0886</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://phpmap.club/" title="程序员之路" target="_blank">程序员之路</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2014 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">狂奔的菜鸟</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="/gitment/gitment1.css">
        <script src="/gitment/gitment1.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  
  

  

  

  

</body>
</html>
